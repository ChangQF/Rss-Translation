<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Fri, 20 Sep 2024 12:31:45 GMT</lastBuildDate>
    <item>
      <title>使用 rma.mv 的不同结果：Mods 与 Subset</title>
      <link>https://stats.stackexchange.com/questions/654648/different-results-using-rma-mv-mods-vs-subset</link>
      <description><![CDATA[我正在使用 metafor 在 R 中进行三级荟萃分析。在计算子组分析时，我注意到一个子组的假定汇总效应与我仅对特定子组进行相同分析时得到的汇总效应不同（如 http://www.metafor-project.org/doku.php/tips:comp_two_independent_estimates 中所述）。问题是，尽管估计值之间的差异并不大，但结论仍然在某种程度上取决于我选择的汇总效应。因此，我将不胜感激任何有关选择正确方法的帮助。
以下是一些伪代码来说明我的问题：
rma.mv(
yi = yi, 
V = vi,
mod = ~ Moderator-1,
random = ~ 1 | study_id / es_id, # 嵌套在每篇论文中的效应大小
slab = paste0(author, &quot;, &quot;, year),
data = my_data,
method = &quot;REML&quot;,
digits = 3
)

# versus #
rma.mv(
yi = yi, 
V = vi,
subset = Moderator == &quot;Moderator Level 1&quot;,
random = ~ 1 | study_id / es_id, # 嵌套在每篇论文中的效应大小
slab = paste0(author, &quot;, &quot;, year),
data = my_data,
method = &quot;REML&quot;,
数字 = 3
)
]]></description>
      <guid>https://stats.stackexchange.com/questions/654648/different-results-using-rma-mv-mods-vs-subset</guid>
      <pubDate>Fri, 20 Sep 2024 12:05:48 GMT</pubDate>
    </item>
    <item>
      <title>如何比较嵌套预测算法的泛化误差？</title>
      <link>https://stats.stackexchange.com/questions/654647/how-to-compare-generalization-errors-of-nested-prediction-algorithms</link>
      <description><![CDATA[假设我想比较两种嵌套预测算法，例如基于 Lasso 回归的预测模型，无论是否带有预测变量 Z。在第一个算法中，Z 在变量选择中不可用，而在第二个算法中，它将作为“新变量”可用，并在有用时包含在模型中。
为了评估 Z 在预测中的有用性，我将报告两种算法的泛化（又称样本外）预测误差。为此，我使用嵌套交叉验证或乐观调整引导法。由于第二种算法（Z 可用）只是第一种算法（Z 不可用）的扩展，因此第二种算法的泛化误差必然小于或等于第一种算法。
我的问题是：我应该如何确定第二个预测误差是否明显较小，从而表明新变量 Z 的预测潜力？如果我使用乐观调整的引导方法，我可以使用引导样本计算泛化误差估计的标准误差吗？如果我使用嵌套交叉验证，

在这种情况下，也可以直接计算标准误差吗？在我看来，计算每个折叠的两种算法之间的性能指标（例如 RMSE）差异，然后报告这些差异的平均值及其标准误差是有意义的。
我认为这是比较嵌套预测模型的一个重要问题，但似乎经常被忽视。通常，报告和比较泛化误差时不考虑估计中的不确定性，我认为这是不充分的。]]></description>
      <guid>https://stats.stackexchange.com/questions/654647/how-to-compare-generalization-errors-of-nested-prediction-algorithms</guid>
      <pubDate>Fri, 20 Sep 2024 10:53:52 GMT</pubDate>
    </item>
    <item>
      <title>非正态分布的中位数相等性检验</title>
      <link>https://stats.stackexchange.com/questions/654644/median-equality-test-for-non-normal-distributions</link>
      <description><![CDATA[尽管许多文章都肯定，当违反正态性假设时，我们可以使用 Wilcoxon-Mann-Whitney 检验来比较中位数，但 Wilcoxon-Mann-Whitney 检验不会比较非正态分布之间的中位数：

Wilcoxon 检验有时被称为测试中位数相等，这里有一个证明它不是这样做的
Wilcoxon-Mann-Whitney 检验不比较中位数
对Mann-Whitney(-Wilcoxon) 𝑈 检验作为中位数差异、平均差异或位置偏移（选择您的解释）的检验，其结果来自两个额外的（严格）假设：(i) A 组和 B 组的分布具有相同的形状，(ii) A 组和 B 组的分布具有相同的方差。

如果我们不能使用 Wilcoxon-Mann-Whitney 检验来比较非正态分布的中位数，那么我们可以使用哪种检验来检验非正态分布（具有不同的方差或不同的形状，或两者不同）之间的中位数相等性？]]></description>
      <guid>https://stats.stackexchange.com/questions/654644/median-equality-test-for-non-normal-distributions</guid>
      <pubDate>Fri, 20 Sep 2024 10:27:17 GMT</pubDate>
    </item>
    <item>
      <title>我需要运行泊松 GLMM 吗？</title>
      <link>https://stats.stackexchange.com/questions/654642/do-i-need-to-run-a-poisson-glmm</link>
      <description><![CDATA[我被要求进行 GLMM 来研究哪些条件对圈养动物的某些行为影响最大。因变量是在 10 分钟观察期间花在每个行为上的时间。
有许多固定因素（例如，访客的存在/不存在、天气等）和一些随机因素。研究人员将性别、年龄和受试者 ID 描述为随机因素。
问题：
-将性别和年龄归类为随机因素是否有意义？
-在这种情况下，GLMM 是最佳选择吗？花在每项活动上的时间不是正态分布的，范围从 0-1（花在活动上的时间百分比），我们有重复测量数据（每个受试者在不同条件下被观察多次），所以我相信这是正确的选择。
-如果我继续使用 GLMM，哪个分布系列最适合对因变量进行建模？泊松分布？

使用 GLMM 时，我需要多大程度上担心这些假设？

感谢您的帮助。我之前执行过广义和混合线性模型，但我对 GLMM 不太熟悉。]]></description>
      <guid>https://stats.stackexchange.com/questions/654642/do-i-need-to-run-a-poisson-glmm</guid>
      <pubDate>Fri, 20 Sep 2024 10:03:06 GMT</pubDate>
    </item>
    <item>
      <title>引导检验应给出复合假设的单侧置信区间</title>
      <link>https://stats.stackexchange.com/questions/654641/bootstrap-test-should-give-one-sided-confidence-interval-for-the-composite-hypot</link>
      <description><![CDATA[我想检验假设 $H_0:$ $ C_L=\frac{\mu-L}{\sigma}&lt;c$ vs $H_A:$ $C_L= \frac{\mu-L}{\sigma}&gt;c$，适用于双参数指数分布。我正在尝试进行基于百分位数引导的测试。为此，我正在关注一篇名为“指数分布寿命性能指数的广义置信限度”的论文。论文第 765 页给出了测试，拒绝域基于 95% 的置信下限。我的问题是，

测试不应该是上尾测试吗？应该使用 95% 的置信上限，而不是论文中使用的 95% 的置信下限？
那么使用 bootstrapped 方法的置信上限应该是什么？
拒绝标准应该是什么？
论文在那里犯了错误吗？
]]></description>
      <guid>https://stats.stackexchange.com/questions/654641/bootstrap-test-should-give-one-sided-confidence-interval-for-the-composite-hypot</guid>
      <pubDate>Fri, 20 Sep 2024 10:00:08 GMT</pubDate>
    </item>
    <item>
      <title>如何在多项数据集的模拟中添加随机噪声？</title>
      <link>https://stats.stackexchange.com/questions/654639/how-to-add-random-noise-to-a-simulation-of-a-multinomial-dataset</link>
      <description><![CDATA[我正在尝试创建一个多次试验、多受试者实验的模拟，每次试验有 3 个可能的答案，但我陷入了困境。
假设一个有 N 个受试者的实验，每个受试者进行 X 次试验。在每次试验中，参与者可能会以 [.1,.4,.5] 的速率回答 A、B 或 C。
我正在尝试创建此类实验的模拟，其中还包括每次试验和每个受试者的噪声。
我目前正在做的是将初始概率移动到对数空间，为试验和受试者添加噪声，然后转换为概率空间，将它们传递给 dirilecht 分布以确保它们的总和为 1，然后从中抽样。但是，我不断从低概率空间进行过采样，无法恢复我的初始参数。
library(tidyverse)
library(DirichletReg)

log_odds &lt;- function(probs) {
return(log(probs / (1 - probs)))
}

prob_from_log &lt;- function(logs){
return( exp(logs)/ (1+exp(logs)))
}

sample_from_dirichlet &lt;- function(alpha_params) {
return(rdirichlet(n = 1, alpha = alpha_params))
}

sample_from_multinomial &lt;- function(prob_vector) {
sample &lt;- rmultinom(n = 1, size = 1, prob = unlist(prob_vector))
return(which(sample==1))
}

initial_p &lt;- c(.1,.4,.5) # 初始状态概率

n_trials &lt;- 100 # 要考虑的试验次数

n_subjects &lt;- 100 # 要考虑的最大样本量

subj_int &lt;- .5 # 对数几率中受试者变化截距

error &lt;- .5 # 对数几率中每次试验的残差

# 使用试验创建一个数据框
items &lt;- data.frame(trial_id = rep(seq(n_trials),1), 
condition = rep(c(&quot;base&quot;), c(n_trials)) )

# 使用受试者噪声创建一个数据框
subjects &lt;- data.frame(subj_id = seq_len(n_subjects), 
subj_intercept = I(lapply(1:n_subjects, function(x) rnorm(n=length(initial_p),平均值=0，sd=subj_int))))

试验 &lt;- crossing(subjects, items) %&gt;% # 合并项目和受试者数据框
mutate(e_si =I(lapply(1:nrow(.), function(x) rnorm(n=length(initial_p), mean=0, sd=error))), # 创建试验特定噪声
initial_p_values= I(rep(list(initial_p), nrow(.))), # 添加概率向量
log_p= I(lapply(initial_p_values, log_odds)), # 将概率转换为对数几率
total_noise = map2(subj_intercept, e_si, ~ .x + .y), # 合并噪声源 (subject+trial)
final_log = map2(log_p, total_noise, ~ .x + .y), # 合并对数几率向量和噪声
final_p_non_sum = I(lapply(final_log, prob_from_log)), # 返回概率
alpha_params = I(lapply(final_p_non_sum, function(p) p * 1000)), # 缩放概率以用作 dirichlet 中的 alpha 参数
dirichlet_sample = I(lapply(alpha_params, sample_from_dirichlet)), # 总和为 1 的样本概率
sample_state = lapply(dirichlet_sample,sample_from_multinomial)) # 从多项分布中抽样

trials %&gt;% 
group_by(sample_state) %&gt;% 
count() %&gt;% 
mutate(perc=n/(n_trials*n_subjects)) -&gt; res

打印（res）
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/654639/how-to-add-random-noise-to-a-simulation-of-a-multinomial-dataset</guid>
      <pubDate>Fri, 20 Sep 2024 09:53:44 GMT</pubDate>
    </item>
    <item>
      <title>我们可以在逻辑回归中包含后指数变量吗</title>
      <link>https://stats.stackexchange.com/questions/654638/can-we-include-post-index-variables-in-a-logistics-regression</link>
      <description><![CDATA[如果事件发生在终点之前，我们可以将索引后事件纳入逻辑回归吗？
我必须进行回归分析以了解哪些患者继续服药。我将索引日期作为他们开始服用药物 x 的日期。患者在开始服用药物 x 之前的所有特征（基线特征）用于预测他们是否会继续接受治疗到 1 年。我有兴趣在这个回归中添加一个变量来查看 6 个月后药物的效果。我可以这样做吗？或者这在统计上不合理，因为本质上这个变量是索引后？
继续治疗 1 年（1 或 0）~ 开始治疗前的患者特征 + 6 个月时治疗的效果]]></description>
      <guid>https://stats.stackexchange.com/questions/654638/can-we-include-post-index-variables-in-a-logistics-regression</guid>
      <pubDate>Fri, 20 Sep 2024 09:23:12 GMT</pubDate>
    </item>
    <item>
      <title>变换随机变量的特征函数</title>
      <link>https://stats.stackexchange.com/questions/654637/characteristic-function-of-transformed-random-variable</link>
      <description><![CDATA[考虑一个随机变量 $X$ 和一个函数 $g(\cdot)$。令 $Y:=g(X)$，令 $\phi_X(\cdot), \phi_Y(\cdot)$ 分别为 $X,Y$ 的特征函数 (cf)。
进一步假设 $\phi_X$ 处处非零。我要求在变换 $g$ 上满足一个条件，在该条件下 $\phi_Y$ 处处也非零。]]></description>
      <guid>https://stats.stackexchange.com/questions/654637/characteristic-function-of-transformed-random-variable</guid>
      <pubDate>Fri, 20 Sep 2024 08:04:56 GMT</pubDate>
    </item>
    <item>
      <title>停车场问题及其变体</title>
      <link>https://stats.stackexchange.com/questions/654636/parking-lot-problem-and-its-variations</link>
      <description><![CDATA[有人能用非常简单的、循序渐进的方式解释下面的问题吗？最后解释一下我需要如何思考它的变化，比如想象他们是 3 个人而不是 2 个人，或者他们可以在最多 2 个停车位之间停车，或者两者兼而有之。
提前非常感谢，我非常感谢这个社区的帮助。
Mary 和 Tom 将他们的车停在一个空停车场，停车场有 n&gt;=2 个连续的停车位（即，连续 n 个停车位，每个停车位只能容纳一辆车）。Mary 和 Tom 随机选择停车位；当然，他们必须各自选择不同的停车位。（所有不同的停车位对都有同等的可能性。）他们之间最多有一个空停车位的概率是多少？
您的答案应该是 n 的函数。]]></description>
      <guid>https://stats.stackexchange.com/questions/654636/parking-lot-problem-and-its-variations</guid>
      <pubDate>Fri, 20 Sep 2024 07:42:47 GMT</pubDate>
    </item>
    <item>
      <title>预测模型与规划模型的比较</title>
      <link>https://stats.stackexchange.com/questions/654635/comparison-of-predictive-and-planning-model</link>
      <description><![CDATA[我正在选择一个主题来进行这方面的研究。预测和规划的理念经常发生冲突。它们一方面看起来相似，另一方面又不同。我找不到任何明显的区别。我想知道它们之间的区别；所以，你能分享你的想法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/654635/comparison-of-predictive-and-planning-model</guid>
      <pubDate>Fri, 20 Sep 2024 07:22:46 GMT</pubDate>
    </item>
    <item>
      <title>集成指数交替更新过程是马尔可夫链吗？</title>
      <link>https://stats.stackexchange.com/questions/654634/is-an-integrated-exponential-alternating-renewal-process-a-markov-chain</link>
      <description><![CDATA[考虑一个交替更新过程，其中交替范围是独立的指数分布，平均值为 mu_0 和 mu_1。交替范围决定了任何时刻的结果是零还是一。所以我们看到一个范围显示零，然后是一个范围显示一，等等。想象一下，这些二进制结果是在连续的相邻的恒定宽度窗口上取平均值。我们将这些平均值称为二进制分数。这些二进制分数是否是马尔可夫链过程，即下一个分数的概率分布仅由当前分数决定。
我的逻辑表明它不是。为了简化这个问题，假设我们有一个离散的二进制 (0,1) 马尔可夫链过程。我们叠加单独的恒定长度 2 的连续窗口，并测量每个窗口内的链处于状态一的时间比例（二进制分数），状态为 (0、0.5 或 1)。现在很明显，当前分数的结果取决于前一个分数的结果。这是由于当前窗口的两个贡献（马尔可夫链）结果中的最后一个与前一个窗口的第一个结果之间存在马尔可夫链关系。这本身就表明分数之间的关系到此结束，并且我们有一个马尔可夫链。
但是，我们并不确切知道构成原始序列中滞后一关系的原始序列的两个值的完整结果（我们所拥有的只是来自每个窗口的二进制分数）。事实上，一些（尽管不完整但仍然有贡献的）关于它们的值的想法是由另一个窗口的分数中的信息提供的。因此，当前分数与过去一步的分数相关（由于马尔可夫链属性），也与过去两步的分数相关（由于滞后二分数的信息增强）。因此，这不是马尔可夫链过程。
为了进一步说明，使用上面的插图，假设滞后一分数为 0.5。这表明，先验地有 0.5 的概率，基础序列值为 0,1（左侧为最新值），有 0.5 的概率为 1,0。但是，进一步想象一下，滞后二分数为 1，这意味着贡献序列的结果为 1,1。如果马尔可夫链过程涉及反映“粘性”状态的转移概率，且切换概率相对较低，则滞后一窗口的基础序列值更可能是 0,1，而不是 1,0。这反过来又会影响滞后零分数，从而违背了马尔可夫链的定义。
这个总体推理可以扩展到指数交替更新过程，即连续马尔可夫链。本质上，每个窗口中的原始序列数量趋近于无穷大，并且当 delta -&gt; 0 时，非切换概率趋近于 1-delta*lambda（其中 delta 是状态记录之间的间隔），但逻辑是相同的。因此，指数交替更新过程的积分“似乎”不会产生马尔可夫链过程。]]></description>
      <guid>https://stats.stackexchange.com/questions/654634/is-an-integrated-exponential-alternating-renewal-process-a-markov-chain</guid>
      <pubDate>Fri, 20 Sep 2024 07:18:45 GMT</pubDate>
    </item>
    <item>
      <title>缺少置信区间的 ROC 区域的 Meta 分析</title>
      <link>https://stats.stackexchange.com/questions/654632/meta-analysis-of-roc-areas-with-missing-confidence-interval</link>
      <description><![CDATA[我正在根据 30 份报告对从 0 到 10 的诊断评分进行荟萃分析。对于每份报告，我都有一个（有时是两个）截点（低和高）的假阳性/真阳性/阴性患者人数数据。我计划对这些结果的敏感性和特异性进行荟萃分析。
对于大多数报告，我也有关于完整评分的 ROC 面积的信息，但对于大多数报告，我错过了置信区间。
我当然可以根据截点进行 ROC 估计，但更愿意使用完整评分提供的 ROC 面积。我可以使用报告的 ROC 面积和每份报告的患者总数作为权重来汇总 ROC 面积吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/654632/meta-analysis-of-roc-areas-with-missing-confidence-interval</guid>
      <pubDate>Fri, 20 Sep 2024 07:03:23 GMT</pubDate>
    </item>
    <item>
      <title>随机森林预测区间 - 新观测值的总和</title>
      <link>https://stats.stackexchange.com/questions/654629/random-forest-prediction-intervals-sum-of-new-observations</link>
      <description><![CDATA[我对随机森林还比较陌生，但一直在尝试各种可用的 R 包。到目前为止一切顺利。但对于我的应用程序，我正在用多个预测变量建模一个响应变量，这很好，但我真正需要做的是使用生成的模型来预测新数据的值。这很好，我收到一组新的预测变量并预测新的未观察响应变量的值。
但是，问题是我对这些单独的新变量并不真正感兴趣，而是对它们的总和感兴趣。这也很好，我只是将每个预测值相加，这就是我感兴趣的参数估计。但是，我真的还想估计与此相关的预测区间。我可以看到有各种方法和 R 包可以对单个变量执行此操作，例如 Meinhausen 的分位数回归森林方法（和包 quantregForest），基于 bootstrapping 或 jackknife 的替代方法。但尚未找到允许对派生参数（例如对各个变量求和）进行预测区间的方法？
我发现了关于随机森林预测区间的先前问题的一些非常有趣的评论，但没有关于如何对派生参数进行预测的明显信息。也许我很天真，错过了它？
我发现最接近的是这个：
随机森林预测区间的总和？
这基本上是我的确切问题，但实际上没有得到充分的回答。
如果有人有任何想法或可以指出我对此事的一些讨论，我将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/654629/random-forest-prediction-intervals-sum-of-new-observations</guid>
      <pubDate>Fri, 20 Sep 2024 05:40:10 GMT</pubDate>
    </item>
    <item>
      <title>R中一个记录和另一个数据集之间的Gower距离</title>
      <link>https://stats.stackexchange.com/questions/654646/gower-distance-between-one-record-and-another-dataset-in-r</link>
      <description><![CDATA[我想计算数据集 1 的一条记录与数据集 2 的所有记录之间的 Gower 距离。我可以编写如下代码吗？
library(gower)

data(iris)
dat1 &lt;- iris[1:10,]
dat2 &lt;- iris[11:30,]

gower::gower_dist(dat1[1,], dat2)

这给了我长度为 20 的结果。

0.09079365 0.09873016 0.16142857 0.29476190 0.20920635 0.33079365 0.21936508 0.05000000 0.23952381 0.11507937 0.12095238 0.15079365 0.16984127 0.24523810 0.16539683 0.12920635 0.17206349 0.03555556 0.02761905 0.14063492

我可以将第一个值解释为 dat1[1,] 和 dat2[1,] 之间的 gower 距离，将第二个值解释为 dat1[1,] 和 dat2[2,] 之间的 gower 距离，依此类推吗？
让我感到困惑的是，如果我计算
gower::gower_dist(dat1[1,],dat2[1,])

，这给了我

0.75

它应该是 0.09079365 吗？为什么是 0.75？
最终，我想计算 dat1 中每个观测值与 dat2 中每个观测值的 gower 距离。]]></description>
      <guid>https://stats.stackexchange.com/questions/654646/gower-distance-between-one-record-and-another-dataset-in-r</guid>
      <pubDate>Fri, 20 Sep 2024 01:30:11 GMT</pubDate>
    </item>
    <item>
      <title>当每个数据点都带来一个置信区间时，如何在两个或多个组之间进行检验？</title>
      <link>https://stats.stackexchange.com/questions/654615/how-to-run-a-test-between-two-or-more-groups-when-each-data-point-brings-a-confi</link>
      <description><![CDATA[早上好，
我最近开始研究一个数据集，但作为一名应届毕业生，我的经验有限，这阻碍了我取得进展。在执行了项目所需的稀疏化之后，我现在有一个包含 24 个物种多样性指数的数据框，每个指数都伴随着由随机稀疏化过程生成的置信区间。这 24 个多样性指数属于 2 个不同的非独立组，我需要进行比较。如果没有置信区间，我只能使用均值，我会使用配对 t 检验。
为了解释通过稀疏化获得的置信区间，我尝试使用从区间得出的方差执行加权 t 检验。但是，我对我的方法没有信心，也找不到任何支持这种方法的在线文章。谢谢您的帮助。
这是我的数据框：
size1 &lt;- c(32.67256,30.59280,33.56214,30.15552,29.02073,24.92427,34.79967,34.26559,29.33457,25.75716,27.91638,33.87884)
size2 &lt;-c(34.18847,30.94369,37.38462,22.96785,27.98805,31.39834,30.26401,33.59788,36.19856,31.19667,21.27245,28.87137)
尺寸 &lt;-c(尺寸1,尺寸2)
尺寸1CI05 &lt;-c(29.50177,26.23491,29.60487,25.94388,24.48941,21.78924,29.24082,28.09738,25.20056,21.21051,24.40705,30.08490)
size2CI05 &lt;-c(29.51654,23.75201,31.29203,17.60071,21.92296,26.38236,23.69115,26.15880,26.44932,26.72620,17.48761,23.76434)
sizeCI05 &lt;-c(size1CI05,size2CI05)
size1CI95 &lt;-c(35.84336,34.95070,37.51941,34.36716,33.55205,28.05929,40.35851,40.43380,33.46857,30.30381,31.42571,37.67278) 
size2CI95 &lt;-c(38.86039,38.13538,43.47722,28.33500,34.05315,36.41432,36.83687,41.03696,45.94780,35.66713,25.05730,33.97840)
sizeCI95 &lt;-c(size1CI95,size2CI95)
group &lt;- c(c(rep(&quot;1&quot;,12),rep(&quot;2&quot;,12))
df &lt;-data.frame(size,sizeCI05,sizeCI95,group)

我还按要求添加了 dput 输出：
df &lt;-structure(list(size = c(32.67256, 30.5928, 33.56214, 30.15552, 
29.02073, 24.92427, 34.79967, 34.26559, 29.33457, 25.75716, 27.91638, 
33.87884, 34.18847, 30.94369, 37.38462, 22.96785, 27.98805, 31.39834, 
30.26401, 33.59788, 36.19856, 31.19667, 21.27245, 28.87137), 
size05CI = c(29.5017662019491, 26.2349058385758, 29.6048735822698, 
25.9438818737996, 24.4894140422372, 21.7892435074709, 29.2408246478003, 
28.097376313181, 25.2005633026381, 21.2105115402011, 24.4070457401779, 
30.0849045894848, 29.5165407340379, 23.7520071901393, 31.2920265619889, 
17.6007091843407, 21.9229562124319, 26.3823600157115, 23.6911524798744, 
26.158796800294, 26.4493176960902, 26.7262037524753, 17.4876088906701, 
23.7643440166671), size95CI = c(35.8433590913617, 34.9506991382152, 
    37.5194133001315、34.3671592174968、33.5520534941053、28.0592932279925、40.3585126169722、40.4338032764411、33.46857135214 04、30.303809204322、31.4257104335821、37.6727751129716、38.8603902871733、38.1353758799793、43.4772171945701、 28.3349990423006, 34.0531465846994, 36.4143170389483, 
36.8368654619253, 41.0369594182707, 45.9478039221974, 35.6671344715295, 
25.0572999101401, 33.9783955274194), group = c(&quot;1&quot;, &quot;1&quot;, 
&quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, 
&quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;)), class = &quot;data.frame&quot;, row.names = c(NA, 
-24L))

这是我尝试做的：
install.packages(&quot;weights&quot;,dependencies=T)
library(weights)
SE1 &lt;-(size1CI95-size1CI05)/3.919928
SE2 &lt;-(size2CI95-size2CI05)/3.919928
sizepaired &lt;-size1-size2
combSE &lt;-sqrt(SE1^2+SE2^2)
weights &lt;-1/combSE^2
wtd.t.test(x=sizepaired,y=0,weight=weights)

我的方法是使用加权检验来考虑由于检验中的稀疏性而产生的置信区间（即标准偏差），其中权重来自标准偏差。但是，我不确定这是否是一种有效的方法，而且我还没有找到任何涉及这种方法的科学文章。我的同事有些怀疑，不愿意使用“实验性”方法。
此外，我目前正在使用参数检验，但在我的数据中（我没有在这里包括），有些数据不遵循正态分布。因此，我应该考虑如何进行加权配对非参数检验]]></description>
      <guid>https://stats.stackexchange.com/questions/654615/how-to-run-a-test-between-two-or-more-groups-when-each-data-point-brings-a-confi</guid>
      <pubDate>Thu, 19 Sep 2024 16:36:06 GMT</pubDate>
    </item>
    </channel>
</rss>