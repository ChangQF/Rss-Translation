<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Mon, 18 Dec 2023 18:17:22 GMT</lastBuildDate>
    <item>
      <title>研究样本设计的好教科书</title>
      <link>https://stats.stackexchange.com/questions/635207/good-textbooks-to-study-the-sample-design</link>
      <description><![CDATA[我将编写一些有关统计样本调查方法的高级主题的测试，其中包括如下主题
简单随机抽样、系统抽样、PPS 抽样、分层抽样。
比率和回归估计方法。非抽样误差、非响应偏差
好的大学针对上述主题会参考哪些教科书？有很多解决方案的教科书会非常好。]]></description>
      <guid>https://stats.stackexchange.com/questions/635207/good-textbooks-to-study-the-sample-design</guid>
      <pubDate>Mon, 18 Dec 2023 17:26:59 GMT</pubDate>
    </item>
    <item>
      <title>glmms 中的哪些系列和链接函数？</title>
      <link>https://stats.stackexchange.com/questions/635206/which-family-and-link-function-in-glmms</link>
      <description><![CDATA[我正在尝试 GLMM 模型来测试两个分类变量（物种和性别）及其相互作用（性别 + 物种 + 性别*物种 = 固定因素）是否影响某些发声的某些声学参数（响应变量）。我的响应变量是连续数值，例如发声的基本频率或持续时间。因此，我正在为我拥有的每个声学参数尝试不同的 glmm。
我的响应变量没有正态分布，它们非常不对称，其中一个有两个中央驼峰。
例如，我尝试过基频、进行对数变换，以及使用伽马或高斯与各种链接函数（对数、逆），但当我检查假设（正态性、残差同质性）时，这些都没有得到验证。
您推荐哪些系列和链接功能？在运行 glmm 之前我应该​​做些什么（例如日志转换、标准化）？ （显然，我在运行模型之前将分类变量转换为因子）
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/635206/which-family-and-link-function-in-glmms</guid>
      <pubDate>Mon, 18 Dec 2023 17:26:39 GMT</pubDate>
    </item>
    <item>
      <title>ROC 综合生物标志物</title>
      <link>https://stats.stackexchange.com/questions/635204/intergrated-biomarkers-for-roc</link>
      <description><![CDATA[我正在寻找组合多个定量值的方法，以便构建具有特异性和敏感性的 ROC 曲线。这似乎在多种生物标记论文中很常见，但我找不到任何直接的方法来做到这一点。 CombiROC 似乎就是为此而设计的，但 Shinyapp 不再工作，软件包也没有更新，这让我质疑它的用途。
我对一组具有各种临床表现的患者的血清进行了多重分析，以量化蛋白质浓度，并发现其中一些是相关的。单独使用这些蛋白质，我可以构建 ROC 曲线。我想进一步推动我的分析，建立一个模型，在其中我可以组合/整合这些标记中的 2 或 3 个，从而完善诊断并获得更好的 AUC/Spe/Sen 值。
到目前为止，这是我发现的方法：我首先构建一个 glm 模型，从中预测落入该组的机会。最后，我通过绘制预测结果与实际结果来计算 ROC。
#与临床组一起构建 glm（二元结果）
组合.glm &lt;- glm(数据集$Group1 ~
                               数据集$分析物1 +
                               数据集$Analyte2 +
                               数据集$分析3，
                               家庭=“二项式”）

#使用模型预测小组结果
数据集$prob.Group1=预测(Combined.glm,type=c(“响应”))

#建立ROC
roc&lt;- roc(数据集$Group1, dataset$prob.Group1)

我想知道这是否是正确的方法，如果不是，应该怎么做？
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/635204/intergrated-biomarkers-for-roc</guid>
      <pubDate>Mon, 18 Dec 2023 16:48:22 GMT</pubDate>
    </item>
    <item>
      <title>使用旧的后验作为给定新数据的新先验[重复]</title>
      <link>https://stats.stackexchange.com/questions/635201/using-old-posterior-as-new-prior-given-new-data</link>
      <description><![CDATA[假设我有一些数据，并使用这些数据创建后验分布。
现在假设我有一些新数据，我相信这些数据与之前的数据来自同一人群。考虑到我的新数据，我现在可以使用旧的后验分布作为新的先验分布吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635201/using-old-posterior-as-new-prior-given-new-data</guid>
      <pubDate>Mon, 18 Dec 2023 16:39:41 GMT</pubDate>
    </item>
    <item>
      <title>我可以在计算 CI 之前删除单个引导样本吗？</title>
      <link>https://stats.stackexchange.com/questions/635200/can-i-remove-a-single-bootstrap-sample-before-calculating-ci</link>
      <description><![CDATA[我将 boot::boot 与 BCa 结合使用来评估二项式模型的不确定性估计。统计函数通过 G-computation 手动编码为集群引导程序（完整解释和可复制代码：https://stats.stackexchange .com/a/620201/323174）。
在极少数情况下，我得到的样本仅包含一些聚类级别，该样本返回不完整的样本估计（即，一个聚类级别之一缺少行的表）。作为响应，引导功能失败并出现错误（boot::boot line 124: ...t.star[r, ] &lt;- res[[r]] 给出：要替换的项目数不是替换长度的倍数）。
为了解决这个问题，我编辑了 boot::boot 函数来删除不完整的样本，并返回一个带有更新的 R 的较小引导程序。
例如，这个引导程序：
boot_out.rrt.dich.uo &lt;- boot(pair_ids, boot_fun_by,
                         R = 99)

返回：
普通非参数引导程序


称呼：
启动（数据=pair_ids，统计=boot_fun_by，R=98）


引导统计：
        原始偏差标准错误
t1* 3.494313e-01 2.572816e+11 2.546256e+12
t2* 2.746097e+13 -2.622462e+1​​3 5.558065e+12
t3* 1.415745e-11 4.028178e+03 1.470726e+04

请注意，函数中的 R = 99 在结果中变为 R = 98（实际代码在 boot::boot 中更改） code&gt; 函数可以在此 fork 中看到。 ）
除了减少样本数量之外，这是否会影响使用 type = &quot;bca&quot; 进行 boot::boot.ci 的计算？]]></description>
      <guid>https://stats.stackexchange.com/questions/635200/can-i-remove-a-single-bootstrap-sample-before-calculating-ci</guid>
      <pubDate>Mon, 18 Dec 2023 16:38:14 GMT</pubDate>
    </item>
    <item>
      <title>证明 K-means 对应于 EM 算法？</title>
      <link>https://stats.stackexchange.com/questions/635199/proving-that-k-means-corresponds-to-an-em-algorithm</link>
      <description><![CDATA[只是想确保我的证明是正确的，并且我在此过程中没有遗漏任何内容。有什么想法吗？
”
为了从数学上证明K-means算法对应于期望最大化算法，我们需要证明对于似然函数和先验分布的特定选择，K-means算法可以从EM算法导出。
K 均值算法可以从具有相等协方差矩阵的 K 个高斯混合的 EM 算法导出。在这种情况下，似然函数由下式给出：
$$p(x_n|z_n=k,\mu_k,\Sigma)=\frac{1}{(2\pi\sigma^2)^{D/2 }}\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_k\|^2\right)$$
其中 $x_n$ 是第 $n$ 个数据点，$z_n$ 是表示 $x_n$ 的簇分配的潜在变量，$ \mu_k$ 是第 $k$ 个簇的平均值，$\Sigma$ 是协方差矩阵，$\sigma^2$ 是公共方差。
先验分布由下式给出：
$$p(z_n=k)=\frac{1}{K}$$
假设每个簇的可能性相同。
这种高斯混合的 EM 算法由下式给出：

随机初始化均值$\mu_k$。
E-step：根据数据 $x_n$ 计算聚类分配的后验概率 $z_n$ span&gt; 和当前的意思 $\mu_k$:

$$r_{nk}=\frac{\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_k\|^ 2\right)}{\sum_{j=1}^K\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_j\|^2\right)}$$&lt; /跨度&gt;
其中 $r_{nk}$ 是第 $k$ 集群的责任第 $n$ 个数据点。

M-step：使用职责更新方法$\mu_k$：

$$\mu_k=\frac{\sum_{n=1}^N r_{nk}x_n}{\sum_{n=1}^N r_{nk} }$$

重复步骤 2 和 3，直至收敛。

现在，让我们证明 K-means 算法与该 EM 算法相对应。 K-means 算法由下式给出：

随机初始化均值$\mu_k$。
分配步骤：将每个数据点分配给最接近的聚类均值：

$$z_n=\arg\min_k\|x_n-\mu_k\|^2$$

重新拟合步骤：将均值 $\mu_k$ 更新为分配给它们的数据点的平均值：

$$\mu_k=\frac{1}{N_k}\sum_{n:z_n=k}x_n$$
其中 $N_k$ 是分配给第 $k$ 个集群的数据点数量.
通过设置 $\sigma^2=\frac{1}{ 可以看出，K-means 算法对应于等协方差矩阵高斯混合的 EM 算法2}$ 和 $r_{nk}=1$ 如果 $z_n=k$和 $r_{nk}=0$ 否则。在这种情况下，似然函数简化为：
$$p(x_n|z_n=k,\mu_k)=\frac{1}{\sqrt{2\pi}}\exp\left(-\frac{ 1}{2}\|x_n-\mu_k\|^2\right)$$
这是具有单位方差的高斯分布。先验分布由下式给出：
$$p(z_n=k)=\frac{1}{K}$$
假设每个簇的可能性相同。
EM 算法的 E 步简化为：
$$r_{nk}=\begin{cases}1 &amp; \text{if }z_n=k\\0 &amp; \text{其他}\end{案例}$$
这相当于K-means算法的赋值步骤。
EM 算法的 M 步简化为：
$$\mu_k=\frac{\sum_{n=1}^N r_{nk}x_n}{\sum_{n=1}^N r_{nk} }=\frac{1}{N_k}\sum_{n:z_n=k}x_n$$
这相当于K-means算法的重新拟合步骤。
因此，我们已经证明，K 均值算法对应于似然函数和先验分布的特定选择的期望最大化算法。”]]></description>
      <guid>https://stats.stackexchange.com/questions/635199/proving-that-k-means-corresponds-to-an-em-algorithm</guid>
      <pubDate>Mon, 18 Dec 2023 16:14:53 GMT</pubDate>
    </item>
    <item>
      <title>计算到核 PCA 子空间的正交距离（使用新数据）</title>
      <link>https://stats.stackexchange.com/questions/635198/calculating-the-orthogonal-distance-to-kernel-pca-subspace-with-a-new-data</link>
      <description><![CDATA[我正在研究内核 PCA 方法，现在我正在尝试计算特征空间上的正交距离 (OD)。我发现，如果您对训练观察结果之一感兴趣，您可以使用内核技巧来计算 OD。但是，我找不到计算新观察值和之前创建的内核 PCA 子空间之间 OD 的方法。
让 $X$ 成为我们的训练集，以行作为观察值，$\phi$ 映射到特征空间，$k$ 我们的 Mercer 内核和 $K$ 我们的内核矩阵 $K_{i,j} = k(x_i, x_j)$。单个观测值的 OD 由以下方程给出。
$$
OD_i = \| \phi(x_i) - \widehat{\phi(x_i)} \|,
$$
其中 $\widehat{\phi(x)}$ 是 $\phi(x)$ 在内核 PCA 子空间上。通过核技巧和毕达哥拉斯定理，我们可以得到以下结果。
\begin{eqnarray*}
OD_i^2 &amp;=&amp; \| \phi(x_i) - \widehat{\phi(x_i)} \|^2 = \| \phi(x_i) - \hat\mu \|^2 + \| \widehat{\phi(x_i)} - \hat\mu \|^2 \text{
 （毕达哥拉斯）} \\
  &amp;=&amp; \langle \phi(x_i) - \hat\mu, \phi(x_i) - \hat\mu \rangle - \sum_{j=1}^k {t_{ij}^2} \\
  &amp;=&amp; (K_c)_{i,i} - \sum_{j=1}^k {t_{ij}^2}
\end{eqnarray*}
$\hat\mu$ 是 KPCA 子空间的中心估计。在求和部分中 $t_{ij}$ 只是第一个 $k$ 主成分的元素。推导仅根据毕达哥拉斯定理，但您可以忽略它。
我的问题是，当我使用 $x_{\text{test}}$ 时，该 $x_{\text{test}}$ 未用于创建 $K$，我找不到$(K_c)_{i,i}$。我该如何将方程更改为没有 $(K_c)_{i,i}$ 的形式？
我尝试将 $\frac{1}{n} \sum_{l=1}^n \phi(x_l)$ 替换为 $\hat\mu$ 并找到了一个合理的结果，但在数字上我无法复制以前的结果。然而，有趣的是，结果是相关的，相关参数为 $0.85$（当我在模拟中使用较少数量的样本时，相关参数甚至更高）。
我的两个资源：
http://dx.doi.org/10.1016/j.patcog .2006.07.009（第6页）
https://doi.org/10.1007/s11634-010-0068-1 （第 160 页）]]></description>
      <guid>https://stats.stackexchange.com/questions/635198/calculating-the-orthogonal-distance-to-kernel-pca-subspace-with-a-new-data</guid>
      <pubDate>Mon, 18 Dec 2023 16:12:50 GMT</pubDate>
    </item>
    <item>
      <title>从具有任意权重的多个基础分布中分析估计联合 Von Mises 分布参数</title>
      <link>https://stats.stackexchange.com/questions/635197/analytically-estimate-joint-von-mises-distribution-parameters-from-multiple-unde</link>
      <description><![CDATA[给定一组 n 一维（圆形）Von Mises 分布，可以对每个分布进行随机采样（使用不同的权重 w，应用于每个分布）分布）并估计单个联合分布的参数 mu 和 k。
使用r包circular可以直接实现这一点。然而，对于我的实时 Java 实现，随机采样和最大似然估计步骤的计算成本很高。
是否可以分析计算此联合分布的参数 mu 和 k？对于我的应用程序，可以进行一些简化的近似，以提供接近但不相同的结果。
库（循环）

## 生成圆形对象的辅助函数，角度范围为 0-360
circularDeg &lt;- 函数(x) 圆形(x,template = “地理”,units = “度”, modulo = “2pi”)
theta &lt;-circularDeg(seq(从 = 0, 到 = 360,by = 1))

m1 &lt;- 圆度(180)
k1 &lt;- 2.1
w1 &lt;- 1.5
dvm1 &lt;- dvonmises(theta,mu = m1, kappa = k1)

m2 &lt;- 圆形度(270)
k2 &lt;- 1.4
w2 &lt;- 1.7
dvm2 &lt;- dvonmises(theta,mu = m2, kappa = k2)

m3 &lt;- 圆形度(135)
k3 &lt;- 0.7
w3 &lt;- 7.2
dvm3 &lt;- dvonmises(theta,mu = m3, kappa = k3)

## 基于从每个带有权重的分布中随机抽取的联合分布进行采样
关节 &lt;- mle.vonmises(c(rvonmises(ceiling(100000 * w1), m1,k1),
                        rvonmises(天花板(100000 * w2), m2,k2),
                        rvonmises(天花板(100000 * w3), m3,k3)))
dvmJoint &lt;- dvonmises(theta,joint$mu, joint$kappa)



## 绘制代码
情节_ly（）|&gt;
  add_lines(x = theta, y = dvm1, name = Past0(&quot;分布 1: m = &quot;,m1,&quot;, k = &quot;,k1,&quot;, 权重 = &quot;,w1),
            line = list(color = &quot;steelblue&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvm2, name = Paste0(&quot;分布 2: m = &quot;,m2,&quot;, k = &quot;,k2,&quot;, 权重 = &quot;,w2),
            line = list(color = &quot;seagreen&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvm3, name = Past0(&quot;分布 3: m = &quot;,m3,&quot;, k = &quot;,k3,&quot;, 权重 = &quot;,w3),
            line = list(color = &quot;indianred&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvmJoint, name = Paste0(&quot;关节: m = &quot;,round(joint$mu,2),&quot;, k = &quot;,round(joint$kappa,3)),
            行=列表（颜色=“黑色”，宽度=2））|&gt;
  布局（xaxis =列表（范围= c（0,360），dtick = 45），
         图例 = 列表(x = 0.5, y = 1.05, xanchor = “中心”, yanchor = “底部”))
]]></description>
      <guid>https://stats.stackexchange.com/questions/635197/analytically-estimate-joint-von-mises-distribution-parameters-from-multiple-unde</guid>
      <pubDate>Mon, 18 Dec 2023 15:40:10 GMT</pubDate>
    </item>
    <item>
      <title>如何改进神经网络的信号分类</title>
      <link>https://stats.stackexchange.com/questions/635196/how-to-improve-a-nn-for-signal-classification</link>
      <description><![CDATA[我正在使用具有两个 Bi-LSTM 层的 RNN 来对信号进行分类。信号的值是复数，因此我向网络提供的是幅度、相位和展开相位。信号的这些参数如下所示：



请注意，这些图仅适用于 1 个信号。每个信号有 3 个图或参数。
我当前的网络有两个双 LSTM 层，分别有 128 个和 256 个隐藏单元，如下所示：

我有 10 个类，分类准确率约为 15%。如何改进 RNN 以使分类效果更好？]]></description>
      <guid>https://stats.stackexchange.com/questions/635196/how-to-improve-a-nn-for-signal-classification</guid>
      <pubDate>Mon, 18 Dec 2023 15:26:40 GMT</pubDate>
    </item>
    <item>
      <title>您是否应该模拟混杂因素对其他混杂因素的影响来测试估计器？</title>
      <link>https://stats.stackexchange.com/questions/635194/should-you-simulate-the-effect-of-confounders-on-other-confounders-to-test-an-es</link>
      <description><![CDATA[想象一下，我正在尝试模拟数据生成过程，其中我对 $Y$ 做出以下假设：
$Y$ = $X$(0.15) + $Z_1$(0.23) + $Z_2$(0.08) + $Z_3$(0.19) + $Z_4$(0.05) + 错误
此外，考虑到我对几个估计器感兴趣，并且我正在尝试找出哪个估计器恢复了 0.15 的定义治疗效果最好。然而，$X$ 被几个变量混淆，所以我相应地调整它们。
我很清楚的是，对于我认为是混杂因素的变量，我需要模拟每个混杂因素对治疗和结果的影响大小。例如，如果 $Z_1$ 对 $Y$ 的影响为 0.23，我还需要在 $X$ 上模拟 0.04 的效果，否则，它不会是一个混杂因素。
然而，在更复杂的数据生成过程中，混杂因素可能会影响其他混杂因素本身的价值。也就是说，将每个混杂因素定义为与其他感兴趣的混杂因素完全外生的分布可能是不合适的。
例如，不要说 $Z_1$ 只是一个平均值为 $\mu 的正态分布变量$ 和标准差 $\sigma$，我也可以说 $Z_2$ 对 $Z_1$ 的影响为 0.33，$Z_3$ 对 $Z_3$ 的影响为 0.07 span class=&quot;math-container&quot;&gt;$Z_1$。
为了实现这个假设模拟的目标（测试不同的估计器，看看哪个估计器能最好地恢复治疗效果），是否有必要定义每个混杂因素对另一个混杂因素的影响？或者，只要我指定每个混杂因素对结果和治疗的影响，模拟分析就可以进行了吗？
一方面，我看到了全面详细说明系统中所有变量的假设数据生成过程的好处。然而，另一方面，我发现我将进一步的假设嵌入到对不感兴趣的效应大小的分析中存在问题（即我没有实际兴趣了解/思考如何 $ Z_3$ 可能会影响 $Z_1$、$Z_2$、$Z_4$ 等）。]]></description>
      <guid>https://stats.stackexchange.com/questions/635194/should-you-simulate-the-effect-of-confounders-on-other-confounders-to-test-an-es</guid>
      <pubDate>Mon, 18 Dec 2023 15:08:33 GMT</pubDate>
    </item>
    <item>
      <title>通过大小为 X 的输入的唯一映射确定算法伪随机性的最佳输出长度</title>
      <link>https://stats.stackexchange.com/questions/635191/determining-optimal-output-length-for-algorithmic-pseudo-randomness-with-unique</link>
      <description><![CDATA[我正在构建一个算法，它应该将每个输入映射到不同的输出，并且输出位应该是统计随机的（也就是说，当放入随机性测试套件（如 NIST）时，它应该给出相当好的分数）。我的问题是，对于输入大小为 X 的情况，输出应该持续多长时间才能满足上述条件？有这个公式吗？如果没有，我该如何研究这个主题？谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/635191/determining-optimal-output-length-for-algorithmic-pseudo-randomness-with-unique</guid>
      <pubDate>Mon, 18 Dec 2023 14:12:11 GMT</pubDate>
    </item>
    <item>
      <title>当 X1 X2 和 Y 具有单位根时的 OLS：I(1)，但不协整</title>
      <link>https://stats.stackexchange.com/questions/635186/ols-when-x1-x2-and-y-have-unit-roots-i1-but-not-cointegrated</link>
      <description><![CDATA[我有三个对数转换的时间序列变量，它们是：I(1) 并且不协整。我在讲座幻灯片中读到，我可以通过添加 LDV 来重新思考我的模型。这解决了我的自相关问题（我添加了 LDV 来解决自相关问题），但外部回归量的效果显着下降。我正在尝试这些组合，看看它们有何不同：
Y(t) = X_1(t) + 错误
Y(t) = X_1 (t) + X_1 (t-1) + Y (t-1) + 误差
Y(t) = X_1 (t-4) + X_2 (t) + 误差
Y(t) = X_1 (t-4) + X_2 (t)+ Y (t-1) + 误差（我进行了顺序测试以确定变量 X_1 的滞后顺序为 4）


对于方程 (2)，我发现系数的符号发生了变化，而对于方程 (4)，与方程 3 相比，两个变量的系数均显着下降。
我经历了这个问题，部分回答了我的问题是在我的模型中使用 LDV，但我想了解为什么方程 2 的符号会发生变化。
我对统计学有一定的了解，所以如果这个问题没有意义，请告诉我。
modelx1 = dynlm(y~x1)
            估计标准。误差t值Pr(&gt;|t|)
（截距）1.8868 0.0306 61.6351 0
x1 -0.3724 0.0091 -41.0770 0
    


modelx1.ar1 = dynlm(y~ L(y, 1)+ L(x1, 0:1))


             估计标准。误差t值Pr(&gt;|t|)
（截距） 0.17596 0.15926 1.10489 0.27581
L(y, 1) 0.91166 0.09068 10.05375 0.00000
L(x1, 0:1)0 -0.41712 0.14231 -2.93118 0.00556
L(x1，0:1)1 0.38155 0.16092 2.37113 0.02264


modelx1.ar1 残差的 ACF 图
]]></description>
      <guid>https://stats.stackexchange.com/questions/635186/ols-when-x1-x2-and-y-have-unit-roots-i1-but-not-cointegrated</guid>
      <pubDate>Mon, 18 Dec 2023 12:48:39 GMT</pubDate>
    </item>
    <item>
      <title>使用 Bash 将文件中的子字符串替换为 MacOS [关闭]</title>
      <link>https://stats.stackexchange.com/questions/635167/replace-sub-string-in-file-with-macos-using-bash</link>
      <description><![CDATA[当我尝试用 sed 替换文件中存在的文本时
sed -i &#39;&#39; “s/21/20/g”十六进制.txt

它没有取代它，有谁知道如何解决这个问题！
顺便说一句，该字符串存在于文件中！]]></description>
      <guid>https://stats.stackexchange.com/questions/635167/replace-sub-string-in-file-with-macos-using-bash</guid>
      <pubDate>Mon, 18 Dec 2023 07:57:50 GMT</pubDate>
    </item>
    <item>
      <title>对于具有分类变量的模型，每个子模型的 OLS 残差总和为零？</title>
      <link>https://stats.stackexchange.com/questions/635145/ols-residuals-sum-to-zero-for-each-submodel-for-a-model-with-categorical-variabl</link>
      <description><![CDATA[据我了解，在 OLS 回归中，整个模型的残差之和必须为零。但是，这个属性是否也保证由分类变量定义的每个子组内的残差之和为零？
如果我有一个分类变量 $X_2 \in \{0, 1\}$ 和一些连续变量 $ X_1$ 这样我的完整模型是：
$Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2$
我的两个子模型是：
$Y = \beta_0 + \beta_1 X_1$
$Y = (\beta_0 + \beta_2) + \beta_1 X_1$
每个子模型的残差之和总是为零吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635145/ols-residuals-sum-to-zero-for-each-submodel-for-a-model-with-categorical-variabl</guid>
      <pubDate>Sun, 17 Dec 2023 22:42:44 GMT</pubDate>
    </item>
    <item>
      <title>比较两个样本的第 90 个百分位数（置信区间、检验）</title>
      <link>https://stats.stackexchange.com/questions/635097/compare-90th-percentiles-of-two-samples-confidence-interval-test</link>
      <description><![CDATA[我有一个质量改进更改前后的救护车响应时间数据集。我想看看更改前后的响应时间是否有差异。具体来说，我试图报告两组（之前和之后）中的第 90 个百分位数值、两个第 90 个百分位数之间的差异、$95$% 置信区间（ CI) 围绕这个差异，以及一个 $p$ 值。
在 R 中，数据集可能如下所示：
set.seed(123)
数据 &lt;- data.frame(
  组=样本（c（“之前”，“之后”），100，替换= TRUE），
  响应时间 = rnorm(100, 平均值 = c(10, 15), sd = 2)
）

我可以使用 t.test 函数轻松测试均值差异：
t.test(data$ResponseTime[data$Group == “之前”],
       数据$ResponseTime[数据$Group ==“之后”])

我还可以像这样计算第 90 个百分位数：
之前 &lt;- 分位数(a$ResponseTime[a$Group==“之前”], probs = 0.9, na.rm = T)
&lt;- 分位数（a$ResponseTime[a$Group==“之后”]，probs = 0.9，na.rm = T）

但我不知道如何比较两者。
我的问题：

这有意义吗？
如果确实有意义，我会使用什么测试来比较第 90 个百分位数？
]]></description>
      <guid>https://stats.stackexchange.com/questions/635097/compare-90th-percentiles-of-two-samples-confidence-interval-test</guid>
      <pubDate>Sun, 17 Dec 2023 02:55:47 GMT</pubDate>
    </item>
    </channel>
</rss>