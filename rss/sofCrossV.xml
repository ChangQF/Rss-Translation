<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Thu, 06 Jun 2024 06:20:42 GMT</lastBuildDate>
    <item>
      <title>在 R 中模拟拟泊松 GLM 的预测区间的难度</title>
      <link>https://stats.stackexchange.com/questions/648734/difficulty-simulating-prediction-interval-for-quasipoisson-glm-in-r</link>
      <description><![CDATA[我拟合了一个拟泊松模型（据我所知，过度分散相当严重），总结如下：

我现在想获得拟合值和 95% 预测区间。经过一番搜索，我在 ciTools 包中找到了 add_pi。但是，当我在模型上运行 add_pi 时，它会产生正确的预测/拟合值，但 PI 为 (0,0)：

当我以相同方式运行 add_ci 时情况并非如此 - 也就是说，add_ci 运行完美。不过，我的理解是 CI 可能是使用模型的 SE 生成的，而 PI 是模拟的。无论如何，我不知道为什么模拟不起作用。有什么想法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/648734/difficulty-simulating-prediction-interval-for-quasipoisson-glm-in-r</guid>
      <pubDate>Thu, 06 Jun 2024 06:12:28 GMT</pubDate>
    </item>
    <item>
      <title>用于二元逻辑回归的 VIF/GVIF</title>
      <link>https://stats.stackexchange.com/questions/648732/vif-gvif-for-binary-logistic-regression</link>
      <description><![CDATA[如何判断我的逻辑回归中是否存在多重共线性？具体来说，GVIF 或 GVIF^(1/2*Df)。 GVIF 的最大值是多少表示存在多重共线性？
Reglog_JKK &lt;- glm(JKK ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9, 
family = binomial)
vif(Reglog_JKK)

结果如下：
 GVIF Df GVIF^(1/(2*Df))
X1 3.411006 1 1.846891
X2 4.899361 1 2.213450
X3 31.723130 5 1.412985
X4 19.833157 3 1.645250
X5 4.305749 1 2.075030
X6 12.188838 3 1.517028
X7 5.436424 2 1.526962
X8 2.525105 1 1.589058
X9 3.045529 1 1.745144
]]></description>
      <guid>https://stats.stackexchange.com/questions/648732/vif-gvif-for-binary-logistic-regression</guid>
      <pubDate>Thu, 06 Jun 2024 03:46:10 GMT</pubDate>
    </item>
    <item>
      <title>逻辑回归[关闭]</title>
      <link>https://stats.stackexchange.com/questions/648730/logistic-regresion</link>
      <description><![CDATA[
&gt; Reglog_JKK &lt;- glm(JKK ~ X1+X2+X3+X4+X5+X6+X7+X8+X9, 
+ family = binomial)
&gt; vif(Reglog_JKK)
GVIF Df GVIF^(1/(2*Df))
X1 3.411006 1 1.846891
X2 4.899361 1 2.213450
X3 31.723130 5 1.412985
X4 19.833157 3 1.645250
X5 4.305749 1 2.075030
X6 12.188838 3 1.517028
X7 5.436424 2 1.526962
X8 2.525105 1 1.589058
X9 3.045529 1 1.745144
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/648730/logistic-regresion</guid>
      <pubDate>Thu, 06 Jun 2024 02:55:23 GMT</pubDate>
    </item>
    <item>
      <title>KNNImputer 如何存储训练集的拟合值？</title>
      <link>https://stats.stackexchange.com/questions/648728/how-does-knnimputer-stores-fitted-values-of-the-train-set</link>
      <description><![CDATA[如果这里有人熟悉 Scikit-learn 的 KNNImputer 实现，我会很想向他学习。
当你在训练数据上安装 Imputer 变换器时，它会保留训练集的参数以便相应地转换测试集（例如 SimpleImputer(method=&#39;mean&#39;) 将存储训练集所有特征向量的平均值并用它们来插补测试集）。
但我无法理解 KNNImputer 除了存储所有训练样本外如何做到这一点。
谢谢你的回答。]]></description>
      <guid>https://stats.stackexchange.com/questions/648728/how-does-knnimputer-stores-fitted-values-of-the-train-set</guid>
      <pubDate>Thu, 06 Jun 2024 01:47:56 GMT</pubDate>
    </item>
    <item>
      <title>贝叶斯分类器的收敛</title>
      <link>https://stats.stackexchange.com/questions/648727/convergence-of-a-bayesian-classifier</link>
      <description><![CDATA[背景
令 $y_k$ 为时间 $k$ 的噪声测量值，令 $\{p_{k-1}(i)\}_{i=1}^n$ 为（离散的）先验概率分布。使用贝叶斯规则，可以根据以下公式更新 $y_k$ 函数中的先验
\begin{equation}
p_k(i)\triangleq \frac{\mathcal{L}(y_k|i)\,p_{k-1}(i)}{\sum_{j=1}^n \mathcal{L}(y_k|j)\,p_{k-1}(j)} \qquad i=1,\dots,n
\end{equation&gt;
其中 $\mathcal{L}(y_k|i)$ 是某个似然函数。然后，我们可以在时间 $k+1$ 重复该过程，在 $y_{k+1}$ 函数中获得 $\{p_{k+1}(i)\}_{i=1}^n$，对于 $k+2,k+3,\dots$ 也是如此
我想了解当 $k\to\infty$ 时会发生什么。我的直觉是，如果可能性对于每个 $k$ 都是恒定的，即
\begin{equation*}
\tag{1}
\mathcal{L}(y_k|i)=C_k \qquad \forall i=1,\dots,n
\end{equation*&gt;
那么根本不会执行任何更新，也就是说，我们每次都会保留初始分布。更准确地说，对于每个 $j\in\mathbb{N}$
\begin{equation*}
p_{k+j}(i) =p_k(i) \qquad \forall i=1,\dots,n
\end{equation*&gt;
另一方面，我从数值实验中看到，概率分布趋向于收敛到唯一集中在单个类 $i^*$ 中的狄拉克分布，即
\begin{equation*}
\lim_{k\to\infty} p_k(i)= \delta_{i^*}(i)
\end{equation*&gt;
就我所见，这种收敛始终是正确的。这可能是真的，因为由于噪音，$(1)$永远不会发生。
问题

排除奇异情况$(1)$，后验总是收敛到狄拉克分布，这是真的吗？

排除奇异情况$(1)$，后验可以收敛到不同于起始分布或狄拉克分布的某个概率分布吗？

]]></description>
      <guid>https://stats.stackexchange.com/questions/648727/convergence-of-a-bayesian-classifier</guid>
      <pubDate>Thu, 06 Jun 2024 01:38:16 GMT</pubDate>
    </item>
    <item>
      <title>在 R 中计算 CECDF（互补经验累积分布函数）</title>
      <link>https://stats.stackexchange.com/questions/648726/computing-the-cecdf-complementary-empirical-cumulative-distribution-function-i</link>
      <description><![CDATA[可以使用 R 中的函数 ecdf() 计算 ECDF。
我有以下表达式，我想根据 CECDF 来定义，但由于某些奇怪的原因，事情并不匹配。
表达式为
\begin{align}
p &amp;= \frac{\#\{d \geq a\}}{\#\{d\}} \\[1mm]
\end{align&gt;
应该等于 $1 - F_d(a)$，其中 $F$ 表示 CDF。
在 R 中，$p$ 只是
p &lt;- mean(d &gt;= a)。

使用 ecdf()，这是
ecdf_d &lt;- ecdf(a)
p_cecdf &lt;- 1 - ecdf_d

这里有一个完整的 MRE 来说明这个问题：
set.seed(123)

d &lt;- rnorm(100)
f &lt;- rnorm(50)
a &lt;- min(f)
b &lt;- min(a)
d_ecdf &lt;- ecdf(d)
f_ecdf &lt;- ecdf(f)
(p_cecdf &lt;- 1 - d_ecdf(b))
# [1] 0.99
(q_cecdf &lt;- 1 - f_ecdf(a))
# [1] 0.98
res_d &lt;- mean(d &gt;= b)
# [1] 0.99
res_f &lt;- mean(f &gt;= a)
# [1] 1

除非我忘记了什么，否则不应该是 $p_\mathrm{cecdf} = res\_d$ 和 $q_\mathrm{cecdf} = res\_f$]]></description>
      <guid>https://stats.stackexchange.com/questions/648726/computing-the-cecdf-complementary-empirical-cumulative-distribution-function-i</guid>
      <pubDate>Thu, 06 Jun 2024 01:33:54 GMT</pubDate>
    </item>
    <item>
      <title>自回归交叉滞后模型</title>
      <link>https://stats.stackexchange.com/questions/648716/autoregressive-cross-lagged-models</link>
      <description><![CDATA[我正在研究一个自回归交叉滞后模型，该模型有两个测量值和三个时间点。从 $t_1$ 到 $t_2$ 的路径是显著的，但从 $t_2$ 到 $t_3$ 的路径都不显著。我对编码/模型/等非常不熟悉，我想知道最好的前进路径是什么？我读过关于限制某些变量的文章，但我真的不明白如何最好地描述/解释这些不显著的路径。我知道这可能会令人困惑，所以感谢您的耐心。]]></description>
      <guid>https://stats.stackexchange.com/questions/648716/autoregressive-cross-lagged-models</guid>
      <pubDate>Wed, 05 Jun 2024 21:24:33 GMT</pubDate>
    </item>
    <item>
      <title>离散时间生存中的审查类型</title>
      <link>https://stats.stackexchange.com/questions/648701/type-of-censoring-in-discrete-time-survival</link>
      <description><![CDATA[*我有一个前瞻性纵向研究。在这项研究中，患者每三个月来医院检查一次。T0（手术前一周）、T3（手术后三个月）、T6（手术后六个月）、T9、T12、、、、、、T24（手术后 24 个月）。所以有 9 个时间点。
我们对包含二元时间相关协变量和连续自变量的预测性 Cox 回归感兴趣。在事件发生前退出、完成无事件随访（T24）或在研究结束时显示特定水平的时间相关协变量的病例为审查员。
似乎在计数过程方法中，只有右审查员。而要使用离散时间生存，必须满足以下条件（如果我说得不对，请纠正我）

所有患者的时间间隔相同
时间点数量有限
区间审查

我不确定我的研究中的审查类型。如果研究中同时存在右审查和区间审查，我们可以使用离散时间生存方法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/648701/type-of-censoring-in-discrete-time-survival</guid>
      <pubDate>Wed, 05 Jun 2024 19:03:51 GMT</pubDate>
    </item>
    <item>
      <title>如何通过统计方法检验特定地点的物种群落是否越来越像另一类型的地点</title>
      <link>https://stats.stackexchange.com/questions/648689/how-to-statistically-test-if-a-community-of-species-at-a-particular-site-is-beco</link>
      <description><![CDATA[我有以下数据框（我在这里使用 R）。
set.seed(2)
Site &lt;- rep(LETTERS[1:13], length.out = 39)
Year &lt;- rep(2019:2022, each = 13, length.out = 39)
Site_Category &lt;- rep(c(paste(&quot;Type&quot;, rep(1:4, each = 3), sep = &quot;_&quot;), 
&quot;Test_Site&quot;), length.out = 39)
Species_1 &lt;- sample(1:100, 39, replace = TRUE)
Species_2 &lt;- sample(1:25, 39, replace = TRUE)
Species_3 &lt;- sample(1:50, 39, replace = TRUE)
Species_4 &lt;- sample(1:500, 39, replace = TRUE)
Species_5 &lt;- sample(1:100, 39, replace = TRUE)
My_Data &lt;- data.frame(Site = Site, Year = Year, Site_Category = 
Site_Category, Species_1 = Species_1, Species_2 = Species_2, 
Species_3 = Species_3, Species_4 = Species_4, 
Species_5 = Species_5)

本质上，我有四个独立的社区数据矩阵（研究的每个年份一个）。您还会注意到，我有一个附加列 Site_Category，它将某些站点分组在一起，并且还指定其中一个站点是独一无二的，因为它是我们感兴趣的站点。
我们的研究问题是判断这个感兴趣的站点是否随着时间的推移变得更像其他站点类型之一。
我熟悉多元分析，例如 Mantel 检验、多响应置换程序和置换方差分析，但我不仅仅是想看看是否存在差异 - 我想结合某种趋势分析来判断随着时间的推移，是否有朝着其他站点类型之一的特定方向的变化。
我可以在这里使用某种统计分析吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/648689/how-to-statistically-test-if-a-community-of-species-at-a-particular-site-is-beco</guid>
      <pubDate>Wed, 05 Jun 2024 14:28:26 GMT</pubDate>
    </item>
    <item>
      <title>简单线性回归的$t$值在线更新</title>
      <link>https://stats.stackexchange.com/questions/648669/online-updating-of-t-value-for-simple-linear-regression</link>
      <description><![CDATA[假设我使用一个简单的普通最小二乘回归模型$y = \beta_1 x + \beta_0$将一个因变量$y$回归到一个独立变量$x$。假设我从 $n$ 个数据点 $(x_1,y_1), \ldots (x_n, y_n)$ 开始，然后拟合回归以获得
$$
\hat{\beta_1} = \frac{s_{xy}}{s^2_x}
$$
and
$$
\hat{\beta_0} = \bar{y} - \hat{\beta_1} \bar{x}
$$
现在假设我有一系列新传入数据 $(x_{n+1},y_{n+1}),\ldots$。
我 知道如何计算新数据集的项$\bar{x}, \bar{y},s^2_x,s^2_y,s_{xy}$，并使用新到达的点进行扩充，从而实现高效计算 - 也就是说，我可以利用我从前$n$个数据点对它们的了解，在恒定的时间内更新所有这些数量。因此，我也知道如何有效地更新数量 $\hat{\beta_1},\hat{\beta_0},r^2$。
我想知道是否有任何巧妙的技巧可以让我有效地更新我的 $t$ 分数，即
$$
t = \frac{\hat{\beta_1}}{\frac{s}{\sqrt{\sum{(x_i-\bar{x})^2}}}}
$$
其中 $s$ 是我们在模型中假设的误差中底层常数标准差 $\sigma$ 的无偏估计量，由
$$
s = \frac{1}{n-2} \sum{(y_i - \hat{y_i})^2}
$$
在我看来，主要问题是，当我们添加新数据点时，所有 $\hat{y_i}$ 值都会发生变化，因此，在重新计算 $s$ 时，它们都是必需的。有没有办法解决这个问题？我可以在恒定时间内更新 $t$ 得分（或等效地 $s$）吗？
假设答案是否定的，我认为对 $t$ 得分可以改变多少进行一些控制会很有用。我可以推导出这一点，但我也希望得到任何文献指点。]]></description>
      <guid>https://stats.stackexchange.com/questions/648669/online-updating-of-t-value-for-simple-linear-regression</guid>
      <pubDate>Wed, 05 Jun 2024 10:13:51 GMT</pubDate>
    </item>
    <item>
      <title>如何检验 B 样条曲线中的变点是否具有统计显著性？</title>
      <link>https://stats.stackexchange.com/questions/648686/how-to-test-if-change-point-in-b-spline-is-statistically-significant</link>
      <description><![CDATA[我想测试一下结点两侧斜率之间的差异是否具有统计显著性。忽略此示例中的模型假设违规，如何查看下图中 x 和 y 之间的关系/斜率是否发生了显著变化？我之前从未使用过带有 b-spline 命令的线性回归，p 值是否表示这两条线之间的差异？我使用的是数据“mtcars”作为我自己数据的替代品。
示例：

library(ggplot2)
library(splines)

data(mtcars)

wt=3 处是否有显著变化点？
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() + 
geom_vline(xintercept=3, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + 
geom_smooth(method=&quot;lm&quot;,
formula= y ~ splines::bs(x, knots = c(3), degree = 1), se=F)


# 构建模型：
mod &lt;- lm(mpg ~ bs(wt, knots = c(3), degree = 1), data = mtcars)

summary(mod)

调用：
lm(formula = mpg ~ bs(wt, knots = c(3), degree = 1), data = mtcars)

残差：
最小值 1Q 中位数 3Q 最大值 
-3.2027 -1.9072 -0.7627 0.9611 6.1070 

系数：
估计标准差误差 t 值 Pr(&gt;|t|) 
(截距) 32.246 1.383 23.313 &lt; 2e-16 ***
bs(wt, knots = c(3), degree = 1)1 -12.884 1.764 -7.306 4.78e-08 ***
bs(wt, knots = c(3), degree = 1)2 -21.133 1.932 -10.937 8.32e-12 ***
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：29 个自由度上的 2.689

多重 R 平方：0.8137，调整后的 R 平方：0.8009

F 统计量：2 和 29 DF 上的 63.34，p 值：2.614e-11

可能的相关问题：
在结点之间分离 B 样条线并比较每个部分的拟合优度]]></description>
      <guid>https://stats.stackexchange.com/questions/648686/how-to-test-if-change-point-in-b-spline-is-statistically-significant</guid>
      <pubDate>Wed, 05 Jun 2024 02:18:10 GMT</pubDate>
    </item>
    <item>
      <title>使用多项式判别法确定 Rademacher 复杂度的界限</title>
      <link>https://stats.stackexchange.com/questions/648587/bound-on-rademacher-complexity-using-polynomial-discrimination</link>
      <description><![CDATA[这是 Wainwright 的高维统计教科书中的引理 4.14，它指出给定一类函数$\mathcal{F}$具有$v$阶多项式判别式，则对于所有整数$n$和$x_1^n = (x_1, \dots, x_n)$，我们有界限
$$
E_{\epsilon} \left[ \sup_{f \in \mathcal{F}} \left| \frac{1}{n} \sum_{i=1}^n \epsilon_i f(x_i) \right| \right] \leq 4D(x_1^n) \sqrt{\frac{v \log (n + 1)}{n}},
$$
其中 $D(x_1^n)$ 是集合 $\mathcal{F}(x_1^n)/n$ 的 $l_2$-半径。
证明留作练习，但对于我来说，如何解决这个问题并不是那么明显。我很感激任何帮助。
我在网上找到了 2 个尝试的解决方案。
第一个解决方案：

我不明白为什么第二个不等式有效。
第二个解决方案的链接：
https://high-Dimensional-statistics.github.io/2021/03/02/exercise-4.9.html
这里的 SG 是什么？另外，他解决方案中使用的亚高斯变量的预期最大值是否有参考？]]></description>
      <guid>https://stats.stackexchange.com/questions/648587/bound-on-rademacher-complexity-using-polynomial-discrimination</guid>
      <pubDate>Tue, 04 Jun 2024 04:07:34 GMT</pubDate>
    </item>
    <item>
      <title>使用多个误差项时的方差分析假设检验</title>
      <link>https://stats.stackexchange.com/questions/648559/analysis-of-variance-assumption-testing-when-multiple-error-terms-are-used</link>
      <description><![CDATA[我正在 R 中进行重复测量分析，其中在一个季节内重复采样块。
My_Data &lt;- data.frame(Sampling_Date = rep(1:4, each = 12), 
Block = rep(1:3, length.out = 48), 
Treatment = rep(LETTERS[1:4], each = 3, 
length.out = 48), 
Response = abs(rnorm(48, 10, 1)))
Model &lt;- aov(Response ~ (Treatment * as.factor(Sampling_Date)) + 
Error(as.factor(Block) / (Treatment * as.factor(Sampling_Date))), 
data = My_Data)
summary(Model)

我想看看残差正态性和同质性的假设是否成立方差得到满足。但是，我无法像平常一样在 R 中运行这些假设测试，因为模型输出针对不同的误差项有不同的表。例如，Shapiro-Wilk 测试将残差作为输入，在这种情况下，我有多组不同的残差（每个模型输出表一个）。当我尝试使用 Levene 方差齐性测试时，我遇到了同样的问题。
我应该分别针对每个模型输出表运行这些测试吗？
lapply(Model, function (x) {
shapiro.test(x$residuals)
})

我在这里遇到了样本大小错误，但就我的问题而言，我真的只是想知道运行这些测试最合适的方法是什么。]]></description>
      <guid>https://stats.stackexchange.com/questions/648559/analysis-of-variance-assumption-testing-when-multiple-error-terms-are-used</guid>
      <pubDate>Mon, 03 Jun 2024 17:01:11 GMT</pubDate>
    </item>
    <item>
      <title>采样以最大化 f(x)p(x)</title>
      <link>https://stats.stackexchange.com/questions/648338/sampling-to-maximise-fxpx</link>
      <description><![CDATA[我有一个概率分布 $p(x)$，我可以非常轻松地从中生成样本。我还有一些函数 $f(x)$，我可以为每个样本计算。我的目标是估算最大化 $f(x)p(x)$ 的 $x$ 的值。我没有简单的方法来计算$p(x)$本身，并且我想避免使用任何 KDE 或任何东西从我的样本中确定$p(x)$。
我的一个想法是从$p(x)$中为大量样本计算一堆$f(x)$，然后根据$f(x)$的值拒绝一些样本。但是 $f(x)$ 没有下限，所以我不确定这是否是正确的选择。
澄清
我想我会保留我原来的想法，这样评论才有意义。

我实际上正在尝试优化 $f(x)p(x)+(1-p(x))f(0)$。
$x$ 是我在控制参数上设定的目标。
$f(x)$ 始终为负数且不具有解析性。它表示如果我的目标参数$x$实际实现，我获得的分数。
$p(x)$表示实现目标控制参数的机会。如果没有实现，我们将得到$x$，而不是$0$。
]]></description>
      <guid>https://stats.stackexchange.com/questions/648338/sampling-to-maximise-fxpx</guid>
      <pubDate>Fri, 31 May 2024 06:28:36 GMT</pubDate>
    </item>
    <item>
      <title>估计多个样本的方差</title>
      <link>https://stats.stackexchange.com/questions/647468/estimating-variance-from-several-samples</link>
      <description><![CDATA[如果从高斯分布中抽取多个样本，每个样本的大小为 n1、n2、n3……，并且从每个样本中估计基础分布的 SD，那么如何正确组合这些估计值以更好地估计总体 SD？
具体情况是，使用不同级别的仪器进行多组测量，因此不能简单地组合，但仪器的不确定性似乎与测量的幅度不成比例，因此任何级别的 SD 可能都可以组合。我感兴趣的是单个测量的变异性，而不是它们的平均值，而且我想 n 的差异足以用它们来衡量各个组。我不知道如何令人信服地汇总方差估计值。
附言不确定这个想法是否有效，但我在考虑简单地对每个组方差的加权平均值取平方根 - 由样本/组大小的平方根的倒数加权 - 如果这有任何意义的话...]]></description>
      <guid>https://stats.stackexchange.com/questions/647468/estimating-variance-from-several-samples</guid>
      <pubDate>Sat, 18 May 2024 04:46:38 GMT</pubDate>
    </item>
    </channel>
</rss>