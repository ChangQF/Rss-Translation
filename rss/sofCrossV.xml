<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Sun, 13 Oct 2024 21:15:52 GMT</lastBuildDate>
    <item>
      <title>当我们将多个参数合并为一个时，这叫什么？[关闭]</title>
      <link>https://stats.stackexchange.com/questions/655733/what-is-it-called-when-we-collapse-many-parameters-in-one</link>
      <description><![CDATA[当我们将同一事物的许多参数放在一起，得到一个标量值时，我们该如何称呼这种操作？尤其是当它不仅涉及参数的简单总结（甚至可能带有权重）时，还涉及更复杂的“合并”时？
例如，当我们考虑某些项目的可排序参数属性，如大小、亮度、光的波长、距离等，然后我们为这些属性提供偏好，并要求按某些公共值进行排序，这些公共值是这些独立值的一种“总和”。
我想到的是：卷积、合并、组合、降维、“标量化”、投影等。
这有什么通用术语吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655733/what-is-it-called-when-we-collapse-many-parameters-in-one</guid>
      <pubDate>Sun, 13 Oct 2024 21:02:33 GMT</pubDate>
    </item>
    <item>
      <title>似然函数简化的证明[重复]</title>
      <link>https://stats.stackexchange.com/questions/655732/proof-of-the-simplification-of-the-likelihood-function</link>
      <description><![CDATA[许多参考文献都指出，在$x_1,x_2,\ldots x_n$为独立同分布的假设下，似然函数可以简化如下：
$$P(x_1,x_2,\ldots ,x_n|\theta)=P(x_1|\theta)P(x_2|\theta)\ldots P(x_n|\theta)$$
不幸的是，大多数参考文献都认为这种简化是理所当然的，而没有提供任何证明或解释。
上述简化背后的证明是什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/655732/proof-of-the-simplification-of-the-likelihood-function</guid>
      <pubDate>Sun, 13 Oct 2024 20:33:21 GMT</pubDate>
    </item>
    <item>
      <title>R 与 Python 在学术生物统计学研究中的比较？[关闭]</title>
      <link>https://stats.stackexchange.com/questions/655731/r-vs-python-in-academic-biostatistics-research</link>
      <description><![CDATA[我很好奇，想听听你对在学术生物统计学或密切相关领域（例如统计学、生物信息学、数据科学）学习 R 与 Python 的重要性的看法。
背景：

我使用 R 已经超过 10 年了，从未遇到过无法用它解决的问题。我对 R 非常熟练，并且很熟悉。
但是，我想知道学习 Python 对于学术界的职业发展，尤其是在生物统计学领域，有多重要。

问题：

对于像我这样拥有丰富 R 经验的人来说，你认为学习 Python 对于生物统计学或类似领域的学术生涯有多重要？
你是否认为 Python（甚至是 Julia）未来可能会在学术界取代 R？我是否应该担心 R 会随着时间的推移变得不那么重要？

就我个人而言，我更愿意坚持使用 R，因为它目前满足了我所有的需求。但如果这对于保持该领域的竞争力至关重要，我愿意学习新工具。我也很想知道你对精通多种统计编程语言（如 Python 或 Julia）是否具有显著优势的看法。]]></description>
      <guid>https://stats.stackexchange.com/questions/655731/r-vs-python-in-academic-biostatistics-research</guid>
      <pubDate>Sun, 13 Oct 2024 20:04:51 GMT</pubDate>
    </item>
    <item>
      <title>当连续变量等于 0 时创建虚拟变量</title>
      <link>https://stats.stackexchange.com/questions/655727/creating-a-dummy-variable-when-the-continuous-variable-is-equal-to-0</link>
      <description><![CDATA[由于我有很多真零（所以它们不是缺失值而是真正的零），我创建了一个虚拟变量，使得：
当正连续变量等于 0 时，虚拟变量等于 1，否则为 0。
因此我执行了以下 logit 回归：
proc logistic data= want plots=ROC;
model perceived_default = Continuous_variable dummy_variable
run;
结果在 Somers&#39;D（60%）方面相当不错，但虚拟变量并不显著（p 值等于 0.35）。
我该如何处理这个问题？即使虚拟变量不显著，我是否可以将其保留在模型中？我认为问题出现是因为虚拟变量在构造上与连续变量共线。
有什么建议吗？干杯 :)]]></description>
      <guid>https://stats.stackexchange.com/questions/655727/creating-a-dummy-variable-when-the-continuous-variable-is-equal-to-0</guid>
      <pubDate>Sun, 13 Oct 2024 16:59:47 GMT</pubDate>
    </item>
    <item>
      <title>为什么自动编码器的潜在空间中不希望有空洞？</title>
      <link>https://stats.stackexchange.com/questions/655726/why-holes-are-not-desirable-in-latent-space-of-autoencoders</link>
      <description><![CDATA[在多项关于自动编码器的研究中，已经指出，普通自动编码器（没有任何正则化的自动编码器）可能会受到潜在空间中空洞的影响。空洞的含义被描述为自动编码器潜在空间中的不连续区域。我无法理解两件事
I) 不连续区域。我认为这意味着将数据映射到潜在空间后获得的流形不连续。
II) 为什么它们不可取？]]></description>
      <guid>https://stats.stackexchange.com/questions/655726/why-holes-are-not-desirable-in-latent-space-of-autoencoders</guid>
      <pubDate>Sun, 13 Oct 2024 15:15:51 GMT</pubDate>
    </item>
    <item>
      <title>使用边际效应包 - avg_slopes() 或 slopes() 加权后从 brms 模型中提取连续效应？</title>
      <link>https://stats.stackexchange.com/questions/655722/extracting-continuous-effects-from-a-brms-model-after-weighting-using-the-margin</link>
      <description><![CDATA[我想估计连续变量 perc_quality_plus_palms 对 Forest.dependency（3 个类别）和 Trophic.Niche（4 个类别；均为物种级属性）的每个组合中不同鸟类数量数量的因果影响。这是一个相当复杂的分层贝叶斯模型，我事先进行了加权：
brm(
bf(CountVisit | weights(weights) ~ t2(perc_quality_plus_palms, Forest.dependency, Trophic.Niche, bs = c(&quot;cr&quot;, &quot;re&quot;, &quot;re&quot;)) + 
(1 + perc_quality_plus_palms | name_latin) +
(1 | square_ID / point_ID) +
(offset(effArea2)),
zi ~ perc_quality_plus_palms + (1|name_latin)
),
data = bird.i,
family = zero_inflated_poisson(),
chains = 4,
cores = 4,
iter = 3000,
warmup = 1000,
previous = my_priors
)

当我在一个简单的 lm 模型中估计 perc_quality_plus_palms 对不同结果的影响时（即我使用了 avg_predictions 和 avg_slopes），我一直在关注这篇博文。但是，我现在不确定如何（使用 marginaleffects 包）评估 perc_quality_plus_palms 是否对每个森林依赖性-生态位组合的 perc_quality_plus_palms 连续体产生影响。
我尝试遵循博文的逻辑并使用 avg_slopes（见下文），但是，通过阅读 marginaleffects 包上的其他信息，我现在不确定这是否合适，以及我是否应该使用 slopes()？
任何对此的见解都将不胜感激！
values &lt;- with(birds.i, seq(quantile(perc_quality_plus_palms, .1),
quantile(perc_quality_plus_palms, .9),
length.out = 100))
avg_slopes(my_brm_wfh_splines_nicedep, newdata = datagridcf(perc_quality_plus_palms = values,Forest.dependency = &quot;Medium&quot;, Trophic.Niche = &quot;Frugivore&quot;, grid_type = &quot;counterfactual&quot;),variables = &quot;perc_quality_plus_palms&quot;, by = &quot;perc_quality_plus_palms&quot;, ndraws = 300, re_formula = NA, dpar = &quot;mu&quot;)
]]></description>
      <guid>https://stats.stackexchange.com/questions/655722/extracting-continuous-effects-from-a-brms-model-after-weighting-using-the-margin</guid>
      <pubDate>Sun, 13 Oct 2024 10:30:16 GMT</pubDate>
    </item>
    <item>
      <title>2 个受试者间，2 个受试者内，以及 2 个 DV</title>
      <link>https://stats.stackexchange.com/questions/655715/2-between-subjects-and-2-within-subjects-and-2-dv</link>
      <description><![CDATA[我的数据包含以下特征：

受试者间因素：组别（干预 A 与干预 B）
受试者内因素：时间（前与后）
因变量：焦虑（量表 A）和行为（量表 B）
个人：48

您会推荐哪种数据分析来处理这些数据？]]></description>
      <guid>https://stats.stackexchange.com/questions/655715/2-between-subjects-and-2-within-subjects-and-2-dv</guid>
      <pubDate>Sun, 13 Oct 2024 06:20:25 GMT</pubDate>
    </item>
    <item>
      <title>Nate Silver 的 p(doom) 计算</title>
      <link>https://stats.stackexchange.com/questions/655697/nate-silvers-pdoom-calculation</link>
      <description><![CDATA[在他的最新著作《边缘》中，Nate Silver 概述了一种“贝叶斯”计算方法，用于计算核战争的概率，其前提是自 1946 年以来我们从未目睹过核武器的使用。我发现他的设置和解决方案有点模糊，我想遵循他的逻辑。
他写道：

自 1945 年以来，核武器从未在冲突中使用过，我们应该对此感到多么欣慰？假设在 1946 年 1 月 1 日，你召集了一个由三位专家组成的小组来预测再次发生核爆炸的可能性。Peter Pessimist 告诉你，每年使用核武器的可能性为 10%。Ollie Optimist 说可能性只有 0.1%。而 Mary Middleground 估计可能性为 1%。由于没有真正的证据，你只能将他们的预测平均下来，得出每年 3.7% 的概率。这令人恐惧：这意味着在未来二十年内，核武器被使用的可能性更大。这有助于解释为什么冯·诺依曼等人在二战后认为文明可能不会再存在太久。但在 78 年（1946 年至 2023 年）没有使用核武器之后，我们可以更新我们分配给每个分析师的估计的权重；这是贝叶斯定理的直接应用。例如，我们可以说彼得·佩西米斯特可能是错的。如果真的有 10% 的年核战争概率，那么我们迄今为止仅凭运气就避免核战争的概率不到 1/3,000。然而，我们没有足够的证据来对玛丽·米德尔格兰特的估计做出太多评论。她说每年发生核战争的概率是1/100，而我们只有七十八年的数据来反驳她。 （没错，一个好的贝叶斯主义者会稍微降低她的预测，同时增加我们对 Ollie Optimist 的理论的信任度。）在长崎核爆 78 年后，我们修订后的贝叶斯估计是每年发生核战争的可能性约为 0.35%。&quot;

他附上了一张我一直试图重现的图表：

我对 Nate 的步骤有点困惑，以为我可能想太多了。他似乎在更新他的前因，即三位“专家”的平均值((乐观派 0.1% + 中间派 1.0% + 悲观派 10%)/3 = 3.7%)，通过对随后 78 年内事件结果的观察，对每位专家（称他们为$p_1, p_2, p_3$）进行加权。也就是说，$p$（$n$ 年内未发生的事件 | 事件概率）= $(1-{p_i})^n$
为了复制此结果，我为每个 $n$ 从 0 到 $N$=78 的专家计算了新的权重：
\begin{align}
p&#39;(n) &amp;= \sum_{i=1}^3\frac{p_i(1-p_i)^n}{Z(n)} \\
Z(n) &amp;= \sum_{i=1}^3(1-p_i)^n
\end{align&gt;
然而，这与 Nate 的情节不太相符：

由于我的信封背面没有起作用，我想知道我是不是走运了，Nate 是否对此进行了更复杂的建模？我很想让这个解决方案更正式，并使这些线条相匹配。欢迎任何意见！谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/655697/nate-silvers-pdoom-calculation</guid>
      <pubDate>Sat, 12 Oct 2024 16:57:55 GMT</pubDate>
    </item>
    <item>
      <title>回归均值的行为</title>
      <link>https://stats.stackexchange.com/questions/655691/behaviour-of-regression-toward-the-mean</link>
      <description><![CDATA[我有一个包含 801 人（男性和女性）左右脚长度的数据集。据我所知，这是一个教学数据集，没有任何具体问题或特殊之处。
以下是均值和协方差矩阵，单位为厘米：
## 均值
右脚长度 左脚长度 
24.3 24.3 

## 协方差矩阵
右脚长度 左脚长度
右脚长度 6.34 6.08
左脚长度 6.08 6.31

左脚对右脚的回归表明，与直觉相反，斜率略低于 1，截距高于 0（见下文）。我认为这是由于向均值回归。到目前为止一切顺利，除非您有更好的解释。
令我困惑的是截距非常接近 1（0.99877）。当然，0.99877 是一个与其他数字一样的数字，但我想知道截距几乎正好为 1 是否有原因。您能解释一下吗？

调用：
lm(formula = LengthLeftFoot ~ LengthRightFoot)

残差：
最小 1Q 中位数 3Q 最大 
-2.254 -0.239 -0.025 0.187 8.823 

系数：
估计标准差。误差 t 值 Pr(&gt;|t|) 
(截距) 0.99877 0.23741 4.21 2.9e-05 ***
LengthRightFoot 0.95891 0.00973 98.50 &lt; 2e-16 ***
---
Signif。代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：799 个自由度上的 0.693
多重 R 平方：0.924，调整后的 R 平方：0.924
F 统计量：1 和 799 DF 上的 9.7e+03，p 值：&lt;2e-16


此 R 模拟生成一个包含 50000 个观测值的数据集，其协方差矩阵与真实值相似。回归重现了上述发现：
mu &lt;- c(24.3, 24.3)
covmat &lt;- structure(c(6.33766534019975, 6.07723639200999, 6.07723639200999, 
6.3073693196005), dim = c(2L, 2L), dimnames = list(c(&quot;LengthRightFoot&quot;, 
&quot;LengthLeftFoot&quot;), c(&quot;LengthRightFoot&quot;, &quot;LengthLeftFoot&quot;)))

sim &lt;- as.data.frame(mvrnorm(n=50000, mu=mu, Sigma=covmat))

回归基于模拟数据：
summary(lm(LengthLeftFoot ~ LengthRightFoot, data=sim))
调用：
lm(formula = LengthLeftFoot ~ LengthRightFoot, data = sim)

残差：
最小值 1Q 中位数 3Q 最大值 
-2.9058 -0.4683 -0.0034 0.4622 2.7255 

系数：
估计标准误差 t 值 Pr(&gt;|t|) 
(截距) 1.037961 0.030047 34.55 &lt;2e-16 ***
LengthRightFoot 0.957488 0.001231 777.63 &lt;2e-16 ***
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：49998 个自由度上的 0.6921

多重 R 平方：0.9236，调整后的 R 平方：0.9236

F 统计量：1 和 49998 DF 上的 6.047e+05，p 值：&lt; 2.2e-16
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/655691/behaviour-of-regression-toward-the-mean</guid>
      <pubDate>Sat, 12 Oct 2024 15:21:33 GMT</pubDate>
    </item>
    <item>
      <title>在所有数据集中确定正确的输出，其中我们只知道错误率，并且输出具有不均匀分布，这是实际工程问题</title>
      <link>https://stats.stackexchange.com/questions/655687/determining-the-correct-output-among-all-data-set-where-we-only-know-error-rate</link>
      <description><![CDATA[我遇到了一个工程问题，但我没有高级统计背景。让我试着解释一下我的情况。
假设我有一台机器，它接受输入并在内部进行一些计算后给出输出。
机器的属性：

机器总是接受完全相同的输入（我们不知道输入）。

我们的机器也有 30% 的错误率

输出具有非均匀分布。

当我们运行我们的机器时，它有时会给出错误的输出，正如我所说，这些错误的输出可能非常不同，但只有一个正确的输出。在这里，我们不知道输入，只看到机器的输出，并且有信息表明机器也有 30% 的错误率，并且输出具有非均匀分布。

我们可以随心所欲地运行机器。


我想用最少的试验来确定正确的输出。所以我在研究一种在向最终用户提供正确输出之前要执行的技术。

例如，假设我的机器进行 4+6 的计算，那么它的输出可能是 560,11,26,3,1563567,67,9,10,34 ... 我写这个例子是因为即使它有 30% 的错误率，第一个输出可能直到某个时候才包含正确的输出。更重要的是，这是非常低的概率，但一些不正确的输出可能会重复并欺骗我们相信它是正确的。然而，这是最糟糕的情况。

当我在互联网上进行研究时，我遇到了 Walds 的序贯概率比检验，但我不确定它是否是解决我的问题的正确工具。更重要的是，我无法理解如何应用该技术。您能否与我分享您的知识来解决我的问题？统计学中是否有任何方法可以将其应用于我的问题。如果 SPRT 是正确的，那么请帮助我应用它

我的想法：为了应用 SPRT，我需要一个假设。我认为假设可以是关于特定值是否是正确的输出。
1.步骤-) 运行机器，直到获得两个相同的输出。当您获得 $2$ 相同的输出时，停止机器。说它可能是正确的。
2.Step-) 假设我们正确输出的候选是 $8$。
$H_0:$ $8$ 不是正确的输出
$H_1:$ $8$ 是正确的输出
3.Step-) 我想要确保我的输出尽可能高，所以我想要 $99$ 百分比置信区间。这里 $\alpha=0.01$ 和 $\beta=0.01$
所以，我的边界点可以是 $$A=log \bigg(\frac{1-\beta}{\alpha}\bigg)=1.995 , B=log \bigg(\frac{\beta}{1-\alpha}\bigg)=-1.995$$
4.Step-) $$L(x_i)=\frac{P(x_i|H_1)}{P(x_i|H_0)} \rightarrow L(8)= \frac{0.7}{0.3}=2.333=log(2.333)=0.368$$
5.Step-) $S_n=S_{n-1}+log(L(x_i))$
在这里，我们在再次运行机器后更新每个输出的 $S_n$ 中的值。如果我们看到可能的正确输出 $8$，我们将添加 $0.368$，但如果我看到任何其他输出，我不知道该怎么做。我被困在这里。如果我的和超过 $1.995$，那么我会推断 $8$ 是正确的，置信度为 $99$，但如果低于 $-1.995$，我会拒绝 $H_1$。
我不确定对于“不正确”的输出我应该怎么做。我认为它们必须对和产生负面影响。不确定。
当和介于 $-1.995$ 和 $1.995$ 之间时，我会继续输出]]></description>
      <guid>https://stats.stackexchange.com/questions/655687/determining-the-correct-output-among-all-data-set-where-we-only-know-error-rate</guid>
      <pubDate>Sat, 12 Oct 2024 13:07:12 GMT</pubDate>
    </item>
    <item>
      <title>多元高斯累积分布函数关于 Sigma 矩阵元素的导数</title>
      <link>https://stats.stackexchange.com/questions/655720/derivative-of-multivariate-gaussian-cdf-with-respect-to-elements-of-sigma-matrix</link>
      <description><![CDATA[我一直在尝试计算多元高斯 cdf 相对于 Sigma 矩阵元素的导数。令 F (f) 代表多元高斯 cdf (pdf)，其均值向量为 mu，相关矩阵为 P，其中 i=j 时其条目 p_ij = 1，否则为 rho。我希望计算 dF/d rho（请原谅这种符号）。
对于双变量情况，结果是已知且简单的。我自己已经能够推导出来，但也找到了一篇包含结果的论文，并且通过使用 R 中的实现，我能够检查解决方案的正确性，见下文。结果是
dF_2 (x1,x2;0,P_2)/d rho = f(x_1,x_2;0,P_2)。
x = rep(0.1,2); rho0 = 0.1; P = matrix(rho0,2,2); diag(P) = 1

F_2 &lt;- function(rho_1){
P.1 = matrix(rho_1,2,2); diag(P.1)=1
mvtnorm::pmvnorm(lower = rep(-Inf,2), upper = x, mean = rep(0,2), 
corr = P.1, seed = 1)[1]
}

all.equal(numDeriv::grad(F_2, rho0),
mvtnorm::dmvnorm(x = x, mean = rep(0,2), sigma = P))

[1] TRUE

现在，对于高于 2 的维度，它会变得有点复杂。首先，我尝试自己计算，虽然 d f/d rho 非常简单且微不足道，但我不确定如何处理 d F/d rho。然后我在 Tong 和 Plackett 中找到了另一个结果，其中指出，例如对于 3 维，偏导数可以写成
dF_3 (x1,x2,x_3;0,P_3)/d rho = f_2(x_1,x_2;0,P_2) F_c (x_3; mu_c, S_c), 
其中 f_2 是边际联合分布(x_1,x_2) 的均值为 0，相关矩阵 P_2 的对角线元素为 1，其他地方为 rho，F_c 是给定 (x_1,x_2) 时 x_3 的条件密度，在本例中为单变量高斯 cdf，均值为 rho(x_1 + x_2)/(1+rho)，方差为 - (2 rho^2 - rho - 1)/(rho+1)。至少，如果我正确解读了这篇论文的话。但是，当我尝试实现它时，结果在数值上是错误的。
x = rep(0.1,3); rho0 = 0.1; P = matrix(rho0,3,3); diag(P) = 1
mu_c = (rho0/(1+rho0))*sum(x[1:2])
sigma2_c = - (2*rho0^2 - rho0 -1)/(rho0+1)

F_3 &lt;- function(rho_1){
P.1 = matrix(rho_1,3,3); diag(P.1)=1
mvtnorm::pmvnorm(lower = rep(-Inf,3), upper = x, mean = rep(0,3), 
corr = P.1, seed = 1)[1]
}

numDeriv::grad(F_3, rho0)
[1] 0.2535275

mvtnorm::dmvnorm(x = x[1:2], mean = rep(0,2), 
sigma = P[1:2,1:2])*pnorm(q = x[3], mean = mu_c, 
sd = sqrt(sigma2_c), lower.tail = TRUE)
[1] 0.0844702

所以我的问题是：我是否错误地解释了公式，或者实现是正确的，但 R 中存在数值问题？如果是这样，它与 pmvnorm 的计算方式有什么关系吗？我知道它使用基于重要性抽样技术的 Genz-Brent 算法，该算法会产生略微随机的结果，当未设置种子时，会产生完全随机的数值梯度。这与它有什么关系吗？或者与 grad 函数本身有什么关系？我非常感谢有关此事的任何帮助。
F_3_noseed &lt;- function(rho_1){
P.1 = matrix(rho_1,3,3); diag(P.1)=1
mvtnorm::pmvnorm(lower = rep(-Inf,3), upper = x, mean = rep(0,3), 
corr = P.1)[1]
}

numDeriv::grad(F_3_noseed, rho0)
[1] 16.76862

&gt; numDeriv::grad(F_3_noseed, rho0)
[1] 1.71553

&gt; numDeriv::grad(F_3_noseed, rho0)
[1] -4.708667

我曾尝试通过展开方程式，然后使用矢量微积分，自己计算 d=3 的积分，但我遇到了困难。也就是说，我计算了 d f(x, P)/d rho= tr ( -1/2 P^{-1} - P^{-1} xx&#39; P^{-1} ) A ),，其中 A 是 dP/drho。但我现在不知道如何将其与 x 积分。然后我在一篇论文中找到了现有的结果并尝试实施。]]></description>
      <guid>https://stats.stackexchange.com/questions/655720/derivative-of-multivariate-gaussian-cdf-with-respect-to-elements-of-sigma-matrix</guid>
      <pubDate>Fri, 11 Oct 2024 13:47:04 GMT</pubDate>
    </item>
    <item>
      <title>有效影响功能的干预措施取决于暴露的自然价值</title>
      <link>https://stats.stackexchange.com/questions/655646/efficient-influence-function-with-interventions-that-depend-on-the-natural-value</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/655646/efficient-influence-function-with-interventions-that-depend-on-the-natural-value</guid>
      <pubDate>Fri, 11 Oct 2024 11:34:19 GMT</pubDate>
    </item>
    <item>
      <title>估计概率值大于来自未知分布的 x</title>
      <link>https://stats.stackexchange.com/questions/655642/estimate-probability-value-is-greater-than-x-from-an-unknown-distribution</link>
      <description><![CDATA[假设我们有 N 个项目的总体，其值从 0 到 6000。
假设总体的平均值是 $\mu$。
我们不知道项目的分布。
我们从这个总体中提取一个项目，我们如何估计 $P(x\geq 2500)$？
同样的问题，假设分布是均匀的。]]></description>
      <guid>https://stats.stackexchange.com/questions/655642/estimate-probability-value-is-greater-than-x-from-an-unknown-distribution</guid>
      <pubDate>Fri, 11 Oct 2024 08:52:55 GMT</pubDate>
    </item>
    <item>
      <title>使用高斯过程生成的二进制序列之间的相关性度量</title>
      <link>https://stats.stackexchange.com/questions/655641/measure-of-correlation-between-binary-sequences-that-were-generated-using-a-gaus</link>
      <description><![CDATA[为了进行实验，我需要构建一个 $n$ 个长度为 $T.$ 的二进制序列集合
由 $n=3$ 和 $T=20$ 组成的示例：
$
\begin{bmatrix}
0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1 \\
0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1 \\
1&amp;0&amp;1&amp;0&amp;0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0
\end{bmatrix}
$
上述矩阵中的每一行都是通过从高斯过程采样而创建的，协方差矩阵的形状为 20 x 20，然后使用阈值（基于预定的 1 百分比），我将它们转换为二进制序列。请注意，此阈值可能因每个序列而异。现在，我想找到这三个（或 $n$）序列之间的互相关。我的目的是使用具有类似核函数的高斯过程从 $n$ 个序列中创建 $x$ 个序列以产生相关性。拥有互相关度量将有助于我注意到在每个序列上运行时某种算法的行为。]]></description>
      <guid>https://stats.stackexchange.com/questions/655641/measure-of-correlation-between-binary-sequences-that-were-generated-using-a-gaus</guid>
      <pubDate>Fri, 11 Oct 2024 08:29:40 GMT</pubDate>
    </item>
    <item>
      <title>为什么具有不同标准差的正态分布比其等效正态分布更适合另一个正态分布？</title>
      <link>https://stats.stackexchange.com/questions/655612/why-a-normal-distribution-with-a-different-standard-deviation-better-fits-anothe</link>
      <description><![CDATA[代码很简单：
vector_sd3 &lt;- rnorm(n = 100, mean = 15, sd = 3)
vector_sd3b &lt;- rnorm(n = 100, mean = 15, sd = 3) # 等效向量
vector_sd1 &lt;- rnorm(n = 100, mean = 15, sd = 1) # 均值相同但标准差较低
sum(abs(vector_sd3 - vector_sd3b))

返回的值高于；
sum(abs(vector_sd3 - vector_sd1))

我尝试运行多次，但仍然得到 vector_sd1 的较低 sd，较低sum(abs(vector_sd3 - vector_sd1)) 是
直观地看，我们会认为相反，有人能解释一下吗？

事实上，我没有注意到向量中的值没有排序。
所以，
vector_sd3 &lt;- sort(x = rnorm(n = 100, mean = 15, sd = 3))
vector_sd3b &lt;- sort(x = rnorm(n = 100, mean = 15, sd = 3)) # 等效向量
vector_sd1 &lt;- sort(x = rnorm(n = 100, mean = 15, sd = 1)) # 均值相同但标准差较低
sum(abs(vector_sd3 - vector_sd3b))

然后我们有 sum(abs(vector_sd3 - vector_sd3b)) &lt; sum(abs(vector_sd3 - vector_sd1))
感谢您的回答！]]></description>
      <guid>https://stats.stackexchange.com/questions/655612/why-a-normal-distribution-with-a-different-standard-deviation-better-fits-anothe</guid>
      <pubDate>Thu, 10 Oct 2024 15:56:52 GMT</pubDate>
    </item>
    </channel>
</rss>