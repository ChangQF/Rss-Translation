<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Thu, 11 Apr 2024 09:14:23 GMT</lastBuildDate>
    <item>
      <title>所有分位数统一的分位数回归的渐近结果</title>
      <link>https://stats.stackexchange.com/questions/644780/asymptotic-results-for-quantile-regression-uniformly-over-all-quantiles</link>
      <description><![CDATA[在标准分位数回归 (QR) 框架中，我们通常只考虑一个感兴趣的分位数水平，例如 $\tau$。通过标准渐近结果，我们得到 $\sqrt{n}(\hat{\beta}(\tau) - \beta(\tau))$，其中 $\hat{\beta}(\tau)$ 是 Koenker 和 Bassett (1978) 的标准 QR 估计器。这为我们提供了一种使用渐近方差估计来对大样本进行推理的方法。
但是，在阅读论文时，我有时也会遇到在所有分位数水平上一致的渐近结果 $\tau \in (0, 1)$。这些结果似乎并不是一个分位数水平结果的简单扩展。例如，在 Belloni 等人的《计量经济学杂志》论文中。 （2019）提到
&lt;块引用&gt;
我们注意到对函数$u \to \beta(u)$的推断，特别是对参数$\beta(u)$ 一致地适用于所有 $u ∈ U$，其中 $ U$ 是一组感兴趣的分位数指数，很困难，因为基于极限分布的标准渐近理论（van de Vaart 和 Wellner，1996）在这里没有帮助，因为过程 $u \to \sqrt{n}(\hat{\beta}(u)−\beta(u))$ 一般来说没有限制
即使在适当的标准化之后，分布也是如此。

这只是我见过的多篇论文中的一篇，这些论文在所有分位数指数上都得出了如此统一的结果。我看过 Van der Vaart 和 Wellner (1996)，但我没有确切地找到 $u \to \sqrt{n}(\hat{\beta }(u)−\beta(u))$ 没有限制。有谁知道为什么会出现这种情况？我想建立一些直觉，了解为什么标准技术不起作用以及如何得出一致的结果。任何帮助或参考其他作品来更详细地解释这一点将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/644780/asymptotic-results-for-quantile-regression-uniformly-over-all-quantiles</guid>
      <pubDate>Thu, 11 Apr 2024 08:16:53 GMT</pubDate>
    </item>
    <item>
      <title>再现认知诊断评估的估计分类一致性和准确性</title>
      <link>https://stats.stackexchange.com/questions/644779/reproduce-the-estimating-classification-consistency-and-accuracy-for-cognitive-d</link>
      <description><![CDATA[I really need to。Here is the code I wrote myself without logic
library(MASS)
library(CDM)
set.seed(0)
参数设置
sample_sizes &lt;- c(100, 500, 1000) # 样本大小
num_attributes &lt;- c(3, 5, 8) # 属性数量级别
num_simulations &lt;- 2000 # 每种情况下的模拟次数
num_items &lt;- 20
num_students &lt;- 1000
存储结果
results &lt;- list()
for (k in num_attributes) {
创建独立属性的协方差矩阵
independent_cov &lt;- diag(1, k)
创建中度相关属性的协方差矩阵
moderately_correlated_cov &lt;- matrix(0, nrow = k, ncol = k)
diag(moderately_correlated_cov) &lt;- 1
moderately_correlated_cov[upper.tri(moderately_correlated_cov)] &lt;- runif((k*(k-1))/2, min = 0.3, max = 0.5)
moderately_correlated_cov[lower.tri(moderately_correlated_cov)] &lt;- t(moderately_correlated_cov)[lower.tri(moderately_correlated_cov)]
创建高度相关属性的协方差矩阵
highly_correlated_cov &lt;- matrix(0, nrow = k, ncol = k)
diag(highly_correlated_cov) &lt;- 1
highly_correlated_cov[upper.tri(highly_correlated_cov)] &lt;- runif((k*(k-1))/2, min = 0.5, max = 0.8)
highly_correlated_cov[lower.tri(highly_correlated_cov)] &lt;- t(highly_correlated_cov)[lower.tri(highly_correlated_cov)]
生成独立属性模式
independent_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = independent_cov)
true_attribute_patterns[[paste(k, &quot;independent&quot;, sep = &quot;_&quot;)]] &lt;- independent_attributes
生成中度相关属性模式
moderately_correlated_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = moderately_correlated_cov)
true_attribute_patterns[[paste(k, &quot;moderately_correlated&quot;, sep = &quot;_&quot;)]] &lt;- moderately_correlated_attributes
生成高度相关属性模式
highly_correlated_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = highly_correlated_cov)
true_attribute_patterns[[paste(k, &quot;highly_correlated&quot;, sep = &quot;_&quot;)]] &lt;- highly_correlated_attributes
}
for (n_sample in sample_sizes) {
for (n_attr in num_attributes_levels) {
# 根据属性数量确定Q矩阵中测量属性的概率
prob_attribute_measured &lt;- if (n_attr == 3) {
0.5
} else if (n_attr == 5) {
0.3
} else { # n_attr == 8
0.1825
}
辅助函数，生成模拟响应数据
simulateDataCDM &lt;- function(true_attribute_patterns, Q_matrix, num_items) {
此函数应生成符合DINA模型的学生响应模式
这里只是一个占位符
response_patterns &lt;- matrix(sample(0:1, nrow(true_attribute_patterns) * num_items, replace = TRUE), nrow = nrow(true_attribute_patterns))
return(list(
true_attribute_patterns = true_attribute_patterns,
response_patterns = response_patterns
))
}# 进行模拟
for (sim in 1:num_simulations) {
模拟属性掌握情况
true_attribute_patterns &lt;- matrix(runif(n_sample * n_attr) &lt; prob_attribute_measured, nrow = n_sample)
模拟Q矩阵
Q_matrix &lt;- matrix(runif(num_items * n_attr) &lt; prob_attribute_measured, nrow = num_items, ncol = n_attr)
生成模拟数据集
sim_data &lt;- simulateDataCDM(true_attribute_patterns, Q_matrix)
sim_data &lt;- simulateDataCDM(true_attribute_patterns, Q_matrix, num_items) # 这里传递num_items作为参数
拟合DINA模型
fit &lt;- din(data = sim_data$response_patterns, q.matrix = Q_matrix)
评估分类一致性和准确性
class_accuracy &lt;- cdm.est.class.accuracy(fit, sim_data$response_patterns)
存储结果
results[[paste(n_sample, &#39;sample&#39;, n_attr, &#39;attributes&#39;, sim, &#39;simulation&#39;, sep = &#39;_&#39;)]] &lt;- class_accuracy
}
}
}
对每种属性数量进行模拟
使用二分法将正态分布变量转换为二进制属性模式
假设大于等于0的值表示属性被掌握
for (i in names(true_attribute_patterns)) {
true_attribute_patterns[[i]] &lt;- ifelse(true_attribute_patterns[[i]] &gt;= 0, 1, 0)
}
查看生成的属性模式
true_attribute_patterns
评估所有模拟结果
evaluate_criteria &lt;- function(Pc, Pa) {
results &lt;- list(
Pc_mean = mean(Pc),
Pc_sd = sd(Pc),
Pc_skewness = skewness(Pc),
Pc_kurtosis = kurtosis(Pc),
Pa_mean = mean(Pa),
Pa_sd = sd(Pa),
Pa_skewness = skewness(Pa),
Pa_kurtosis = kurtosis(Pa)
)
Pc_theoretical_sd &lt;- sqrt(var(Pc) / length(Pc)) # 这里应用渐近正态理论
Pa_theoretical_sd &lt;- sqrt(var(Pa) / length(Pa)) # 同上
比较实证分布和理论分布
results$Pc_theoretical_sd_diff &lt;- abs(Pc_theoretical_sd - results$Pc_sd)
results$Pa_theoretical_sd_diff &lt;- abs(Pa_theoretical_sd - results$Pa_sd)
return(results)
}
调用评估函数
evaluate_all_simulations(results)]]></description>
      <guid>https://stats.stackexchange.com/questions/644779/reproduce-the-estimating-classification-consistency-and-accuracy-for-cognitive-d</guid>
      <pubDate>Thu, 11 Apr 2024 07:39:20 GMT</pubDate>
    </item>
    <item>
      <title>概率和运算顺序[重复]</title>
      <link>https://stats.stackexchange.com/questions/644778/probability-and-order-of-operations</link>
      <description><![CDATA[我很困惑......

&lt;标题&gt;


汽车
自行车
总线
其他


&lt;正文&gt;

新生
10
5
7
2


大二
20
10
11
5


初级
25
20
31
4


高级
18
17
16
14



如果我做 P（新生 | 巴士），答案将是 P（新生给巴士）或“巴士”组中有多少人？ （即 [7, 11, 31, 16]）是新生，即
7/(7 + 11 + 31 + 16) = 7/65
但是，如果我做 P（汽车 | 大二或大四）...
我可以将其视为 P((汽车 | 大二或大四) 或 P(汽车 | (大二或大四))
如果我假设 P((汽车 | 大二) 或大四)：
给定逻辑 P(A 或 B) = P(A) + P(B) - P(A 和 B)
并给出逻辑 P(A 和 B) = P(A) * P(B)，
我也可以构造这样的逻辑：P(A 或 B) = P(A) + P(B) - P(A) * P(B)
我假设：
P(A 或 B) = P(A) + P(B) - P(A) * P(B)
翻译为
P((汽车 | 大二) 或 高年级) = P(汽车 | 大二) + P(高年级) - P(汽车 | 大二) * P(高年级)
求解子方程：
P（汽车 | 大二）= 20 / (20 + 10 + 11 + 5) = 20/46 = 0.43478
P(高级) = (18 + 17 + 16 + 14) / (18 + 17 + 16 + 14 + 25 + 20 + 31 + 4 + 5 + 11 + 10 + 20 + 2 + 7 + 5 + 10 ) = 65/215 = 0.30233
这意味着：
P((汽车|大二)或大四) = 0.43478 + 0.30233 - 0.43478 * 0.30233
P((汽车|大二)或大四)= 0.60566
如果我假设 P(Car | (大二或大四))：
我可以将 [二年级，汽车] 单元格和 [高年级，汽车] 单元格相加，然后将结果除以高年级学生总数和二年级学生总数：
P(汽车 | (大二或大四)) = (20 + 18) / (20 + 10 + 11 + 5 + 18 + 17 + 16 + 14)
P(汽车 | (大二或大四)) = 38 / 111
P(汽车 | (大二或大四)) = 0.34234
我的困惑：
什么时候应该应用联合概率与边际概率？另外，我是否遗漏了一些关于首选操作顺序的内容，或者我是否在编造事情？]]></description>
      <guid>https://stats.stackexchange.com/questions/644778/probability-and-order-of-operations</guid>
      <pubDate>Thu, 11 Apr 2024 07:28:21 GMT</pubDate>
    </item>
    <item>
      <title>为什么在使用 lme4 比较 R 中结果变量的多级模型（对数变换与常规尺度）时 ICC 有所不同？</title>
      <link>https://stats.stackexchange.com/questions/644775/why-does-the-icc-differ-when-comparing-multilevel-models-log-transformations-vs</link>
      <description><![CDATA[我目前正在利用 lme4 包在 R 中开展一个多级建模项目。该研究的主要目的是评估家庭间和家庭内部差异在解释个人收入差异方面的相对重要性。通过检查类内相关系数 (ICC)，我试图量化家庭间差异与家庭内部差异所造成的总收入差异的比例。
为了进行此分析，我生成了一个综合数据集，其中包含嵌套在 40 个族中的 80 个观察值。每个观察结果都包括收入和年龄变量，并将个人分配到不同的家庭。随后，我安装了四个不同的多级模型：
利用原始收入规模（收入）的模型。
采用对数变换的收入规模（对数收入）的模型。
尽管使用相同的数据集，但我观察到这些模型的 ICC 值存在差异。这种不一致是出乎意料的，因为我认为 ICC 应该对结果变量规模的转换保持不变。
下面是我用来生成数据集并拟合模型的代码片段：
库(lme4)
设置.种子(123)

n &lt;- 80 # 观察数
n_families &lt;- 40 # 组（族）数量

# 一级变量（个人收入）
收入 &lt;- rnorm(n，平均值 = 40000，sd = 10000)

# 2 级变量（家庭效应）
family_id &lt;-rep(1:n_families, every = n/n_families) # 家庭归属
family_effect &lt;- rnorm(n_families,mean = 0,sd = 5000) # 家庭对收入的影响

# 根据family_id将家庭影响分配给个人收入
收入 &lt;- 收入 + family_effect[family_id]

# 创建数据框
data &lt;- data.frame(收入 = 收入, 年龄 = 年龄, family_id = 因子(family_id))
数据$log Revenue &lt;- log(data$收入)


# 使用 lmer 拟合多级模型
model_regular_scale &lt;- lmer(收入 ~ 1 + (1 | family_id), data = data)
model_log &lt;- lmer(logvenue ~ 1 + (1 | family_id), data = data)


# 模型总结
摘要（模型_常规_规模）
摘要（模型日志）
摘要（model_10）

# ICC值的计算
icc_regular_scale &lt;- 5518713/(5518713 + 91636300)
icc_log_scale &lt;- 0.003098/(0.003098 + 0.058133)

我将非常感谢任何关于为什么对数转换模型和非缩放模型之间 ICC 值不同的见解或建议。估计过程或结果解释是否存在潜在问题？感谢您的帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/644775/why-does-the-icc-differ-when-comparing-multilevel-models-log-transformations-vs</guid>
      <pubDate>Thu, 11 Apr 2024 06:20:00 GMT</pubDate>
    </item>
    <item>
      <title>基于缺失数据模式组合回归模型</title>
      <link>https://stats.stackexchange.com/questions/644774/combining-regression-models-based-on-missing-data-patterns</link>
      <description><![CDATA[我有一个数据集，其中包含一些缺失模式。对于这个数据集，我有一个完整的训练集，包含所有输入特征。我的测试集对因变量有完整的观察结果，但输入特征存在一些缺失数据的模式。下面我举一个例子：
示例数据集
# 生成缺少数据模式的假测试
subset1 &lt;- data.frame(yield = rnorm(500, 1000, 100)) %&gt;%
  变异(var1 = 产量 * rnorm(500, 100, 5))

subset2 &lt;- data.frame(yield = rnorm(500, 1000, 100)) %&gt;%
  变异(var2 = 产量 * rnorm(500, 100, 10),
         var3 = -产量 * rnorm(500, 100, 4))

subset3 &lt;- data.frame(yield = rnorm(500,1000,100)) %&gt;%
  变异(var1 = 产量 * rnorm(500, 100, 5),
         var3 = -产量 * rnorm(500, 100, 4))

测试 &lt;- plyr::rbind.fill(subset1,subset2,subset3)

# 训练集有完整的观察结果
训练 &lt;- data.frame(yield = rnorm(500,1000,100)) %&gt;%
  变异(var1 = 产量 * rnorm(500, 100, 5),
         var2 = 产量 * rnorm(500, 100, 10),
         var3 = -产量 * rnorm(500, 100, 4))

md.pattern(plyr::rbind.fill(测试，训练))


缺失数据模式
注意第一行是训练集，其他行是测试集

我想对此数据集执行回归，但我对使用插补持谨慎态度，除非我有充分的理由。当然，我可以只删除包含丢失数据的行，但这将删除数据集的很大一部分。我遇到过简化建模的概念，它标识了测试集中缺失数据的不同模式，基于完整的子集训练单独的模型。根据我对这个概念的理解，这就是我尝试过的：
# 查看测试集上缺失的数据模式
模式 &lt;- 小鼠::md.pattern(test,plot=F)

# 启动一个列表以将子集放入其中
model_list &lt;- 列表()

for (i in 1:(nrow(pattern) - 1)) {
  # 获取缺失的数据模式
  cols_with_no_missing &lt;- 名称(which(pattern[i, -ncol(pattern)] == 1))

  # 根据此模式对数据集进行子集化
  subset_df &lt;- 测试 %&gt;%
    选择（all_of（cols_with_no_missing））％&gt;％
    na.省略()

  # 仅使用这些列训练模型
  数据 &lt;- 训练 %&gt;%
    选择（all_of（cols_with_no_missing））
  
  mod &lt;- 训练（产量 ~ .,
               数据=数据，
               方法 = &#39;lm&#39;,
               trControl = trainControl(方法 = &#39;repeatedcv&#39;,
                                        数量 = 10,
                                        重复次数 = 10))
  
  # 获取一些模型统计数据
  obspred &lt;- data.frame(obs=subset_df$yield,
                        pred = 预测(mod,newdata =subset_df))
  
  n_obs &lt;- nrow(obspred)
  rsq &lt;- 摘要(mod)$r.squared
  
  # 创建一个情节
  plt &lt;- obspred %&gt;%
    ggplot(aes(x = obs, y = pred)) +
    几何点（）+
    geom_abline(斜率 = 1) +
    注释（“文本”，x = -Inf，y = Inf，
             标签=粘贴(粘贴(&#39;n&#39;,n_obs,sep=&#39;=&#39;),
                           粘贴（&#39;R²&#39;，圆形（rsq，2），sep =&#39;=&#39;），
                           粘贴（&#39;产量&#39;，粘贴（cols_with_no_missing[-1]，折叠=&#39;+&#39;），sep=&#39;〜&#39;），
                           九月=&#39;\n&#39;),
             hjust = -0.1，vjust = 1，大小 = 4)

  model_list[[i]] &lt;- plt
}

# 比较模型测试性能
图书馆（拼凑而成）
包裹图（模型列表）+情节布局（轴=&#39;收集&#39;）


测试性能

我的问题

我想知道使用这种方法会产生什么后果，或者是否有更合适的方法来做类似的事情？
您能否创建某种集成模型，根据可用功能选择适当的子模型？如果是这样，您将如何将不断变化的准确性（根据可用功能而变化）纳入其中？

我的实际数据集比这个示例大得多（约 90,000 个观测值），具有 25 个特征，因此实际上我将使用随机森林回归，但（我认为？？）原理应该类似。]]></description>
      <guid>https://stats.stackexchange.com/questions/644774/combining-regression-models-based-on-missing-data-patterns</guid>
      <pubDate>Thu, 11 Apr 2024 04:01:55 GMT</pubDate>
    </item>
    <item>
      <title>关于分层对数秩检验的最早论文</title>
      <link>https://stats.stackexchange.com/questions/644772/earliest-paper-on-stratified-log-rank-test</link>
      <description><![CDATA[最早提出对数秩检验的分层版本的论文是什么？
不幸的是，在教科书中查找既定统计程序的引文/参考文献很困难。]]></description>
      <guid>https://stats.stackexchange.com/questions/644772/earliest-paper-on-stratified-log-rank-test</guid>
      <pubDate>Thu, 11 Apr 2024 03:24:52 GMT</pubDate>
    </item>
    <item>
      <title>使用论文中的 GEE 重现简单交叉试验的分析</title>
      <link>https://stats.stackexchange.com/questions/644771/reproduce-an-analysis-of-a-simple-crossover-trial-using-gee-from-a-paper</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/644771/reproduce-an-analysis-of-a-simple-crossover-trial-using-gee-from-a-paper</guid>
      <pubDate>Thu, 11 Apr 2024 02:18:08 GMT</pubDate>
    </item>
    <item>
      <title>如何计算下面的Dirichlet分布和Beta分布的期望？</title>
      <link>https://stats.stackexchange.com/questions/644769/how-to-calculate-the-expectation-of-the-following-dirichlet-distribution-and-bet</link>
      <description><![CDATA[这是我研究中的一个问题，涉及基于 LDA 的模型的平均场假设的变分 EM 算法的推导。$$E_{q(\psi, \boldsymbol{\varphi} \mid \boldsymbol{\lambda}, \boldsymbol{\mu})}[\log{((1-\psi)\cdot \varphi_{v} +\psi)}]$$&lt; /跨度&gt;
其中 $\psi$ 和 $\boldsymbol{\varphi}$ 是独立的， $\psi \sim \mathrm{Beta}(\lambda_1, \lambda_2), \boldsymbol{\varphi} = (\varphi_1, \varphi_2,\cdots, \varphi_V) \sim \mathrm{Dir} (\boldsymbol{\mu})$]]></description>
      <guid>https://stats.stackexchange.com/questions/644769/how-to-calculate-the-expectation-of-the-following-dirichlet-distribution-and-bet</guid>
      <pubDate>Thu, 11 Apr 2024 02:03:03 GMT</pubDate>
    </item>
    <item>
      <title>滞后增强局部投影和标准误差</title>
      <link>https://stats.stackexchange.com/questions/644757/lag-augmented-local-projection-and-standard-errors</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/644757/lag-augmented-local-projection-and-standard-errors</guid>
      <pubDate>Wed, 10 Apr 2024 22:29:14 GMT</pubDate>
    </item>
    <item>
      <title>当所有变量都是因子时，残差在逻辑回归中重要吗？</title>
      <link>https://stats.stackexchange.com/questions/644737/are-residuals-important-in-logistic-regression-when-all-variables-are-factors</link>
      <description><![CDATA[我有一个关于逻辑回归模型中残差的概念性问题。
据我所知，对于线性回归，残差代表观察值和拟合值之间的差异。线性回归模型可以根据拟合值与观测值的偏差（偏差）来评估，并且有各种统计数据使用偏差来评估拟合优度，例如众多 R2 统计数据之一的 AIC。&lt; /p&gt;
我可以看到逻辑回归中的情况是这样的，其中至少一个变量（响应变量或解释变量）是连续的。
我不太清楚的是，当所有变量都是因子时，残差的作用。
假设我有一个模型，试图预测结果 A 对结果 B 的选择，并且解释变量都是二元的，或者具有阶乘水平“是、否”。或“选项 1、选项 2、选项 3”。
在这种情况下，残差代表什么？其实，“距离”并不大。之间的价值观对吗？对我来说似乎有点抽象。
我读过的有关逻辑回归的大多数资源都涉及至少包含一个连续变量的示例，很少涉及所有变量都是阶乘的情况。
我读到的一个消息来源表明，对于这些情况，像 Nagelkerke psuedo-R2 这样的统计数据是因为总方差的比例“概念上不太清晰”。
我认为人们可以为 AIC 提出同样的理由。
所以我的总体问题是，如果残差是确定回归模型拟合优度的关键因素，但它们在逻辑回归模型中并不那么相关，那么如何评估模型中的拟合优度纯阶乘变量？]]></description>
      <guid>https://stats.stackexchange.com/questions/644737/are-residuals-important-in-logistic-regression-when-all-variables-are-factors</guid>
      <pubDate>Wed, 10 Apr 2024 17:05:12 GMT</pubDate>
    </item>
    <item>
      <title>对连续解释变量每单位变化结果的纵向变化进行建模</title>
      <link>https://stats.stackexchange.com/questions/644717/modeling-longitudinal-change-in-outcome-per-unit-of-change-in-a-continuous-expla</link>
      <description><![CDATA[我的问题与相关您如何处理“嵌套”问题？回归模型中的变量？但是，我的问题略有不同。
我正在分析减肥干预的基因表达数据。在干预前和两个随访点（变量访问）对参与者进行了测量。从后续 1 到后续 2，参与者的体重减轻了不同程度，有些甚至反弹了。我们还有其他队列的数据，无法与该数据集直接比较。然而，为了产生具有一定可比性的结果，我想对基因表达的干预效果进行建模，以便结果能够通过体重减轻百分比 (wlp) 显示从基线到每次随访的变化。 
在本例中，visit 是解释变量，wlp 嵌套在其中。如果我只有两个时间点，我将仅使用 wlp 作为解释变量来获得我想要的结果（给出与 visit:wlp 交互相同的结果）。 
我的问题是：在这种情况下，当有三个时间点时，没有主效应的 visit:wlp 交互是否会给我每个 wlp 结果（基因表达）的变化code&gt; 处两次不同的访问？如果我分别分析两个后续点，估计结果非常相似；然而，p 值较小。]]></description>
      <guid>https://stats.stackexchange.com/questions/644717/modeling-longitudinal-change-in-outcome-per-unit-of-change-in-a-continuous-expla</guid>
      <pubDate>Wed, 10 Apr 2024 11:01:24 GMT</pubDate>
    </item>
    <item>
      <title>收敛的概率几乎确定，而现实中的概率为 0</title>
      <link>https://stats.stackexchange.com/questions/644665/almost-sure-probability-in-convergence-versus-0-probability-in-reality</link>
      <description><![CDATA[我对概率分布收敛的含义有一些疑问。考虑这个示例问题：对于一个公平的骰子，抛出$6x$次，对于整数$x$，将 $y$ 定义为看到每个结果 $x$ 次的概率。
我之前的想法是，大数定律说 $$\underset{x \rightarrow \infty}{\lim} y = 1 \tag{1} $$
但情况似乎更加复杂。我们可以以封闭形式计算 $y$：
$$y = \dfrac{(6x)!}{6^{6x} (x!)^6} \quad \Rightarrow \quad \underset{x \rightarrow \infty} {\lim} y = 0\tag{2}$$
上面的问题让我想到了第二个例子，你们中的一些人可能更喜欢这个例子。
让我们在 $\{0, 1\}$ 的支持下定义随机变量 $X$ span&gt;，这样 $\mathbb{P}(X = 1) = 1/6$ 和 $\mathbb{ P}(X = 0) = 5/6$。使用定义
$$\bar{X}_n = \frac{1}{6n}\sum_1^{6n} X_i$$
我们有那个
$$\mathbb{P}(\bar{X}_n = 1/6) = {6n \选择 n}\left( \dfrac{1}{6} \right) ^n\left(\dfrac{5}{6} \right)^{5n}$$
由此可见
$$\underset{n \rightarrow \infty}{\lim}\mathbb{P}(\bar{X}_n = 1/6) = 0 \tag{3}$ $
现在，根据维基百科页面，根据大数定律，
$$\mathbb{P}( \underset{n \rightarrow \infty}{\lim} \bar{X}_n = 1/6) = 1 \tag{4}$ $
这说明了等式之间明显矛盾的原因。 (1) 和 (2) - 极限和概率的顺序不同。在我看来，两个方程。 （3）和（4）是有效的，这对我来说似乎很奇怪。我希望这两个方程应该具有相同的值。
是等式。 3 有效吗？如果是这样，为什么应该等式。 4 也有效吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/644665/almost-sure-probability-in-convergence-versus-0-probability-in-reality</guid>
      <pubDate>Tue, 09 Apr 2024 19:42:46 GMT</pubDate>
    </item>
    <item>
      <title>分割稀疏数据集时生成没有数据的集合的概率</title>
      <link>https://stats.stackexchange.com/questions/644617/probability-of-making-a-set-with-no-data-when-splitting-a-sparse-dataset</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/644617/probability-of-making-a-set-with-no-data-when-splitting-a-sparse-dataset</guid>
      <pubDate>Tue, 09 Apr 2024 07:57:09 GMT</pubDate>
    </item>
    <item>
      <title>为什么因子在 2 向方差分析中显得显着，但通过检查（平均值 +/- sd 或误差图）却不显着？</title>
      <link>https://stats.stackexchange.com/questions/644574/why-does-factor-appear-significant-in-2-way-anova-but-not-by-inspection-mean</link>
      <description><![CDATA[我对双向方差分析的结果感到困惑。这些因素是分类因素和非随机因素，所使用的平方和受 III 型约束（不过，分类或 SS 类型的选择似乎对结果并不重要）。
数据由50个测量值、一个因素(“催化剂”)的2个水平、另一因素(“化学处理”)的5个水平以及每个处理5个重复组成。
下面的误差图说明了各个处理的平均值+/-标准差，根据因子#2（催化剂，有两个水平，-/+）进行阻止。
（编辑：我用错误图替换了箱线图；评论进一步建议简单地使用散点图。注意，我选择发布箱线图是因为这是 MATLAB ANOVA 函数提供的默认可视化；这些函数的文档解释了线条和符号的含义，可能有些独特）。

在上述处理中，1-5和6-10对应于因子#2（催化剂）的两个水平（-/+），而处理1-5在因子#1（化学处理，水平与6-匹配）方面有所不同。 10).
从检查来看，因素#1（化学处理）有效果，但对于因素#2（催化剂）却很难说有效果。
我在 MATLAB 中运行分析
[p,tbl,model] = anovan(msmnt,{var1,var2},“模型”,“交互”,&#39;varnames&#39;,{&#39;var 1&#39;,&#39;var 2&#39;}) ; %双因素方差分析
这是输出表：

&lt;标题&gt;

来源
平方和
d.f.
平均平方
F
问题&gt;F


&lt;正文&gt;

因子 1（化学处理）
612.97
4
153.242
56.86
0


因子 2（催化剂）
22.445
1
22.445
8.33
0.0063


因子 1:因子 2
12.53
4
3.132
1.16
0.3418


错误
107.8
40
2.695




总计
755.745
49






由于这两个因素（并且没有交互作用），似乎存在显着影响（95% 置信度）。
我手动计算了一些方差分析项，它们（嗯，我的计算）似乎是正确的。
但是，如果您查看因素 #2 的两个水平中每个水平的均值：

&lt;标题&gt;

事实#2（催化剂）级别
平均
示例标准开发


&lt;正文&gt;

-
15.35
4.50


+
16.68
3.34



误差图（简单检查）和平均值表明这不是显着差异（由于因素 #2、催化剂而没有影响），但方差分析表似乎另有说明。
这种相互矛盾的解释令人困惑。我的分析中遗漏了什么？方差分析是否看到了我没有看到的东西？
我怀疑原因是治疗内差异相对较小。然而，如果这是真的，我如何确定各个对中的两种处理（例如 1-6、2-7 等，存在或不存在催化剂时不同）是否会产生显着不同的效果？]]></description>
      <guid>https://stats.stackexchange.com/questions/644574/why-does-factor-appear-significant-in-2-way-anova-but-not-by-inspection-mean</guid>
      <pubDate>Mon, 08 Apr 2024 16:01:53 GMT</pubDate>
    </item>
    <item>
      <title>Gompertz AFT 模型中误差项的分布是怎样的？</title>
      <link>https://stats.stackexchange.com/questions/644010/what-is-the-distribution-of-error-term-in-gompertz-aft-model</link>
      <description><![CDATA[给定 AFT 模型 $\ln(T)=\beta+\sigma\times W$， 的分布$T$ 取决于随机项 $W$。如果 $T$ 遵循具有形状和速率的 Gompertz 分布，我如何导出 $\sigma$&lt; 的值/span&gt; 和 $\beta$ 的形状和速率？我想首先我需要知道 $W$ 的分布。]]></description>
      <guid>https://stats.stackexchange.com/questions/644010/what-is-the-distribution-of-error-term-in-gompertz-aft-model</guid>
      <pubDate>Mon, 01 Apr 2024 08:20:34 GMT</pubDate>
    </item>
    </channel>
</rss>