<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Mon, 18 Dec 2023 21:11:49 GMT</lastBuildDate>
    <item>
      <title>“置信区间内的 0 意味着没有显着性”对于图形线性回归置信区间是否有效？</title>
      <link>https://stats.stackexchange.com/questions/635217/does-0-inside-the-confidence-interval-means-no-significance-work-for-graphed-l</link>
      <description><![CDATA[在进行假设检验时，确定某个值 $a$ 是否与其他值 $b$&lt; 显着不同/span&gt;，如果 $a$ 的置信区间包含 $b$，那么我们不能拒绝零假设，因此 $a$ 与 $b$ 没有显着差异。
以下图为例（用Python中的seaborn.regplot绘制）：

当我对拟合的回归进行适当的显着性测试时，我得到以下结果：

&lt;表类=“s-表”&gt;
&lt;标题&gt;


系数
标准错误。
t
P&gt;绝对值(t)
[0.025
0.975]


&lt;正文&gt;

常量
0.2529
0.031
8.111
0.000
0.186
0.320


（1-log（动量））
0.0192
0.017
1.131
0.279
-0.017
0.056




截距明显显着，但斜率并非显着非零，因为其置信区间包含 0。
当我查看图表时，我注意到我能够绘制一条完全适合置信区间的水平线，如下所示：

似乎我可以通过查看是否可以在置信区间内拟合一条水平线来判断斜率是否与 0 显着不同。
我的问题是这样的：
这是巧合还是这个技巧通常有效？
它也适用于拦截吗？
（例如，如果 x 轴位于区间内，则它与 0 没有显着差异）]]></description>
      <guid>https://stats.stackexchange.com/questions/635217/does-0-inside-the-confidence-interval-means-no-significance-work-for-graphed-l</guid>
      <pubDate>Mon, 18 Dec 2023 21:08:23 GMT</pubDate>
    </item>
    <item>
      <title>比较 GAM 模型中平滑效应的驱动因素</title>
      <link>https://stats.stackexchange.com/questions/635216/compare-drivers-of-a-smoothed-effect-in-a-gam-model</link>
      <description><![CDATA[假设我有一个简单的平滑 GAM 模型，在 R 中编码如下：
&lt;前&gt;&lt;代码&gt;库(mgcv)
m1 &lt;- gam(main_outcome ~ 控制 + s(时间),data=data)

我发现时间有平滑效应，但我相信还有其他变量可以解释时间的平滑效应。我为这些替代变量运行单独的 GAM，结果也如下：
m2 &lt;- gam(解释1 ~ 控制 + s(时间),数据=数据)
m3 &lt;- gam(解释2 ~ 控制 + s(时间),数据=数据)


我也发现了这些变量的平滑效应，但我相信这些是 main_outcome 平滑的、基于时间的下降的潜在原因。例如，我认为 main_outcome 在 age 的上半部分大幅下降，因为 explanation1 在年龄的上半部分大幅增加。 p&gt;
如何创建一个模型来评估 explanation1 和 explanation2 对 time 对 main_outcome 的平滑效果的相对贡献？
本质上，我想创建一个正常的回归模型来解释 main_outcome 中的平滑变化，并比较我的两种解释的效果大小。如果没有 GAM，这将通过如下方式完成：
lm(main_outcome ~ 解释1 + 解释2 + 控制，数据=数据)


我可以比较explanation1和explanation2的系数/p值。
但是我知道main_outcome的变化是基于时间的平滑下降趋势。如何测试时间的平滑效果是否更多地由 explanation1 或 explanation2 驱动。
对于 GAM 来说这可能吗？或者 GAM 不存在这种分析吗？是否有其他方法来评估平滑效果的来源？]]></description>
      <guid>https://stats.stackexchange.com/questions/635216/compare-drivers-of-a-smoothed-effect-in-a-gam-model</guid>
      <pubDate>Mon, 18 Dec 2023 21:07:48 GMT</pubDate>
    </item>
    <item>
      <title>如何评价一个稀有类别分类器？</title>
      <link>https://stats.stackexchange.com/questions/635214/how-to-evaluate-a-rare-category-classifier</link>
      <description><![CDATA[我想为一个非常罕见的类别制作一个分类器。随机样本中的基本率约为 0.01%，是通过使用零样本分类器在 100,000 个未标记示例上找到大约 10 个正示例来估计的。
我可以访问更多未标记的示例。
显然，在这种情况下有很多奇怪而奇妙的技术来处理训练分类器（例如主动学习），但我仍然需要能够评估不同的分类器。&lt; /p&gt;
我想要一个保留/测试集来评估我在不同技术上的表现。
这里有哪些选项/最佳实践？假设手动标记随机数据样本以使用测试集是不切实际的，因为即使只获得 100 个正面示例，我也会这样做需要标记 100 万个示例。]]></description>
      <guid>https://stats.stackexchange.com/questions/635214/how-to-evaluate-a-rare-category-classifier</guid>
      <pubDate>Mon, 18 Dec 2023 20:57:03 GMT</pubDate>
    </item>
    <item>
      <title>根据物种出现的日期和时间是否位于多个时间段内的其他日期之间创建新列</title>
      <link>https://stats.stackexchange.com/questions/635213/create-new-column-based-on-whether-date-and-time-at-which-a-species-occurs-is-be</link>
      <description><![CDATA[我有一个包含多个行物种的数据框 (df1)，以及该物种发生的日期时间事件，如下所示：
df1&lt;-as.data.frame(sample(seq(from=as.POSIXct(“2023-07-01 00:00”),to=as.POSIXct(“2023-07-”) 01 00:20&quot;),by=&quot;秒&quot;),21))
df1
colnames(df1)&lt;-c(&#39;day.hour.df1&#39;) #重命名df2的列
df1$Species&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;NA&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot; ；、“b”、“b”、“c”、“c”、“NA”、“a”、“a”、“b”、“b”、“a” ;,“NA”,“b”) #添加物种列
名称(df1)

我有第二个数据框（df2），作为列，包含开始（作为日期和时间）（START.df2）、结束（END.df2）和物种（此处为“a”）。第二个数据框如下所示：
df2&lt;-as.data.frame(seq(from=as.POSIXct(“2023-07-01 00:00:00”),to=as.POSIXct(“2023-07-”) 01 00:20:00&quot;),by=&quot;分钟&quot;))
df2
df2$time2&lt;-(seq(from=as.POSIXct(&quot;2023-07-01 00:00:59&quot;),to=as.POSIXct(&quot;2023-07-01 00:20:59&quot;),by=&quot;分钟&quot;))
名称(df1)
df2$物种&lt;-(c(&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a &#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;))
df2

colnames(df1)&lt;-c(&#39;START.df2&#39;,&#39;END.df2&#39;,&#39;物种&#39;)

我想向第二个数据帧 (df2) 添加一个名为“occurrence_a”的新列，其中，如果物种“a”为df1 中包含的数据出现在数据帧 2 (df2) 的 START (START.df2) 和 END (END.df2) 之间的 day_time (day.hour.df1) 处，则给出 1，否则给出 0。
我尝试过但没有成功：
库(dplyr)


df2 %&gt;% left_join(df1, by = “物种”) %&gt;%
  mutate( = 之间(day.hour.df2, START.df1, END.df1)) %&gt;%
  group_by(物种, day.hour.df1) %&gt;%
  总结（OCCURRENCEa = 任意（OCCURRENCEa））
df2


 
]]></description>
      <guid>https://stats.stackexchange.com/questions/635213/create-new-column-based-on-whether-date-and-time-at-which-a-species-occurs-is-be</guid>
      <pubDate>Mon, 18 Dec 2023 20:57:01 GMT</pubDate>
    </item>
    <item>
      <title>R party::cforest 中的 mtry [关闭]</title>
      <link>https://stats.stackexchange.com/questions/635212/mtry-in-r-partycforest</link>
      <description><![CDATA[在 R 中使用 party::cforest 之前，您能帮忙正确定义 mtry 吗？我还没有找到如何为条件随机森林定义这个值]]></description>
      <guid>https://stats.stackexchange.com/questions/635212/mtry-in-r-partycforest</guid>
      <pubDate>Mon, 18 Dec 2023 20:26:10 GMT</pubDate>
    </item>
    <item>
      <title>什么时候分组变量应该在混合效应模型中相互作用？</title>
      <link>https://stats.stackexchange.com/questions/635210/when-should-grouping-variables-interact-in-a-mixed-effects-model</link>
      <description><![CDATA[我正在阅读这篇文章，它与我正在做的一个研究项目相关现在正在努力。我认为我理解交叉随机效应和嵌套随机效应之间的区别，例如如所述在这里。
我链接的第一篇文章询问随机效应结构之间的差异Ticks~(1|Year)+(1|Site) 与 Ticks~(1|Year)+(1|Site)+(1|Year:Site)，即除了跨年份和跨站点的变化之外，还允许每个Site 的刻度数随年份变化。由于每年对每个站点都有多次观测，因此该模型是可估计的，并且比省略术语 (1|Year:Site) 的模型更灵活。
虽然优秀的GLMM FAQ没有提到分组变量之间的相互作用， Ben Bolker 在此处的另一篇文章中提到了这一点，其中也描述了这种影响因为允许每年的影响因地点而异。
我试图更多地了解分组变量之间的这种相互作用以及何时可能需要这种相互作用，以及左轴上带有 1 的术语或左轴上的变量之间的差异是否不同分组术语。假设这样的模型是可估计的，在什么情况下人们会想要使用模型 y ~ (x|f) + (x|g) 而不是 y ~ (x|f) + (x|g) + (x|f:g) ？
从我读到的很多内容来看，似乎前一种模型通常被推荐用于完全交叉的设计。这是否证明省略额外术语是合理的？为什么？
我是否只是想得太多了，这个术语的包含应该基于领域知识和具体数据？]]></description>
      <guid>https://stats.stackexchange.com/questions/635210/when-should-grouping-variables-interact-in-a-mixed-effects-model</guid>
      <pubDate>Mon, 18 Dec 2023 19:26:41 GMT</pubDate>
    </item>
    <item>
      <title>EDA 中的异常值 - 有还是没有？</title>
      <link>https://stats.stackexchange.com/questions/635209/outliers-in-eda-with-or-without</link>
      <description><![CDATA[我正在尝试对学生表现数据集执行我的第一次 EDA。该数据集有 395 个样本，由 33 个属性组成。绘制箱线图并进行一些测试后，我在其中 10 个属性中检测到异常值，范围从非常小的百分比 (0.3%) 到较高的百分比（高达 21%）。在某些专栏中，异常值是否确实是异常值有点主观（例如，学生没有参加考试并获得 0 分），但让我们忽略这些。
我主要关心的是：
我想检查变量之间的成对关联。这样做时我是否应该包含异常值？
&lt;小时/&gt;
我已经写了我的问题，但我会提供更多信息以防有帮助。
最初，我决定将异常值包含在测试中。这是我遵循的策略：

我发现哪些变量遵循（近似）正态分布。没有找到这样的变量，因此我继续对成对关联进行非参数检验。
我对数值变量对使用了 Spearman 的等级相关系数，因为 Spearman 对异常值不敏感。
对于分类对，我使用了蒙特卡罗卡方。
对于二进制和数字对，我使用 Shapiro 来确定数字变量在二进制变量的两个级别中是否遵循正态分布。 Shapiro 表明，在任何二元水平上，没有变量遵循正态分布，因此我继续进行 Mann - Whitney U 检验。
对于名义和数值对，我使用方差分析，然后使用夏皮罗来验证残差的正态性。

我一直在研究几个 EDA 示例来掌握 EDA 步骤，但似乎每个人都有自己的方法。大多数人甚至不使用这些统计测试。绘图和相关矩阵就其配对关联而言。我是不是把事情搞得太复杂了？]]></description>
      <guid>https://stats.stackexchange.com/questions/635209/outliers-in-eda-with-or-without</guid>
      <pubDate>Mon, 18 Dec 2023 18:50:05 GMT</pubDate>
    </item>
    <item>
      <title>研究样本设计的好教科书</title>
      <link>https://stats.stackexchange.com/questions/635207/good-textbooks-to-study-the-sample-design</link>
      <description><![CDATA[我将编写一些有关统计样本调查方法的高级主题的测试，其中包括如下主题
简单随机抽样、系统抽样、PPS 抽样、分层抽样。
比率和回归估计方法。非抽样误差、非响应偏差
好的大学针对上述主题会参考哪些教科书？包含大量解决方案的教科书会非常好。]]></description>
      <guid>https://stats.stackexchange.com/questions/635207/good-textbooks-to-study-the-sample-design</guid>
      <pubDate>Mon, 18 Dec 2023 17:26:59 GMT</pubDate>
    </item>
    <item>
      <title>glmms 中的哪些系列和链接函数？</title>
      <link>https://stats.stackexchange.com/questions/635206/which-family-and-link-function-in-glmms</link>
      <description><![CDATA[我正在尝试 GLMM 模型来测试两个分类变量（物种和性别）及其相互作用（性别 + 物种 + 性别*物种 = 固定因素）是否影响某些发声的某些声学参数（响应变量）。我的响应变量是连续数值，例如发声的基本频率或持续时间。因此，我正在为我拥有的每个声学参数尝试不同的 glmm。
我的响应变量没有正态分布，它们非常不对称，其中一个有两个中央驼峰。
例如，我尝试过基频、进行对数变换，以及使用伽马或高斯与各种链接函数（对数、逆），但当我检查假设（正态性、残差同质性）时，这些都没有得到验证。
您推荐哪些系列和链接功能？在运行 glmm 之前我应该​​做些什么（例如日志转换、标准化）？ （显然，我在运行模型之前将分类变量转换为因子）
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/635206/which-family-and-link-function-in-glmms</guid>
      <pubDate>Mon, 18 Dec 2023 17:26:39 GMT</pubDate>
    </item>
    <item>
      <title>ROC 综合生物标志物</title>
      <link>https://stats.stackexchange.com/questions/635204/intergrated-biomarkers-for-roc</link>
      <description><![CDATA[我正在寻找组合多个定量值的方法，以便构建具有特异性和敏感性的 ROC 曲线。这似乎在多种生物标记论文中很常见，但我找不到任何直接的方法来做到这一点。 CombiROC 似乎就是为此而设计的，但 Shinyapp 不再工作，软件包也没有更新，这让我质疑它的用途。
我对一组具有各种临床表现的患者的血清进行了多重分析，以量化蛋白质浓度，并发现其中一些是相关的。单独使用这些蛋白质，我可以构建 ROC 曲线。我想进一步推动我的分析，建立一个模型，在其中我可以组合/整合这些标记中的 2 或 3 个，从而完善诊断并获得更好的 AUC/Spe/Sen 值。
到目前为止，这是我发现的方法：我首先构建一个 glm 模型，从中预测落入该组的机会。最后，我通过绘制预测结果与实际结果来计算 ROC。
#与临床组一起构建 glm（二元结果）
组合.glm &lt;- glm(数据集$Group1 ~
                               数据集$分析物1 +
                               数据集$Analyte2 +
                               数据集$分析3，
                               家庭=“二项式”）

#使用模型预测小组结果
数据集$prob.Group1=预测(Combined.glm,type=c(“响应”))

#建立ROC
roc&lt;- roc(数据集$Group1, dataset$prob.Group1)

我想知道这是否是正确的方法，如果不是，应该怎么做？
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/635204/intergrated-biomarkers-for-roc</guid>
      <pubDate>Mon, 18 Dec 2023 16:48:22 GMT</pubDate>
    </item>
    <item>
      <title>使用旧的后验作为给定新数据的新先验[重复]</title>
      <link>https://stats.stackexchange.com/questions/635201/using-old-posterior-as-new-prior-given-new-data</link>
      <description><![CDATA[假设我有一些数据，并使用这些数据创建后验分布。
现在假设我有一些新数据，我相信这些数据与之前的数据来自同一人群。考虑到我的新数据，我现在可以使用旧的后验分布作为新的先验分布吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635201/using-old-posterior-as-new-prior-given-new-data</guid>
      <pubDate>Mon, 18 Dec 2023 16:39:41 GMT</pubDate>
    </item>
    <item>
      <title>我可以在计算 CI 之前删除单个引导样本吗？</title>
      <link>https://stats.stackexchange.com/questions/635200/can-i-remove-a-single-bootstrap-sample-before-calculating-ci</link>
      <description><![CDATA[我将 boot::boot 与 BCa 结合使用来评估二项式模型的不确定性估计。统计函数通过 G-computation 手动编码为集群引导程序（完整解释和可复制代码：https://stats.stackexchange .com/a/620201/323174）。
在极少数情况下，我得到的样本仅包含一些聚类级别，该样本返回不完整的样本估计（即，一个聚类级别之一缺少行的表）。作为响应，引导功能失败并出现错误（boot::boot line 124: ...t.star[r, ] &lt;- res[[r]] 给出：要替换的项目数量不是替换长度的倍数）。
为了解决这个问题，我编辑了 boot::boot 函数来删除不完整的样本，并返回一个带有更新的 R 的较小引导程序。
例如，这个引导程序：
boot_out.rrt.dich.uo &lt;- boot(pair_ids, boot_fun_by,
                         R = 99)

返回：
普通非参数引导程序


称呼：
启动（数据=pair_ids，统计=boot_fun_by，R=98）


引导统计：
        原始偏差标准错误
t1* 3.494313e-01 2.572816e+11 2.546256e+12
t2* 2.746097e+13 -2.622462e+1​​3 5.558065e+12
t3* 1.415745e-11 4.028178e+03 1.470726e+04

请注意，函数中的 R = 99 在结果中变为 R = 98（实际代码在 boot::boot 中更改） code&gt; 函数可以在此 fork 中看到。 ）
除了减少样本数量之外，这是否会影响使用 type = &quot;bca&quot; 进行 boot::boot.ci 的计算？]]></description>
      <guid>https://stats.stackexchange.com/questions/635200/can-i-remove-a-single-bootstrap-sample-before-calculating-ci</guid>
      <pubDate>Mon, 18 Dec 2023 16:38:14 GMT</pubDate>
    </item>
    <item>
      <title>证明 K-means 对应于 EM 算法？</title>
      <link>https://stats.stackexchange.com/questions/635199/proving-that-k-means-corresponds-to-an-em-algorithm</link>
      <description><![CDATA[只是想确保我的证明是正确的，并且我在此过程中没有遗漏任何内容。有什么想法吗？
”
为了从数学上证明K-means算法对应于期望最大化算法，我们需要证明对于似然函数和先验分布的特定选择，K-means算法可以从EM算法导出。
K 均值算法可以从具有相等协方差矩阵的 K 个高斯混合的 EM 算法导出。在这种情况下，似然函数由下式给出：
$$p(x_n|z_n=k,\mu_k,\Sigma)=\frac{1}{(2\pi\sigma^2)^{D/2 }}\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_k\|^2\right)$$
其中 $x_n$ 是第 $n$ 个数据点，$z_n$ 是表示 $x_n$ 的簇分配的潜在变量，$ \mu_k$ 是第 $k$ 个簇的平均值，$\Sigma$ 是协方差矩阵，$\sigma^2$ 是公共方差。
先验分布由下式给出：
$$p(z_n=k)=\frac{1}{K}$$
假设每个簇的可能性相同。
这种高斯混合的 EM 算法由下式给出：

随机初始化均值$\mu_k$。
E-step：根据数据 $x_n$ 计算聚类分配的后验概率 $z_n$ span&gt; 和当前的意思 $\mu_k$:

$$r_{nk}=\frac{\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_k\|^ 2\right)}{\sum_{j=1}^K\exp\left(-\frac{1}{2\sigma^2}\|x_n-\mu_j\|^2\right)}$$&lt; /跨度&gt;
其中 $r_{nk}$ 是第 $k$ 集群的责任第 $n$ 个数据点。

M-step：使用职责更新方法$\mu_k$：

$$\mu_k=\frac{\sum_{n=1}^N r_{nk}x_n}{\sum_{n=1}^N r_{nk} }$$

重复步骤 2 和 3，直至收敛。

现在，让我们证明 K-means 算法与该 EM 算法相对应。 K-means 算法由下式给出：

随机初始化均值$\mu_k$。
分配步骤：将每个数据点分配给最接近的聚类均值：

$$z_n=\arg\min_k\|x_n-\mu_k\|^2$$

重新拟合步骤：将均值 $\mu_k$ 更新为分配给它们的数据点的平均值：

$$\mu_k=\frac{1}{N_k}\sum_{n:z_n=k}x_n$$
其中 $N_k$ 是分配给第 $k$ 个集群的数据点数量.
通过设置 $\sigma^2=\frac{1}{ 可以看出，K-means 算法对应于等协方差矩阵高斯混合的 EM 算法2}$ 和 $r_{nk}=1$ 如果 $z_n=k$和 $r_{nk}=0$ 否则。在这种情况下，似然函数简化为：
$$p(x_n|z_n=k,\mu_k)=\frac{1}{\sqrt{2\pi}}\exp\left(-\frac{ 1}{2}\|x_n-\mu_k\|^2\right)$$
这是具有单位方差的高斯分布。先验分布由下式给出：
$$p(z_n=k)=\frac{1}{K}$$
假设每个簇的可能性相同。
EM 算法的 E 步简化为：
$$r_{nk}=\begin{cases}1 &amp; \text{if }z_n=k\\0 &amp; \text{其他}\end{案例}$$
这相当于K-means算法的赋值步骤。
EM 算法的 M 步简化为：
$$\mu_k=\frac{\sum_{n=1}^N r_{nk}x_n}{\sum_{n=1}^N r_{nk} }=\frac{1}{N_k}\sum_{n:z_n=k}x_n$$
这相当于K-means算法的重新拟合步骤。
因此，我们已经证明，K 均值算法对应于似然函数和先验分布的特定选择的期望最大化算法。”]]></description>
      <guid>https://stats.stackexchange.com/questions/635199/proving-that-k-means-corresponds-to-an-em-algorithm</guid>
      <pubDate>Mon, 18 Dec 2023 16:14:53 GMT</pubDate>
    </item>
    <item>
      <title>计算到核 PCA 子空间的正交距离（使用新数据）</title>
      <link>https://stats.stackexchange.com/questions/635198/calculating-the-orthogonal-distance-to-kernel-pca-subspace-with-a-new-data</link>
      <description><![CDATA[我正在研究内核 PCA 方法，现在我正在尝试计算特征空间上的正交距离 (OD)。我发现，如果您对训练观察结果之一感兴趣，您可以使用内核技巧来计算 OD。但是，我找不到计算新观察值和之前创建的内核 PCA 子空间之间 OD 的方法。
让 $X$ 成为我们的训练集，以行作为观察值，$\phi$ 映射到特征空间，$k$ 我们的 Mercer 内核和 $K$ 我们的内核矩阵 $K_{i,j} = k(x_i, x_j)$。单个观测值的 OD 由以下方程给出。
$$
OD_i = \| \phi(x_i) - \widehat{\phi(x_i)} \|,
$$
其中 $\widehat{\phi(x)}$ 是 $\phi(x)$ 在内核 PCA 子空间上。通过核技巧和毕达哥拉斯定理，我们可以得到以下结果。
\begin{eqnarray*}
OD_i^2 &amp;=&amp; \| \phi(x_i) - \widehat{\phi(x_i)} \|^2 = \| \phi(x_i) - \hat\mu \|^2 + \| \widehat{\phi(x_i)} - \hat\mu \|^2 \text{
 （毕达哥拉斯）} \\
  &amp;=&amp; \langle \phi(x_i) - \hat\mu, \phi(x_i) - \hat\mu \rangle - \sum_{j=1}^k {t_{ij}^2} \\
  &amp;=&amp; (K_c)_{i,i} - \sum_{j=1}^k {t_{ij}^2}
\end{eqnarray*}
$\hat\mu$ 是 KPCA 子空间的中心估计。在求和部分中 $t_{ij}$ 只是第一个 $k$ 主成分的元素。推导仅根据毕达哥拉斯定理，但您可以忽略它。
我的问题是，当我使用 $x_{\text{test}}$ 时，该 $x_{\text{test}}$ 未用于创建 $K$，我找不到$(K_c)_{i,i}$。我该如何将方程更改为没有 $(K_c)_{i,i}$ 的形式？
我尝试将 $\frac{1}{n} \sum_{l=1}^n \phi(x_l)$ 替换为 $\hat\mu$ 并找到了一个合理的结果，但在数字上我无法复制以前的结果。然而，有趣的是，结果是相关的，相关参数为 $0.85$（当我在模拟中使用较少数量的样本时，相关参数甚至更高）。
我的两个资源：
http://dx.doi.org/10.1016/j.patcog .2006.07.009（第6页）
https://doi.org/10.1007/s11634-010-0068-1 （第 160 页）]]></description>
      <guid>https://stats.stackexchange.com/questions/635198/calculating-the-orthogonal-distance-to-kernel-pca-subspace-with-a-new-data</guid>
      <pubDate>Mon, 18 Dec 2023 16:12:50 GMT</pubDate>
    </item>
    <item>
      <title>从具有任意权重的多个基础分布中分析估计联合 Von Mises 分布参数</title>
      <link>https://stats.stackexchange.com/questions/635197/analytically-estimate-joint-von-mises-distribution-parameters-from-multiple-unde</link>
      <description><![CDATA[给定一组 n 一维（圆形）Von Mises 分布，可以对每个分布进行随机采样（使用不同的权重 w，应用于每个分布）分布）并估计单个联合分布的参数 mu 和 k。
使用r包circular可以直接实现这一点。然而，对于我的实时 Java 实现，随机采样和最大似然估计步骤的计算成本很高。
是否可以分析计算此联合分布的参数 mu 和 k？对于我的应用程序，可以进行一些简化的近似，以提供接近但不相同的结果。
库（循环）

## 生成圆形对象的辅助函数，角度范围为 0-360
circularDeg &lt;- 函数(x) 圆形(x,template = “地理”,units = “度”, modulo = “2pi”)
theta &lt;-circularDeg(seq(从 = 0, 到 = 360,by = 1))

m1 &lt;- 圆度(180)
k1 &lt;- 2.1
w1 &lt;- 1.5
dvm1 &lt;- dvonmises(theta,mu = m1, kappa = k1)

m2 &lt;- 圆形度(270)
k2 &lt;- 1.4
w2 &lt;- 1.7
dvm2 &lt;- dvonmises(theta,mu = m2, kappa = k2)

m3 &lt;- 圆形度(135)
k3 &lt;- 0.7
w3 &lt;- 7.2
dvm3 &lt;- dvonmises(theta,mu = m3, kappa = k3)

## 基于从每个带有权重的分布中随机抽取的联合分布进行采样
关节 &lt;- mle.vonmises(c(rvonmises(ceiling(100000 * w1), m1,k1),
                        rvonmises(天花板(100000 * w2), m2,k2),
                        rvonmises(天花板(100000 * w3), m3,k3)))
dvmJoint &lt;- dvonmises(theta,joint$mu, joint$kappa)



注意一点：在研究潜在的解决方案时，我发现了 GeorgeWQ 对另一个 Von Mises 相关问题的回答：“Cue Combination on the Circle and the Sphere”和“利用冯米塞斯分布混合的仅方位跟踪”。两者的作者都实施了一种数学方法来组合两个分布。
但是，用于计算 kappa 的近似值产生的联合分布与使用最大似然估计估计的值相比具有非常不同的离散度，并且在 kappa 比率不等于 1 的情况下，估计均值也会发散。此外，在应用两个以上分布的情况下，它们组合的顺序对结果有显着影响

&lt;小时/&gt;
##（绘制代码）
情节_ly（）|&gt;
  add_lines(x = theta, y = dvm1, name = Past0(&quot;分布 1: m = &quot;,m1,&quot;, k = &quot;,k1,&quot;, 权重 = &quot;,w1),
            line = list(color = &quot;steelblue&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvm2, name = Paste0(&quot;分布 2: m = &quot;,m2,&quot;, k = &quot;,k2,&quot;, 权重 = &quot;,w2),
            line = list(color = &quot;seagreen&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvm3, name = Past0(&quot;分布 3: m = &quot;,m3,&quot;, k = &quot;,k3,&quot;, 权重 = &quot;,w3),
            line = list(color = &quot;indianred&quot;, dash = &quot;dot&quot;)) |&gt;;
  add_lines(x = theta, y = dvmJoint, name = Paste0(&quot;关节: m = &quot;,round(joint$mu,2),&quot;, k = &quot;,round(joint$kappa,3)),
            行=列表（颜色=“黑色”，宽度=2））|&gt;
  布局（xaxis =列表（范围= c（0,360），dtick = 45），
         图例 = 列表(x = 0.5, y = 1.05, xanchor = “中心”, yanchor = “底部”))
]]></description>
      <guid>https://stats.stackexchange.com/questions/635197/analytically-estimate-joint-von-mises-distribution-parameters-from-multiple-unde</guid>
      <pubDate>Mon, 18 Dec 2023 15:40:10 GMT</pubDate>
    </item>
    </channel>
</rss>