<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Tue, 01 Oct 2024 01:22:11 GMT</lastBuildDate>
    <item>
      <title>ARMA(2,2) 的无限移动平均表示</title>
      <link>https://stats.stackexchange.com/questions/655143/infinity-moving-average-representation-of-an-arma2-2</link>
      <description><![CDATA[我正在尝试编写以下 ARMA(2,2) 过程的无限移动平均表示
$$Y_t = 1.1 Y_{t-1} - 0.8Y_{t-2} - 1.7\epsilon_{t-1} + 0.72\epsilon_t,$$
其中 $\epsilon_t \sim WN(0, \sigma^2)$.
我已经验证这是一个因果过程，这意味着它可以用无限移动平均表示。但是，在使用系数之间的关系时，我得到了一个无法以封闭形式表达的递归定律：
$$\psi_k = 1.1 \psi_{k-1} - 0.8 \psi_{k-2}, \hspace{0.15cm} k \geq 3.$$
如果有人能帮助我或提供如何进行的提示，我将不胜感激！
此外，我想提一下，特征多项式中没有公共根（自回归多项式中的虚根），因此无法通过分解项将该过程简化为低阶 ARMA 模型，例如 ARMA(1,1)。]]></description>
      <guid>https://stats.stackexchange.com/questions/655143/infinity-moving-average-representation-of-an-arma2-2</guid>
      <pubDate>Tue, 01 Oct 2024 01:21:24 GMT</pubDate>
    </item>
    <item>
      <title>区分两个高斯</title>
      <link>https://stats.stackexchange.com/questions/655142/distinguishing-two-gaussians</link>
      <description><![CDATA[假设我们有两个高斯$N_0 = \mathcal{N}(0, \Sigma_0)$和$N_1 = \mathcal{N}(0,\Sigma_1)$，其中$\Sigma_0$和$\Sigma_1$是两个$n\times n$协方差矩阵。
区分它们的最佳检验方法是什么？如果 $\Sigma_0$ 和 $\Sigma_1$ 都是可逆的，我知道似然比检验有效，即
$$X^T (\Sigma_0^{-1} - \Sigma_1^{-1})X$$
具有最小检验误差。
如果 $\Sigma_0$ 或 $\Sigma_1$ 退化了怎么办？作为一个猜测，我觉得
$$X^T (\Sigma_0^{\dagger} - \Sigma_1^{\dagger})X$$
可能有效，其中 $\dagger$ 表示 Moore–Penrose 逆。
我的问题是，这是真的吗？在哪里可以找到区分高斯分布的良好参考资料？]]></description>
      <guid>https://stats.stackexchange.com/questions/655142/distinguishing-two-gaussians</guid>
      <pubDate>Tue, 01 Oct 2024 00:16:21 GMT</pubDate>
    </item>
    <item>
      <title>在存在相关协变量的情况下，基于系数的假设检验与基于似然比的假设检验？</title>
      <link>https://stats.stackexchange.com/questions/655140/hypothesis-test-based-on-coefficient-vs-based-on-likelihood-ratio-in-the-presen</link>
      <description><![CDATA[我有来自准实验的时间序列数据（条件：基线与干预，以 ABAB 模式分块应用），但由于情况控制不佳，我还观察到一些与可能的混淆相对应的协变量。协变量之间以及与操纵之间都有相关性。
我为此建立了一个线性模型，如果您愿意的话，可以使用单向 2 级 ANCOVA，只是可能的误差自相关性被建模为 AR(1)。 （在 R 中使用 gls 来自 nlme）
让我感到困惑的是 p 值在 0 之间有所不同

对条件虚拟回归量与 0 的系数进行检验，$p = 0.0019$ 来自 $t(70) = 3.235616$，并且
对有和没有回归量的模型进行似然比检验，$p = 0.0002$ 来自 $F(1, 70) = 15.1067$。

（使用 summary 和anova）
我理解这两个检验的工作原理不同：一个基于完整模型中的系数估计及其标准误差，而另一个则比较完整模型和简化模型所解释的方差。我相信，如果没有协变量（与条件相关），两者应该是等价的（$F = t^2$），但如果有相关的协变量，完整模型中的条件回归量会拾取方差，而在某种程度上，简化模型中的协变量也可以拾取该方差。
但我仍然感到困惑，因为两个检验似乎都有相同的零假设（“条件无影响”）。差异是统计能力的问题吗？
更重要的是，不同的p值使得其中一个低于传统显着性水平而另一个不低于。如果是，我应该使用哪一个来声明“条件的统计显著影响”？
此外，是否可以概括地说明两个 p 值中哪一个会（随机地）较小？
除了直接回答外，我还希望得到文献指针或相关搜索关键字。]]></description>
      <guid>https://stats.stackexchange.com/questions/655140/hypothesis-test-based-on-coefficient-vs-based-on-likelihood-ratio-in-the-presen</guid>
      <pubDate>Mon, 30 Sep 2024 21:55:14 GMT</pubDate>
    </item>
    <item>
      <title>预测模型的观察期选择[关闭]</title>
      <link>https://stats.stackexchange.com/questions/655138/selection-of-observation-period-for-predictive-model</link>
      <description><![CDATA[如果事件发生率在最近2-3年内持续增加且不稳定，如何选择观察期]]></description>
      <guid>https://stats.stackexchange.com/questions/655138/selection-of-observation-period-for-predictive-model</guid>
      <pubDate>Mon, 30 Sep 2024 21:04:48 GMT</pubDate>
    </item>
    <item>
      <title>时间序列分析 ACF 和平稳性帮助</title>
      <link>https://stats.stackexchange.com/questions/655135/time-series-analysis-acf-and-stationarity-help</link>
      <description><![CDATA[基本上这是我第一次将 TS 分析应用于真实数据集。ACF 和 PACF 图不如假设设置中那么好。我需要帮助来解释结果。
我正在分析具有明显 7 天和 30 天季节性的销售数据。
通过增强迪基-福勒 (ADF) 检验，TS 是非平稳的。
一阶差分通过增强迪基-福勒 (ADF) 检验消除了非平稳性。 （p 值 ~ e-10）
但是，我的一阶差分 TS 的 ACF 和 PACF 图显示出明显的季节性趋势。
滞后=40：ACF：https://ibb.co/B66wSCm PACF：https://ibb.co/dMbty3W
滞后=100：（滞后=100 后 ACF 仍然非常显著）ACF：https://ibb.co/xYVxzvJ PACF：https://ibb.co/1ZHKxP7
更有趣的是，当我应用 7 阶差分时，我得到了这个：ACF：https://ibb.co/4g2SwM2 PACF：https://ibb.co/mzmV5Nn
我得到 TS 中的季节性成分，SARIMA 模型更合适。我想根据 ACF 和 PACF 手动找到 p 和 q。有关更多分析（图表和背景），请参阅我的代码：https://www.kaggle.com/code/bigsmallmediumpotato/time-series-analysis-store-sales]]></description>
      <guid>https://stats.stackexchange.com/questions/655135/time-series-analysis-acf-and-stationarity-help</guid>
      <pubDate>Mon, 30 Sep 2024 20:21:01 GMT</pubDate>
    </item>
    <item>
      <title>如何避免似然优化中的负方差估计？</title>
      <link>https://stats.stackexchange.com/questions/655131/how-to-prevent-negative-variance-estimates-in-likelihood-optimization</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/655131/how-to-prevent-negative-variance-estimates-in-likelihood-optimization</guid>
      <pubDate>Mon, 30 Sep 2024 18:49:28 GMT</pubDate>
    </item>
    <item>
      <title>使用 R 中的生存分析评估事件趋势率变化的统计意义</title>
      <link>https://stats.stackexchange.com/questions/655128/assessing-for-statistical-significance-of-change-in-trend-rate-of-events-with-su</link>
      <description><![CDATA[我有数据用于检查不同样本个体在特定程序之后发生事件的日期。我预计在程序执行后的 X 天内，我的事件发生率将会增加，然后在 X 天后恢复到基线。我在此测试中的目标是查看整个数据集的趋势是否发生了总体变化。
我计划使用统一速率进行 Kolmogorov-Smirnov 检验。我尝试在 R 中执行此操作，但收到一条错误消息，提示“Kolmogorov-Smirnov 检验不应存在平局。”我的数据存在联系，因为多个人可能在同一术后当天发生该事件。
这是我的数据和方法的示例。
day_of_event &lt;- c(1,2,4,4,5,6,12,16,16,17,19,21)

ks.test(day_of_event, &quot;punif&quot;, min = 0, max = 21)

渐近单样本 Kolmogorov-Smirnov 检验

数据：天数
D = 0.31429，p 值 = 0.1033
备选假设：双侧

警告消息：
在 ks.test.default(days, &quot;punif&quot;, min = 0, max = 21) 中：
Kolmogorov-Smirnov 不应存在联系测试

是否有其他方法可以进行此分析？
(如何测试事件发生率的变化？) 之前的帖子建议计算到达间隔时间，但我不确定这种方法是否有效，原因有两个。在这种情况下，到达间隔时间是无意义的值，并且不解决联系问题。]]></description>
      <guid>https://stats.stackexchange.com/questions/655128/assessing-for-statistical-significance-of-change-in-trend-rate-of-events-with-su</guid>
      <pubDate>Mon, 30 Sep 2024 18:37:54 GMT</pubDate>
    </item>
    <item>
      <title>使用 R 对生存分析中事件发生率变化进行显著性检验</title>
      <link>https://stats.stackexchange.com/questions/655132/significance-testing-for-a-change-in-rate-of-events-in-survival-analysis-with-r</link>
      <description><![CDATA[我有数据用于检查不同样本个体在特定程序后发生事件的概率。我预计在程序执行后的 X 天内，我的事件发生率将会增加，然后在 X 天后恢复到基线。我在此测试中的目标是查看趋势是否发生了总体变化。
我想进行具有统一概率的 Kolmogorov-Smirnov 检验。我尝试在 R 中执行此操作，但收到一条错误消息，提示“Kolmogorov-Smirnov 检验不应存在平局。”我的数据存在联系，因为多个人可能在同一术后当天发生该事件。
这是我的数据和方法的示例。
days &lt;- c(1,2,4,4,5,6,12,16,16,17,19,21)
ks.test(days, &quot;punif&quot;, min = 0, max = 21)

渐近单样本 Kolmogorov-Smirnov 检验

数据：days
D = 0.31429，p 值 = 0.1033
备选假设：双侧

警告消息：
在 ks.test.default(days, &quot;punif&quot;, min = 0, max = 21) 中：
Kolmogorov-Smirnov 不应存在联系测试
]]></description>
      <guid>https://stats.stackexchange.com/questions/655132/significance-testing-for-a-change-in-rate-of-events-in-survival-analysis-with-r</guid>
      <pubDate>Mon, 30 Sep 2024 17:37:05 GMT</pubDate>
    </item>
    <item>
      <title>对于无界实值数据，应使用哪种评级者间信度指标</title>
      <link>https://stats.stackexchange.com/questions/655119/what-kind-of-inter-rater-reliability-metric-to-use-for-unbounded-real-valued-da</link>
      <description><![CDATA[我正在分析两位注释者对各种产品的货币价值（以美元计）进行注释的评分者间信度。为此，他们的任务是在线查找每种产品的货币价值。因此，该量表是实值且正向无界的。两位注释者都注释了所有项目。我得出结论，为此使用皮尔逊相关性，但我不完全确定此指标是否适用，或者是否有任何其他更适用的指标。​​我找不到明确的答案。]]></description>
      <guid>https://stats.stackexchange.com/questions/655119/what-kind-of-inter-rater-reliability-metric-to-use-for-unbounded-real-valued-da</guid>
      <pubDate>Mon, 30 Sep 2024 15:22:13 GMT</pubDate>
    </item>
    <item>
      <title>相互作用是 lme4 与 nlme 之间的主要影响因素</title>
      <link>https://stats.stackexchange.com/questions/655111/interaction-as-main-effect-in-lme4-vs-nlme</link>
      <description><![CDATA[假设我想看看不同类型的汽车（例如吉普车、SUV、卡车、跑车）之间是否存在速度差异。我还想看看汽车商店（A、B、C、D、E）是否对此有影响。我对汽车商店没有具体的假设，但我假设某些商店倾向于销售某些类型的汽车（例如，商店 A 销售 SUV，商店 B 销售卡车）。
因此，我尝试使用 lme4 和 nlme 拟合线性混合效应模型。
我对这两个模型之间的区别有疑问：
nlme：
m1 &lt;- lme(speed ~ car_type + car_store + car_type:car_store, 
data = data1, random = ~ 1 | car_owner, method = &quot;ML&quot;)

lme4 等价于：
m2 &lt;- lmer(speed ~ car_type * car_store + (1 | car_owner), 
data = data1, REML = FALSE)

现在，我的问题是，我是否可以像这样将交互作为 nlme 中的主效应：
m3 &lt;- lme(speed ~ car_type + car_type:car_store, data = data1, 
random = ~ 1 | car_owner, method = &quot;ML&quot;)

到目前为止，我在 lme4 中找不到与 m3 等效的函数。有人能帮我理解原因吗？
此外，理想情况下，我认为我可以使用 m3 实现我的目的。但是我还应该考虑其他什么吗？比如，也许最好也使用 lme4 和 car_store 作为主要/固定效果？]]></description>
      <guid>https://stats.stackexchange.com/questions/655111/interaction-as-main-effect-in-lme4-vs-nlme</guid>
      <pubDate>Mon, 30 Sep 2024 12:51:11 GMT</pubDate>
    </item>
    <item>
      <title>如何运行统计测试来逐行寻找三种不同表型中特定基因的过度富集？</title>
      <link>https://stats.stackexchange.com/questions/655109/how-to-run-a-statistical-test-to-look-for-over-enrichment-of-specific-genes-acr</link>
      <description><![CDATA[
这是我的 contingency_table:
基因组表型1表型2表型3
基因组1 2 4 26
基因组2 0 0 1
基因组3 2 6 4
基因组4 1 0 0
基因组5 0 0 2
基因组6 0 0 1
基因组7 0 0 1
基因组8 0 1 1
基因组9 3 0 6
基因组10 0 0 1

我想识别出在一个表型上显著富集于其他两个单独表型的基因组。
为此，我想看看每个基因组中的表型分布是否与其余 ST 组中的分布有显著不同。然后我想看看表型 1 或表型 3 是否与特定 ST 组相关。
我认为我需要以逐行方式运行 Fisher 精确检验，对每个基因组使用 3x2 矩阵，对吗？对于每个基因组，我想为 p 值添加一个新列。那么，我是否需要为多重检验校正的 p 值添加一个额外的列，也许可以使用 Bonferroni 校正？
当我说 3x2 矩阵时，我认为每个基因组的数据都可以用 3x2 矩阵格式表示，其中：

列：代表三种表型类别（表型 1、表型 2、表型 3）
行：两行代表正在测试的基因组的计数和其余基因组的计数。

为此，我尝试了以下方法：
# 加载库
library(dplyr)

# 创建列联表作为数据框
contingency_table &lt;- data.frame(
Gene_group = c(&quot;Gene_group1&quot;, &quot;Gene_group2&quot;, &quot;Gene_group3&quot;, &quot;Gene_group4&quot;, &quot;Gene_group5&quot;, &quot;Gene_group6&quot;, &quot;Gene_group7&quot;, &quot;Gene_group8&quot;, &quot;Gene_group9&quot;, &quot;Gene_group10&quot;),
phenotype1 = c(2, 0, 2, 1, 0, 0, 0, 0, 3, 0),
phenotype2 = c(4, 0, 6, 0, 0, 0, 0, 1, 0, 0),
phenotype3 = c(26, 1, 4, 0, 2, 1, 1, 1, 6, 1)
)

# 为每个基因组运行 Fisher 精确检验的函数
run_fisher_test &lt;- function(gene_group_row, total_counts) {
# 提取当前基因组
current_counts &lt;- as.numeric(gene_group_row[2:4])

# 剩余组的计数
remaining_counts &lt;- colSums(total_counts[-which(total_counts$Gene_group == gene_group_row$Gene_group), 2:4])

# 创建列联表
contingency_matrix &lt;- rbind(current_counts, remaining_counts)

# 运行 Fisher 精确检验
test_result &lt;- fisher.test(contingency_matrix)

return(test_result$p.value)
}

# 将函数应用于列联表的每一行
contingency_table &lt;- contingency_table %&gt;%
rowwise() %&gt;%
mutate(p_value = run_fisher_test(cur_data(), contingency_table)) %&gt;%
ungroup() # 按行操作后取消分组

# 测试总数
num_tests &lt;- nrow(contingency_table)

# 使用 Bonferroni 校正调整 p 值
contingency_table &lt;- contingency_table %&gt;%
mutate(adjusted_p_value = p.adjust(p_value, method = &quot;bonferroni&quot;)) %&gt;%
mutate(bonferroni_significance = 0.05 / num_tests) # 计算 Bonferroni 显著性水平

# 查看结果
print(contingency_table)

结果如下所示：

所有这些听起来都是正确的方法吗？
然后，我还想运行 2 x 2 Fishers 精确检验来查看在表型 1 或表型 3 中显著富集的基因组，将 p 值和多重检验校正的 p 值添加到每个基因组的附加列中。
我是 R 编码新手，所以任何建议都会非常有帮助。]]></description>
      <guid>https://stats.stackexchange.com/questions/655109/how-to-run-a-statistical-test-to-look-for-over-enrichment-of-specific-genes-acr</guid>
      <pubDate>Mon, 30 Sep 2024 11:15:36 GMT</pubDate>
    </item>
    <item>
      <title>样本均值和贝塔回归系数之间有协方差吗？</title>
      <link>https://stats.stackexchange.com/questions/655101/is-there-covariance-between-the-sample-mean-and-beta-regression-coefficients</link>
      <description><![CDATA[在线性回归中，样本均值和 beta 回归估计值之间是否存在协方差？
例如模型如下：
$$ y_i = \beta_0 + \beta_1 x_i + \epsilon_i $$
在此设置中，$\bar{y}$ 是因变量的样本均值，$\bar{x}$ 是自变量的样本均值。
我想要找出答案：
$$ Cov(\bar{y}, \hat{\beta_1})$$
我首先写了 OLS 估计：
$$ \hat{\beta_1} = \frac{\sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n (x_i - \bar{x})^2} $$
然后我以 $y_i$ 的形式写下 $\bar{y}$：
$$ \bar{y} = \frac{1}{n} \sum_{i=1}^n y_i $$
把所有东西放在一起：
$$ Cov(\bar{y}, \hat{\beta_1}) = E[(\bar{y} - E[\bar{y}])(\hat{\beta_1} - E[\hat{\beta_1}])] $$
然后代入公式：
$$ Cov(\bar{y}, \hat{\beta_1}) = E\left[\left(\frac{1}{n} \sum_{i=1}^n y_i - E[\bar{y}]\right)\left(\frac{\sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n (x_i - \bar{x})^2} - E[\hat{\beta_1}]\right)\right] $$
但我不确定如何从这里继续。
我认为协方差确实存在（即非零），因为$\bar{y}$ 具有来自样本的不确定性，而$\hat{\beta_1}$ 具有来自样本的不确定性……但我不确定回归理论是否表示它们之间的协方差基本上为 0，或者在大样本下期望值约为 0，或者实际上非零。
我应该如何进行？

模拟（应 Henry 的要求）：
library(ggplot2)

set.seed(123)

n_sims &lt;- 10000

simulate_and_fit &lt;- function(n = 100) {
x &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- 2 + 3 * x + rnorm(n, 平均值 = 0, sd = 1)
模型 &lt;- lm(y ~ x)
return(c(x_bar = 平均值(x), beta1_hat = coef(model)[2]))
}

结果 &lt;- 复制(n_sims, mock_and_fit())
results_df &lt;- data.frame(x_bar = results[1,], beta1_hat = results[2,])

相关性 &lt;- cor(results_df$x_bar, results_df$beta1_hat)

ggplot(results_df, aes(x = x_bar, y = beta1_hat)) +
geom_point(alpha = 0.5) +
geom_smooth(method = &quot;lm&quot;, color = &quot;red&quot;) +
labs(title = &quot;x-bar 和 beta1-hat 之间的关系&quot;,
x = &quot;x-bar&quot;,
y = &quot;beta1-hat&quot;) +
annotate(&quot;text&quot;, x = min(results_df$x_bar), y = max(results_df$beta1_hat), 
label = paste(&quot;相关性：&quot;, round(correlation, 4)), 
hjust = 0, vjust = 1) +
theme_minimal()


看起来没有相关性 - 但我们如何从数学上证明这一点？]]></description>
      <guid>https://stats.stackexchange.com/questions/655101/is-there-covariance-between-the-sample-mean-and-beta-regression-coefficients</guid>
      <pubDate>Mon, 30 Sep 2024 05:36:49 GMT</pubDate>
    </item>
    <item>
      <title>在线性混合效应模型中，随机效应的估计条件模式是否遵循 MVN？</title>
      <link>https://stats.stackexchange.com/questions/655058/do-estimated-conditional-modes-of-random-effects-follow-a-mvn-in-a-linear-mixed</link>
      <description><![CDATA[在教程 GLMM 示例 中提供的 示例中，线性混合效应模型与苔原生态系统的数据（来自 Belshe et al., 2013）拟合，具有以下规范：
cmod_lmer &lt;- lmer(GS.NEE ~ cYear + (1+cYear|Site),
data=mc2B, REML=TRUE,
weights=n)

本教程后面会提出以下建议：

您可以使用 qqmath() 代替 dotplot() 来获取 条件模式的 Q-Q 图。 [强调添加]

我理解，随机效应，无条件和有条件（给定观察到的响应）具有多元正态分布（请参阅为什么假设随机效应遵循正态分布，或这些幻灯片中的第 3.4 节，第 173 页，作者：Dimitris Rizopoulos）。
我从上面提到的建议中推断出，模型中随机效应的条件模式（或均值）的估计值应遵循多元正态（MVN）分布，因此，我们应该检查如果 qqmath(ranef(...)) 确实如此。但是，在线性混合效应模型的公式化中，从未明确假设随机效应的条件模式应具有多元正态分布，对吗？那么使用估计值的 Q-Q 图背后的动机是什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/655058/do-estimated-conditional-modes-of-random-effects-follow-a-mvn-in-a-linear-mixed</guid>
      <pubDate>Sat, 28 Sep 2024 20:52:25 GMT</pubDate>
    </item>
    <item>
      <title>如何操作 nlme 模型中的交叉和嵌套随机效应</title>
      <link>https://stats.stackexchange.com/questions/655051/how-to-manipulate-crossed-and-nested-random-effects-in-nlme-model</link>
      <description><![CDATA[我看过一些关于此问题的旧帖子，但我真的很挣扎。我正在拟合营养数据，我认为我的数据太大，无法发布，我尝试对数据进行子采样，以便在此处发布一个可行的示例，但当我减少数据时，模型无法运行。我正在使用这个威布尔函数，因为我通过 drm 分析确定它最适合我的数据。它看起来像这样：

数据包括 4 个地点 3 年内 4 棵树生长季节时间序列中不同树种/品种（不同点形状）的叶子中的营养浓度。在考虑随机效应并将模型移至 nlme 以解释它们时，我遇到了挑战。我认为应该将年份视为交叉随机效应，因为我在所有年份都使用了相同的站点/树。树应该嵌套在每个站点中，因为每个站点都采样了相同的 4 棵树（但每个站点的树都不同）。我知道设置交叉和嵌套的随机因素很有挑战性，我已经阅读了关于此问题的六篇帖子。从这个模型开始，我得到了嵌套在站点中的树的随机效应结果，结果是合理的，但我知道年份很重要：
m1 &lt;- nlme(
Nutrient ~ W1.4_function(Time, b, c, d, e), # 使用预定义的 W1.4 函数
data = data,
fixed = b + c + d + e ~ 1, # 所有参数的固定效应
random = b + c + e ~ 1 | Site/Tree, # 嵌套在站点中的树
start = start_values, # 使用优化的起始值
control = nlmeControl(msMaxIter = 200, opt = &quot;nlm&quot;) 
)

我不希望对威布尔参数 d 产生随机效应。当我像这样构建随机效应时，AIC 从 130 降至 -90：
m2 = nlme(
Nutrient ~ W1.4_function(Time, b, c, d, e), # 使用 W1.4 函数进行建模
data = data,
fixed = b + c + d + e ~ 1, # 所有参数的固定效应
random = list(Year = pdIdent(b + c + e ~ 1), # 年份作为交叉随机效应
Site = pdDiag(b + c + e ~ 1), # 
Tree = pdDiag(b + c + e ~ 1)), # 嵌套在站点内的树
start = start_values, # 使用优化的起始值
control = nlmeControl(msMaxIter = 200, opt = &quot;nlm&quot;) # 增加最大迭代次数

)
现在组是：
组数：
年份 站点 %in% 年份
3 12
树 %in% 站点 %in% 年份
32

现在看来，我有年份作为交叉效应，但也有嵌套在年份中的站点和嵌套在年份中的站点中的树。我并没有打算在年份中嵌套站点或树。我知道我需要使用 pdBlocked 和 pdDiag 来以某种方式获得交叉和嵌套的随机效应？我最好转向 lme4 方法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655051/how-to-manipulate-crossed-and-nested-random-effects-in-nlme-model</guid>
      <pubDate>Fri, 27 Sep 2024 23:32:32 GMT</pubDate>
    </item>
    <item>
      <title>brms 中的 Priors 并未按我预期的那样工作</title>
      <link>https://stats.stackexchange.com/questions/655043/priors-in-brms-are-not-working-as-i-expect</link>
      <description><![CDATA[我是贝叶斯统计的新手，我正在尝试使用 brms 拟合一个简单的线性回归并手动设置每个参数的先验，但它并没有像我预期的那样工作
这是我的代码
data_2 &lt;- structure(list(YearsExperience = c(1.1, 1.3, 1.5, 2, 2.2, 2.9, 3, 3.2, 3.2, 3.7, 3.9, 4, 4, 4.1, 4.5, 4.9, 5.1, 5.3, 5.9, 6, 
6.8, 7.1, 7.9, 8.2, 8.7, 9, 9.5, 9.6, 10.3, 10.5), Salary = c(39343L, 
46205L, 37731L, 43525L, 39891L, 56642L, 60150L, 54445L, 64445L, 
57189L, 63218L, 55794L, 56957L, 57081L, 61111L, 67938L, 66029L, 
83088L, 81363L, 93940L, 91738L, 98273L, 101302L, 113812L, 109431L, 
105582L, 116969L, 112635L, 122391L, 121872L)), class = &quot;data.frame&quot;, row.names = c(NA, 
-30L))

priors &lt;- c(
set_prior(&quot;normal(28700, 2000)&quot;, class = &quot;Intercept&quot;),
set_prior(&quot;normal(9006, 1000)&quot;, class = &quot;b&quot;, 
coef = &quot;YearsExperience&quot;),
set_prior(&quot;normal(0, 2000)&quot;, class = &quot;sigma&quot;, lb = 0) 
)

fit_brms &lt;- brm(Salary ~ YearsExperience, data = data_2, Prior=priors)

但是，当我绘制链时，例如，当先验分布远离负值时进行截距。而且我设置的先验并非完全不准确。

如果我使用默认先验进行拟合，效果很好。]]></description>
      <guid>https://stats.stackexchange.com/questions/655043/priors-in-brms-are-not-working-as-i-expect</guid>
      <pubDate>Fri, 27 Sep 2024 21:16:13 GMT</pubDate>
    </item>
    </channel>
</rss>