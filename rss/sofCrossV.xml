<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Sat, 25 May 2024 15:14:43 GMT</lastBuildDate>
    <item>
      <title>我可以在本研究中使用双向方差分析吗？</title>
      <link>https://stats.stackexchange.com/questions/647964/can-i-use-a-two-way-anova-for-this-study</link>
      <description><![CDATA[标记测试，观察处于 3 种镜子条件（无镜子、镜子或玻璃）和 2 种标记条件（有标记或无标记）的动物。因变量是执行镜像定向行为的频率 - 这在技术上是离散的，但 Laerd 统计数据告诉我，我只能对连续因变量使用 2 路方差分析？我还想用什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/647964/can-i-use-a-two-way-anova-for-this-study</guid>
      <pubDate>Sat, 25 May 2024 14:49:19 GMT</pubDate>
    </item>
    <item>
      <title>如何在 R 中分段进行 GAM？</title>
      <link>https://stats.stackexchange.com/questions/647963/how-can-i-do-gam-piecewise-in-r</link>
      <description><![CDATA[我有一些数据 $(x_i,y_i)_{i=1}^N$，它在 xy 平面上看起来像一条 S 形曲线。有点像这样：

我认为我的数据是同方差正态分布的。

我的数据的方差比这个图大得多，但在 $xy$ 平面上的总体形状相差不大。我认为对于解释变量（$x$）的中间值，使用三次样条函数的 GAM 是合适的。
事实上，在实验中，我知道对于 $x$ 的较小值和较大值，$y$ 是常数。所以我想在非常量区域使用三次样条函数，在常数区域使用常数样条函数 $y(x) = \overline{x}$。
我有在 R 中使用 mgcv 拟合 qubic spline-GAM 的经验。

我可以在 R 中使用 GAM 对解释变量的不同区域使用不同次数的样条函数吗？如果可以，我该怎么做？如果不可能，那么在 R 中拟合这些数据最合理的方法是什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/647963/how-can-i-do-gam-piecewise-in-r</guid>
      <pubDate>Sat, 25 May 2024 14:03:45 GMT</pubDate>
    </item>
    <item>
      <title>观察性前后设计和混杂因素调整</title>
      <link>https://stats.stackexchange.com/questions/647962/observational-pre-post-design-and-confounder-adjustment</link>
      <description><![CDATA[我有基线观察数据和二元治疗的两个后续测量数据。因变量是问卷量表分数***。我计划拟合一个线性混合效应模型，其中受试者为随机效应，治疗 x 时间相互作用，基线为协变量，允许使用样条函数（即 ANCOVA 类型模型）进行非线性拟合。我的问题是：

假设样本量足够，是否建议拟合其他协变量来调整混杂因素？我不确定基线协变量本身是否足以做到这一点？如果答案是肯定的，那么这是否包括随时间变化的协变量以及随时间依赖的协变量？

除上述内容外，是否还建议将倾向得分拟合为协变量（可能是样条曲线）？


*** 我知道尺度得分是序数尺度，但我认为首先尝试线性混合模型并检查残差分布是否适当正态是合理的。]]></description>
      <guid>https://stats.stackexchange.com/questions/647962/observational-pre-post-design-and-confounder-adjustment</guid>
      <pubDate>Sat, 25 May 2024 13:59:39 GMT</pubDate>
    </item>
    <item>
      <title>预测已知曲线的模拟数据</title>
      <link>https://stats.stackexchange.com/questions/647960/predicting-simulated-data-for-a-known-curve</link>
      <description><![CDATA[我在研究问题上遇到了障碍，确实需要利用您的专业知识。
我有一条通过推断已知拟合实验数据创建的预先存在的曲线。如下所示，x 轴是给予样品的热量，y 轴是热量与响应的响应概率。

我有另一个数据集，我必须估计其衰减函数。对于样品“i”，总热量定义为
H_{i} = H_{0}exp^{-kt} + H_{已知} {1}
其中 H_{0}、t 和 H_{known} 是已知项。 “k”是指是未知术语
从等式 1 生成的 H_{i} 及其所有样本的已知二元响应然后进行分箱以获得 H 和响应概率。
下面，我展示了一个示例图，其中绿点作为新数据，并带有随机选取的“k”点。价值。绿色模拟数据

我的问题是未知“k”的估计在公式 1 中，它最小化了绿点和蓝色曲线之间的差异。
有人可以建议一种理想的方法来估计“k”]]></description>
      <guid>https://stats.stackexchange.com/questions/647960/predicting-simulated-data-for-a-known-curve</guid>
      <pubDate>Sat, 25 May 2024 13:34:44 GMT</pubDate>
    </item>
    <item>
      <title>机器学习到底有啥“技巧”？</title>
      <link>https://stats.stackexchange.com/questions/647957/what-are-the-tricks-in-machine-learning</link>
      <description><![CDATA[我遇到了一些不同的“技巧”机器学习方法论，我在下面列出了这些方法以及我的基本理解。

内核技巧：
这用于支持向量机 (SVM) 和其他算法（例如核岭回归），使它们能够在高维空间中运行，而无需显式计算该空间中数据的坐标。它涉及使用核函数来计算高维空间中数据点的点积，从而使算法能够找到非线性决策边界。

Gumbel-Softmax 技巧：
这是一种用于通过可微分运算来近似分类样本的技术，使基于梯度的优化方法能够处理离散随机变量。这种方法在离散潜变量模型的神经网络中特别有用，因为它允许通过离散选择进行反向传播。通过向 logits 引入 Gumbel 噪声并应用 softmax 函数，该方法可以生成连续、可微的分类分布近似值，从而促进涉及离散变量的模型的高效训练。

重新参数化技巧：
该技术主要用于变分自动编码器（VAE），也可以应用于涉及随机过程的其他算法，例如一些生成对抗网络（GAN）。它通过将随机变量重新表示为带有添加噪声项的确定性变量，从而实现通过随机变量的反向传播。这使得梯度下降优化可以有效地应用于将概率元素纳入模型潜在变量或参数的模型，从而促进高效稳定的训练。

Log-Sum-Exp 技巧：这用于稳定指数和的对数的计算，这在计算 softmax 函数或对数概率中很常见。它有助于通过重新制定计算来避免数值上溢和下溢。


我注意到 Log-Sum-Exp 和 Kernel Trick 在 CV 上都有自己的标签。
我对两件事很好奇。首先，这些方法到底是什么让它们成为“伎俩”的？ ？是什么让他们变得“棘手”？ ？英语不是我的母语，所以也许（可能）这里使用这个术语有一些我不明白的微妙之处。我的基本理解是这些“方法”是其实就是方法，我不太明白为什么它们被称为“技巧”。
查阅英语词典，我找到了可能的答案：“一种聪明的或特殊的做某事的方式”。我想这有一定道理。是这样吗？
我对这个解释的疑问是：肯定还有数百种其他方法也是解决顽固问题的非常聪明的方法。是什么让这些“伎俩”成为现实？特别？
我的第二个问题是，机器学习中经常使用哪些其他技巧，这些技巧被称为“技巧”？在机器学习社区。]]></description>
      <guid>https://stats.stackexchange.com/questions/647957/what-are-the-tricks-in-machine-learning</guid>
      <pubDate>Sat, 25 May 2024 13:07:19 GMT</pubDate>
    </item>
    <item>
      <title>学习《统计学家的实函数分析》的参考资料</title>
      <link>https://stats.stackexchange.com/questions/647956/references-to-learn-real-and-functional-analysis-for-statisticians</link>
      <description><![CDATA[我正在寻找一本能够提供实分析元素的书，用于数理统计和计量经济学理论等。
我计划使用以下 3 本高级统计理论教科书：

概率基础，作者：Jacod 和 Protter
理论统计：核心课程主题，作者：Keener Robert
数学统计 作者：Jun Shao

但是它们非常注重实分析，尽管它们都提供了测量理论概率的介绍，所以我只是缺乏实分析来开始。我有经济学背景（欧洲 LMD 系统的许可证 3），所以即使我学过一些微积分、线性代数、初等概率和统计学，我也绝不是数学家，而且我不认为我是数学家。一个“基于证明”的数学家。
我做了一些研究，找到了这些书：

经济理论和计量经济学的数学分析简介，作者：Corbae、Stinchcombe 和 Zeman。
实际分析与经济应用作者：A. Efe
高级经济学微积分
和金融：理论与方法，作者：Giulio Bottazzi

但我认为最好请一些权威人士确定一下，不要浪费时间在对我来说太沉重或对君少类型的书来说不完整的东西上。
你们中的一些人有一些适合经济学家、工程师等自学实分析的好参考吗？
谢谢你，并对我糟糕的英语感到抱歉。]]></description>
      <guid>https://stats.stackexchange.com/questions/647956/references-to-learn-real-and-functional-analysis-for-statisticians</guid>
      <pubDate>Sat, 25 May 2024 13:05:16 GMT</pubDate>
    </item>
    <item>
      <title>概率下限</title>
      <link>https://stats.stackexchange.com/questions/647955/probability-lower-bounds</link>
      <description><![CDATA[我们有三个事件$A, B, C.$
此外，我们还有，$$\mathcal{P}(A\cap B\cap C)=\mathcal{P}(A)-\mathcal{P}(A\cap(\overline{B}\cup \overline{C})).$$
从上面的结果如何证明$$\mathcal{P}(A)-\mathcal{P}(A\cap(\overline{B}\cup \overline{C}))\geq \mathcal{P}(A)-\mathcal{P}(A\cap \overline{B})-\mathcal{P}(A\cap \overline{C})?$$]]></description>
      <guid>https://stats.stackexchange.com/questions/647955/probability-lower-bounds</guid>
      <pubDate>Sat, 25 May 2024 12:54:07 GMT</pubDate>
    </item>
    <item>
      <title>为单个人运行测试</title>
      <link>https://stats.stackexchange.com/questions/647954/runs-test-for-a-single-individual</link>
      <description><![CDATA[我理解无法推广到总体的问题，但在这种情况下，我感兴趣的是数据是否表明单个个体表现的随机性。具体来说，我正在尝试评估狗的肢体偏侧性。如果我假设，真正的偏侧化将表现为在操纵物体时肢体使用缺乏随机性，我可以对单个动物的 R/L 肢体使用使用运行测试吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/647954/runs-test-for-a-single-individual</guid>
      <pubDate>Sat, 25 May 2024 12:30:46 GMT</pubDate>
    </item>
    <item>
      <title>R中的stR包中的严格周期性季节性</title>
      <link>https://stats.stackexchange.com/questions/647951/strictly-periodic-seasonality-in-str-package-in-r</link>
      <description><![CDATA[我正在进行分解练习，将每日用电量分解为每周、每年的季节性波动以及天气温度与正常温度的偏差。为此，我使用了 Documentov, Hyndman (2015) 论文中最近开发的一个很好的“stR”包。问题是我需要设置严格的季节性波动周期而不是灵活的周期：我的时间序列涵盖5年，不太可能观察到季节性波动的变化。因此，我受到外生变量（温度波动）的偏差影响，因为季节项的变化与它们相关。我怎样才能解决这个问题，并将季节性的严格周期性设置为来自寓言/盛宴包的STL中的“周期性”选项？
不幸的是，我无法在这里发布代码和数据，因为它处于 NDA 之下。]]></description>
      <guid>https://stats.stackexchange.com/questions/647951/strictly-periodic-seasonality-in-str-package-in-r</guid>
      <pubDate>Sat, 25 May 2024 10:29:12 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 convLSTM2D 对可变输入形状进行训练？</title>
      <link>https://stats.stackexchange.com/questions/647949/how-to-train-with-convlstm2d-on-variable-input-shape</link>
      <description><![CDATA[我正在使用 4 过滤器对 72x72 图像的时间序列进行分类（就像 RGB）。如果我的所有样本都具有相同的时间步长（或纪元数），那么事情就会很好地进行。然而，实际上我每个样本都有不同数量的时间步长。 （这是天文学中的，我无法随意获取数据。）但是当我尝试包含不同的时间步长时，我收到错误。请查看 MWC。
&lt;前&gt;&lt;代码&gt;N=2000
train_data_arr=np.random.rand(N, 11, 72, 72, 4)
train_label=np.repeat(np.random.randint(2,size=N)[:, np.newaxis], 11,axis=1)
Ntot,dum=train_label.shape;打印(Ntot,dum)

#===可变数据形状====
def select_random_time_epochs(数据、标签、max_time_steps=11):
    变量数据 = []
    变量标签 = []
    对于 zip（数据，标签）中的 d、l：
        #时间步数 = 11
        time_steps = np.random.randint(1, max_time_steps + 1)
        variable_data.append(d[:time_steps])
        variable_labels.append(l[:time_steps])
    返回变量数据、变量标签
train_data_var, train_label_var = select_random_time_epochs(train_data_arr, train_label)

#====数据生成器======
def make_generator（数据，标签）：
    def 生成器():
        对于 zip（数据，标签）中的 d、l：
            产量 d, l
    返回发电机

train_ds = tf.data.Dataset.from_generator(
    生成器=make_generator(train_data_var, train_label_var),
    输出类型=（tf.float32，tf.int32），
    output_shapes=(tf.TensorShape([无, 72, 72, 4]), tf.TensorShape([无]))
）
批量大小 = 32
train_ds = train_ds.batch(batch_size)

#===型号===
输入形状 = (无, 72, 72, 4)  
模型 = tf.keras.Sequential()
model.add(输入(形状=input_shape))
model.add(ConvLSTM2D(32, (9, 9), 激活=&#39;relu&#39;, padding=&#39;valid&#39;, return_sequences=True, data_format=&#39;channels_last&#39;))
model.add(BatchNormalization())
model.add(TimeDistributed(MaxPooling2D((2, 2), data_format=&#39;channels_last&#39;)))
model.add(TimeDistributed(Flatten()))
model.add(TimeDistributed(Dense(64,activation=&#39;relu&#39;)))
model.add(TimeDistributed(Dense(1,activation=&#39;sigmoid&#39;)))
model.compile(optimizer=&#39;adam&#39;,loss=&#39;binary_crossentropy&#39;,metrics=[&#39;accuracy&#39;])
模型.summary()

model.fit(train_ds, epochs=20)

如果我将时间步长固定为 11（在函数 select_random_time_epochs() 中），则一切正常。但是当我使用可变数量的时间步长时，我收到错误：
无法对组件 0 中具有不同形状的张量进行批处理。第一个元素的形状为 [3,72,72,4]，元素 3 的形状为 [6,72,72,4]。

我知道它无法处理 32 个批次内的可变时间步长。实际上，当我设置 batch_size = 1 时，上面的代码可以工作，但这需要太多时间，而且很可能永远不会融合到真实的用例场景中。
所以我的问题如下。

假设我完全不需要任何填充。当批次内的样本具有不同形状时，是否有更快的方法来实现 model.fit() ？否则，我可以动态批处理具有相同时间步长的样本吗？这是唯一的方法吗？评估可能不遵循同一批次分布的测试数据时会出现问题吗？

现在来到 padding 选项：tensorflow.keras.layers.Masking 是否真的能够处理我在缺失时期放置的“坏图像” ？换句话说，Masking 或其他东西可以完全使填充值变得无关吗？


重要的一点：我必须使用生成器来避免立即在 GPU 上加载数据，因为我的实际数据很大（字面意思是天文数字）。
另外，以下线程讨论了 LSTM 的变量输入，但我的用例稍微复杂一些。
https://stackoverflow.com/questions/63663399/how -处理lstm的可变长度数据
https://stackoverflow.com /questions/38189070/how-do-i-create-a-variable-length-input-lstm-in-keras]]></description>
      <guid>https://stats.stackexchange.com/questions/647949/how-to-train-with-convlstm2d-on-variable-input-shape</guid>
      <pubDate>Sat, 25 May 2024 08:54:08 GMT</pubDate>
    </item>
    <item>
      <title>书籍：Rice 还是 Casella、Berger？</title>
      <link>https://stats.stackexchange.com/questions/647948/books-rice-or-casella-berger</link>
      <description><![CDATA[我对您更喜欢哪个以及出于什么（主观和客观）原因感兴趣：
Rice（数学、统计和数据分析）或 Casella、Berger（统计推断）？
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/647948/books-rice-or-casella-berger</guid>
      <pubDate>Sat, 25 May 2024 08:53:30 GMT</pubDate>
    </item>
    <item>
      <title>如何估计很小比例的置信区间？</title>
      <link>https://stats.stackexchange.com/questions/647947/how-to-estimate-the-confidence-interval-of-a-very-small-proportion</link>
      <description><![CDATA[我想估计很小比例的置信区间。假设我有 1000 人的简单随机样本，有 4 个人回答了“是”这个问题。人们可能想利用正态性假设并使用基本公式计算置信区间
CI ± z * sqrt(p^ * (1-p^)/n))
然而，要使这一点成立，通常会施加 n * p ≥ 5 且 n * (1-p) ≥ 5 的限制，在本例中违反了这一限制。
因此，我的问题是：如果我想说：“在 95% 的置信度下，回答“是”的人数比例小于 x%”。我如何找到x？]]></description>
      <guid>https://stats.stackexchange.com/questions/647947/how-to-estimate-the-confidence-interval-of-a-very-small-proportion</guid>
      <pubDate>Sat, 25 May 2024 08:51:01 GMT</pubDate>
    </item>
    <item>
      <title>特定人群的生存函数</title>
      <link>https://stats.stackexchange.com/questions/647931/survival-function-for-a-certain-population</link>
      <description><![CDATA[如果某个群体的生存函数由 $$ s(x) = \left( \frac{1}{1+x} \right)^4 $ 给出$ 对于 $x \ge 0$，您预计 $41$ 的人会持续多久能活多少岁？
(a) $14$ 年
(b) $18.5$ 年
(c) $20$ 年
(d) $40$ 年
(e) $42$ 年
我的尝试如下：
$$E\left[X&gt;41\right]=\int _{41}^{\infty }\frac{x}{\left(1+x\right)^ 4}\:dx=\frac{31}{111132}$$
这似乎不正确，请提供任何形式的帮助，谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/647931/survival-function-for-a-certain-population</guid>
      <pubDate>Fri, 24 May 2024 23:11:54 GMT</pubDate>
    </item>
    <item>
      <title>在建模逆关系（曝光〜结果）时，如何在 dagitty/ggdag 中正确指定“曝光”和“结果”？</title>
      <link>https://stats.stackexchange.com/questions/647952/how-to-correctly-specify-exposure-and-outcome-in-dagitty-ggdag-when-modelli</link>
      <description><![CDATA[我正在尝试使用 R 中的包 ggdag 来更好地理解我的建模结果。
如果我希望对响应 ~ 事件关系进行建模，我可以轻松找到要控制的变量：
库(ggdag)

达格化（
  响应〜事件+混杂因素，
  事件〜混淆者，
  曝光=c(“事件”)，
  结果 = c(“响应”)
) |&gt; ggdag_调整_设置()


但是，如果我现在有兴趣建模相反的关系，即事件〜响应（例如，预测给定响应的事件的概率），我收到一条警告，指出无法关闭后门路径：
dagify(
  响应〜事件+混杂因素，
  事件〜混淆者，
  暴露=c(“响应”)，
  结果 = c(“事件”)
) |&gt; ggdag_调整_设置()
#&gt; dag_adjustment_sets(.,exposure=exposure,outcome=outcome,：关闭后门路径失败。常见原因包括：
#&gt;             * 图不是无环的
#&gt;             * 后门路径无法使用给定的变量集关闭
#&gt;             * 必要的变量是未测量的（潜在的）


同样的情况也发生在更简单的 DAG 中：
dagify(
  响应〜事件，
  暴露=c(“响应”)，
  结果 = c(“事件”)
) |&gt; ggdag_调整_设置()

在我看来，由于因果关系的方向是事件 -&gt;响应 我要求的路径（响应 -&gt; 事件）被 ggdag 解释为后门路径，因此出现警告。
由于我的实际模型比这些简单的示例复杂得多，我仍然想从 ggdag 获取调整集。
DAG 的正确规范是什么？如果人们只是离开“曝光”？和“结果”和第一种情况一样，即使是反向建模？]]></description>
      <guid>https://stats.stackexchange.com/questions/647952/how-to-correctly-specify-exposure-and-outcome-in-dagitty-ggdag-when-modelli</guid>
      <pubDate>Fri, 24 May 2024 16:04:00 GMT</pubDate>
    </item>
    <item>
      <title>为什么在该随机效应方差分析中估计的总体方差与估计的 $\sigma^2 + \tau^2$ 不同？</title>
      <link>https://stats.stackexchange.com/questions/647826/why-estimated-population-variance-differs-from-estimated-sigma2-tau2-in</link>
      <description><![CDATA[随机效应方差分析模型通常写为
$Y_{ij} = \gamma_{00} + u_{0j} + \epsilon_{ij}$
。结果变量的总方差分解为
$var(Y_{ij}) = \tau^2 + \sigma^2$
其中$\tau^2$表示$u_{0j}$和&lt;的方差span class=&quot;math-container&quot;&gt;$\sigma^2$ $\epsilon_{ij}$ 的方差。
我有一些代码可以创建 $\sigma^2$ 和 $\tau^2$ 的估计值span&gt; 来自人工数据。
然后我运行一个空的多级模型，可以看到 $\sigma^2$ 和 $\ 的估计值tau^2$ 与 lme4 给我的结果完全匹配。
但是，当我将估计总体方差计算为
estimated_population_variance &lt;- var(my_data$y) * (N-1)/N

它不等于$\sigma^2 + \tau^2$。为什么不？ $\sigma^2 + \tau^2$ 不就是总方差的分解吗？
我认为这一定与我估计总体方差的方式有关，但我不确定我做错了什么。
代码：
库(lme4)

设置.种子(123) 
组 &lt;- 代表（1:10，每组 = 10）
random_numbers &lt;- 样本（1:99，长度（组），替换 = TRUE）
my_list &lt;- 列表(group = groups, y = random_numbers)
my_data &lt;- as.data.frame(my_list)

N &lt;- 100
组数 &lt;- 10
平均组大小 &lt;- 10

table_of_groups &lt;- my_data %&gt;%
  group_by(组) %&gt;%
  总结（均值 = 均值（y），方差 = var（y），n = n（））

s2within &lt;- 均值(table_of_groups$variance)
估计_sigma2 &lt;- s2within

s2之间 &lt;- sum((table_of_groups$mean-mean(my_data$y))^2) * (1/(num_groups-1))
estimated_tau2 &lt;- s2 Between - (s2within/average_group_size)

empty_model &lt;- lmer(“y ~ 1 + (1 | group)”, data = my_data) 
摘要（空模型）

估计总体方差 &lt;- var(my_data$y) * (N-1)/N

估计_tau2 + 估计_sigma2
]]></description>
      <guid>https://stats.stackexchange.com/questions/647826/why-estimated-population-variance-differs-from-estimated-sigma2-tau2-in</guid>
      <pubDate>Thu, 23 May 2024 13:55:02 GMT</pubDate>
    </item>
    </channel>
</rss>