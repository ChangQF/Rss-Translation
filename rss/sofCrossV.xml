<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Fri, 17 May 2024 15:15:22 GMT</lastBuildDate>
    <item>
      <title>导出平稳 AR(2) 过程自相关函数的替代方法</title>
      <link>https://stats.stackexchange.com/questions/647432/alternative-method-to-deriving-autocorrelation-function-of-stationary-ar2-proc</link>
      <description><![CDATA[我已阅读此问题/答案：
平稳 AR(2) 过程的自相关
我们如何使用期望得出这个结果。
令 $Y_t = \phi_0 +\phi_1 Y_{t-1} + \phi_2 Y_{t-2}+\epsilon_t$
我找到了平均值：
$\mu = E(Y_t)= \phi_1 E(Y_{t-1})+\phi_2E(Y_{t-2})$&lt; /p&gt;
然后使用这个属性：
$cov[Y_t, Y_{t-2}] = E[(Y_t-\mu)(Y_{t-2}-\mu)]$
我们如何使用它来导出链接中的内容？
$cov[Y_t, Y_{t-2}] = E[(Y_t-\phi_1 E(Y_{t-1})+\phi_2E(Y_{t- 2}))(Y_{t-2}-\phi_1 E(Y_{t-1})+\phi_2E(Y_{t-2}))]$
我被困在这里了。
我怎样才能做到这一点 -
$$
\开始{对齐}
= \phi_{1}\ \rho_{k-1} + \phi_{2}\ \rho_{k-2}\\
\结束{对齐}
$$]]></description>
      <guid>https://stats.stackexchange.com/questions/647432/alternative-method-to-deriving-autocorrelation-function-of-stationary-ar2-proc</guid>
      <pubDate>Fri, 17 May 2024 14:55:34 GMT</pubDate>
    </item>
    <item>
      <title>为什么我的 DNN 回归模型的预测区间是水平线？</title>
      <link>https://stats.stackexchange.com/questions/647429/why-are-the-prediction-intervals-for-my-dnn-regression-model-horizontal-lines</link>
      <description><![CDATA[我正在致力于开发深度强化学习的预测区间。因此，我按照此处给出的说明进行操作。我运行了一个小示例，使用简单的深度学习模型来开发预测区间。但是，我看到预测是水平线。
按照链接中的说明，我通过强制神经网络输出均值和方差来开发概率模型 -
 defforward(self, x)：
        平均值 = self.mean(x)
        var = self.var(x)
        返回 self.selu(mean), torch.exp(var)

然后，我从网络采样——
# 重复mean和var num_samples次
平均值 = 平均值.重复(num_samples, num_samples)
var = var.repeat(num_samples, num_samples)

# 来自预测分布的样本
样本 = 平均值 + torch.randn_like(mean) * torch.sqrt(var)

然后我取了它的分位数 -
lower_bound, upper_bound = torch.quantile(samples, torch.tensor([0.025, 0.975]), dim=1)


这是我的代码 -
导入火炬
将 torch.nn 导入为 nn
导入 torch.optim 作为 optim
将 matplotlib.pyplot 导入为 plt

# 检查GPU是否可用并相应地设置设备
device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)

# 定义数据集
x = torch.linspace(-1, 1, 100).view(100, 1).to(设备)
y = (3 * x + 1 + torch.randn(x.size()) * 0.2).to(设备)

# 定义模型
类 Net(nn.Module):
    def __init__(self, n_feature, n_output):
        超级().__init__()
        self.mean = nn.Linear(n_feature, n_output) # 均值的线性层
        self.var = nn.Linear(n_feature, n_output) # 方差的线性层
        self.selu = nn.SELU() # 添加非线性

    def 前向（自身，x）：
        平均值 = self.mean(x)
        var = self.var(x)
        返回 self.selu(mean), torch.exp(var)

# 创建一个Net实例并将其传输到设备
net = Net(n_feature=1, n_output=1).to(设备)

# 定义优化器
优化器 = optim.SGD(net.parameters(), lr=0.0001)

# 训练循环
对于范围（500000）内的 t：
    均值，var = net(x)
    损失 = torch.mean((y - 平均值)**2 / var + torch.log(var))
    优化器.zero_grad()
    loss.backward()
    优化器.step()

    如果 t%20==0:
        print(f&quot;Epoch {t} | 损失：{loss.item()}&quot;)

# 假设我们有一些测试数据
x_test = torch.linspace(-1, 1, 100).view(100, 1).to(设备)

# 获取预测均值和方差
均值，var = net(x_test)

# 用于预测区间和绘图的其余代码


样本数 = 100
# 假设我们有一些测试数据
x_test = torch.linspace(-1, 1, 100).view(100, 1)

# 获取预测均值和方差
均值，var = net(x_test)

# 重复mean和var num_samples次
平均值 = 平均值.重复(num_samples, num_samples)
var = var.repeat(num_samples, num_samples)

# 来自预测分布的样本
样本 = 平均值 + torch.randn_like(mean) * torch.sqrt(var)
# 转置样本，以便分别计算每个测试点的分位数
样本 = 样本.t()

# 计算预测区间
lower_bound, upper_bound = torch.quantile(samples, torch.tensor([0.025, 0.975]), dim=1)
x_lower_bound = []
x_upper_bound = []
# 打印预测区间
对于范围内的 i(len(x_test))：

    # print(f&quot;i = {i},x={x_test[i]} 的预测区间: [{lower_bound[i​​]}, {upper_bound[i​​]}]&quot;)
    print(f“i = {i} 的预测区间”)
    x_lower_bound.append(lower_bound[i​​].detach().numpy())
    x_upper_bound.append(upper_bound[i​​].detach().numpy())

plt.plot(x, y, label = &#39;真实值&#39;)
plt.plot(x, net(x)[0].detach().numpy(), label = &#39;预测&#39;)
plt.plot(x, x_lower_bound, label = &#39;下限&#39;)
plt.plot(x, x_upper_bound, label = &#39;上限&#39;)
plt.图例()
plt.show()

如下图所示，我的预测区间是水平线。有没有办法获得更紧的约束 -
]]></description>
      <guid>https://stats.stackexchange.com/questions/647429/why-are-the-prediction-intervals-for-my-dnn-regression-model-horizontal-lines</guid>
      <pubDate>Fri, 17 May 2024 14:39:13 GMT</pubDate>
    </item>
    <item>
      <title>无法将 genextreme 与我的数据相匹配[关闭]</title>
      <link>https://stats.stackexchange.com/questions/647425/cannot-fit-genextreme-with-my-data</link>
      <description><![CDATA[我尝试将一些代码从 MATLAB 移植到 python，但在使用 genextreme 时遇到了一些问题。由于 scipy 不支持分箱数据，因此我使用频率扩展了原始数据。我知道这不是最好的做法（我打开了这个）。问题是 Gumbel 和 Weibull 分布的拟合度为“mm”。据我了解，GEV 是 Gumbel 和 Weibull 的一般情况，但运行以下代码会导致：“矩量法遇到非有限分布矩，无法继续。”。有什么提示吗？
import numpy as np
import scipy.stats as stats

H = [15.25, 13.75, 12.75, 12.25, 11.75, 11.25, 10.75, 10.25, 9.75, 9.25, 8.75, 8.25, 7.75, 7.25, 6.75, 6.25, 5.75, 5.25,
4.75, 4.25, 3.75, 3.25, 2.75, 2.25, 1.75, 1.25, 0.75]

nrep = [1, 1, 1, 2, 5, 20, 17, 18, 37, 66, 112, 151, 215, 352, 525, 750, 1130, 1731, 2649, 4002, 6083, 9610, 14990,
21362, 26898, 26783, 13482]

expanded = np.repeat(H, nrep)

parameters = stats.genextreme.fit(expanded, method=&#39;mm&#39;)
]]></description>
      <guid>https://stats.stackexchange.com/questions/647425/cannot-fit-genextreme-with-my-data</guid>
      <pubDate>Fri, 17 May 2024 13:09:39 GMT</pubDate>
    </item>
    <item>
      <title>RCT中的多重插补方法</title>
      <link>https://stats.stackexchange.com/questions/647423/multiple-imputation-method-in-rct</link>
      <description><![CDATA[我们决定在 RCT 中使用多重插补法来解决一些后续缺失数据的问题（完全是出于随机原因）。我计划在 SPSS 中使用多重插补法，默认情况下会运行 5 次迭代。我的问题是：在这种情况下，这 5 次迭代是否足够？有人有这方面的经验吗？我以前从未这样做过，也不是很自信。
提前谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/647423/multiple-imputation-method-in-rct</guid>
      <pubDate>Fri, 17 May 2024 12:19:10 GMT</pubDate>
    </item>
    <item>
      <title>从高斯分布中获取的一式三份样本中观测值分布的分布</title>
      <link>https://stats.stackexchange.com/questions/647422/distribution-of-a-spread-of-observations-in-triplicate-sample-taken-from-gaussia</link>
      <description><![CDATA[假设从具有已知均值和 SD 的高斯分布中随机抽取一式三份样本。每个样本中 3 个可能的观测值对之间的最大绝对差应该是什么分布（一式三份的范围）？]]></description>
      <guid>https://stats.stackexchange.com/questions/647422/distribution-of-a-spread-of-observations-in-triplicate-sample-taken-from-gaussia</guid>
      <pubDate>Fri, 17 May 2024 11:25:49 GMT</pubDate>
    </item>
    <item>
      <title>我可以将中心极限定理的两个独立结果相加吗？</title>
      <link>https://stats.stackexchange.com/questions/647420/can-i-add-two-independent-results-from-the-central-limit-theorems</link>
      <description><![CDATA[我正在阅读 R. Hogg 等人撰写的数理统计简介。
我很难理解极限分布。
设 $X_1,\cdots,X_{n_1}$ 为来自 $Bernoulli(p_1)$ 的独立同分布随机变量 并让 $Y_1,\cdots,Y_{n_2}$ 为来自 $Bernoulli(p_2) 的 iid 随机变量）$。感兴趣的假设如下：
$$H_0: p_1=p_2\ \text{vs}.\ H_1: p_1\ne p_2.$$
根据中心极限定理，我认为我们可以有
$$\frac{\sqrt{n_i}(\hat{p}_i-p_i)}{\sqrt{p_i(1-p_i)}}\to Z_i\ \text{分布},\ i=1,2,$$
由于 $\hat{p_1}=(\sum_{i=1}^{n_1} x_i)/n_1$，那么它是独立随机变量的总和 (当然它有 $1/n$)。
假设$i=1,2$，为$n\to\infty,\ n_i/n\到 \lambda_i$，其中 $0&lt;\lambda_i&lt;1$ 和 $\lambda_1+\lambda_2=1 $。然后我想证明一下
$$\sqrt{n}[(\hat{p_1}-\hat{p_2})-(p_1-p_2)]\to N(0,\frac{1}{ \lambda_1}p_1(1-p_1)+\frac{1}{\lambda_2}p_2(1-p_2)).$$
我尝试过的
我认为我不能只从 CLT 中添加两个限制分布，因为该加法并不适用于分布收敛。
我也尝试用 CLT 来证明它，但我认为我不能使用它，因为 $\hat{p_1}-\hat{p_2}$ 不是总和尽管 $\hat{p_1}-\hat{p_2}=(\sum X_i)/{n_1} - (\sum Y_j)/{n_2}$ 是独立的。
你能解释一下如何证明分布收敛吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/647420/can-i-add-two-independent-results-from-the-central-limit-theorems</guid>
      <pubDate>Fri, 17 May 2024 11:11:46 GMT</pubDate>
    </item>
    <item>
      <title>两个骰子点数为 6 的概率为 1/36。这对于 $\alpha = .05$ 具有统计意义吗？</title>
      <link>https://stats.stackexchange.com/questions/647419/probability-of-two-dice-being-6-is-1-36-is-that-statistically-significant-for</link>
      <description><![CDATA[在一个样本 t 检验中，当样本均值过于极端时，我们称其具有统计显着性。
虽然这对骰子的例子不满足单样本 t 检验的假设，但我们可以说：

$P(\text{样本平均值} \geq 5) = \frac{4}{36}$
$P(\text{样本平均值} \geq 6) = \frac{1}{36}$

让我们设置$\alpha = .05$。
对于第一种情况，骰子似乎是公平的，因为获得如此极端的样本均值的可能性是 $\geq .05$。
对于第二种情况，我们是否应该说骰子不公平？
我一定错过了一些东西，因为这有点类似于在 21 面公平骰子中获得 21，这不应该直接表明骰子不公平。]]></description>
      <guid>https://stats.stackexchange.com/questions/647419/probability-of-two-dice-being-6-is-1-36-is-that-statistically-significant-for</guid>
      <pubDate>Fri, 17 May 2024 10:59:57 GMT</pubDate>
    </item>
    <item>
      <title>具有 BF 相关性的单尾贝叶斯相关假设，解释输出？</title>
      <link>https://stats.stackexchange.com/questions/647418/one-tailed-bayesian-correlation-hypothesis-with-bfcorrelation-interpretation-ou</link>
      <description><![CDATA[对于以下命令：
correlationBF(df$var1, df$var2, nullInterval = c(-1, 0))

我得到了结果输出
贝叶斯因子分析
--------------
[1]替代，r=0.333 -1＜rho＜0：96.40458±NA%
[2]替代，r=0.333!(-1＜rho＜0)：0.06047267±NA%

反对分母：
  空，rho = 0
---
贝叶斯因子类型：BFcorrelation、Jeffreys-beta*

我现在想要获得假设相关性  的 BF。 0. 起初我以为是 96.4，但我很困惑，因为备择假设的 BF 不应该是 1/96.4 而不是 0.06 吗？
或者我需要将两个结果相除，但为什么？
非常感谢任何帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/647418/one-tailed-bayesian-correlation-hypothesis-with-bfcorrelation-interpretation-ou</guid>
      <pubDate>Fri, 17 May 2024 10:23:46 GMT</pubDate>
    </item>
    <item>
      <title>相关数据的排名概率</title>
      <link>https://stats.stackexchange.com/questions/647414/rank-probabilities-for-dependent-data</link>
      <description><![CDATA[众所周知，对于 iid 样本 $X_1, \dots, X_T$ 排名概率在 $1 上是均匀的， \点，T$。换句话说，固定$1 \le i_0 \le T$，概率为$X_{i_0}$排名为 $k$（即 $X_{i_0} = X_{(k)}$）是 $1/n$。
我对这样的概率感兴趣，但对于非独立同分布随机变量的情况。即，令 $\hat{z}_1, \dots, \hat{z}_T$ 为估计的 GARCH 残差（它们显然是非独立同分布的）。我想绑定 $\mathcal{P}(\hat{z}_{i_0} = \hat{z}_{(k)})$ （理想情况下我正在寻找订单的界限 $1/T$)。
如果有任何有助于估计相关数据的排名概率的文献/提示，我将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/647414/rank-probabilities-for-dependent-data</guid>
      <pubDate>Fri, 17 May 2024 09:57:19 GMT</pubDate>
    </item>
    <item>
      <title>为什么 $\epsilon (X - X')$ 和 $(X - X')$ 具有完全相同的分布？</title>
      <link>https://stats.stackexchange.com/questions/647400/why-epsilon-x-x-and-x-x-have-exactly-the-same-distribution</link>
      <description><![CDATA[设 $\epsilon \in \{-1, 1\}$ 为 Rademacher 随机变量，
$X$ 是一个随机变量，$X&#39;$ 是 $X$。
为什么 $\epsilon (X - X&#39;)$ 和 $(X - X&#39;)$ 有相同的分布？
鉴于 $X-X&#39;$ 围绕 $0$ 对称，直观上这是正确的，但如何证明呢？]]></description>
      <guid>https://stats.stackexchange.com/questions/647400/why-epsilon-x-x-and-x-x-have-exactly-the-same-distribution</guid>
      <pubDate>Fri, 17 May 2024 05:35:50 GMT</pubDate>
    </item>
    <item>
      <title>使用 PyMC 中的新数据点对后验进行重新采样 [已迁移]</title>
      <link>https://stats.stackexchange.com/questions/647397/re-sampling-the-posterior-with-a-new-data-point-in-pymc</link>
      <description><![CDATA[我有一些数据
X = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
y = np.array([0, 1, 0, 1, 1])

我适合模特
以 pm.Model() 作为模型：
    X_shared = pm.Data(“X_data”, X)
    beta_0 = pm.Normal(“beta_0”, mu=0, sigma=1)
    beta_1 = pm.Normal(“beta_1”, mu=0, sigma=1)
    mu = beta_0 + beta_1 * X_shared
    p = pm.math.sigmoid(mu)
    y_obs = pm.Bernoulli(“y_obs”, p=p, 观察=y)
    跟踪 = pm.sample(100)

现在我想根据新的数据点重新采样后验
型号：
    pm.set_data({“X_data”: [1.69]})
    y_new_simulated = pm.sample_posterior_predictive(trace).posterior_predictive.y_obs
    y_new_obs_name = f“y_new_obs_1” # 为伯努利变量创建一个唯一的名称
    y_new_obs = pm.Bernoulli(y_new_obs_name, p=pm.math.sigmoid(beta_0 + beta_1 * 1.69), 观察=y_new.posterior_predictive.y_obs)
    new_trace = pm.sample(100)

但我收到广播错误：
ValueError：不允许运行时广播。

我的目标是尝试找出新数据点 X（并假装我们没有观察到 y 而必须模拟它）通过比较来添加信息旧痕迹和新痕迹]]></description>
      <guid>https://stats.stackexchange.com/questions/647397/re-sampling-the-posterior-with-a-new-data-point-in-pymc</guid>
      <pubDate>Fri, 17 May 2024 02:31:21 GMT</pubDate>
    </item>
    <item>
      <title>使用 R 中的 nls() 对非常嘈杂的数据进行非线性回归</title>
      <link>https://stats.stackexchange.com/questions/647394/non-linear-regression-with-very-noisy-data-with-nls-in-r</link>
      <description><![CDATA[我正在尝试将噪声数据拟合到具有两个我想估计的参数的特定模型。不幸的是，模型拟合很糟糕，噪声也增加了。我可以做些什么来改善这种契合度吗？
公式/模型如下所示：
model_form &lt;- as.formula(y ~ 1/((1/i)-(r*x)))
下面我创建了一些数据的示例。 噪声只是随机的附加噪声，也出现在我的真实数据集中（生物起源）。如果没有此噪音，nls() 拟合效果良好，最终估计 r 和 i 足够好。但随着噪声的增加，尽管热图中存在可见的模式，但模型拟合和参数估计很差。
使用示例参数 i 和 r 创建样本数据（这些参数实际上未知，但仅限于特定的已知区间）：
## 创建示例数据
my_i &lt;- 0.5 # i 参数示例
my_r &lt;- 100 # r 参数示例
d &lt;- data.frame(x=c(-rexp(500,rate=10),
                    seq(-1,0,length.out = 500))) %&gt;%
    突变（y=抖动（1/（（1/my_i）-（my_r * x）），1000））
噪声 &lt;- data.frame(x=runif(1000,-1,0),
                    y=runif(1000,0,0.5))
d &lt;-bind_rows(d,噪声)

以下函数使用上面的 model_form 将该数据拟合为 nls。
fitPlot &lt;- 函数（数据）{
    适合 &lt;- nls(model_form,数据,
               开始=列表(r=10,i=0.3))

    fit_r &lt;- 摘要(fit)$coefficients[&quot;r&quot;,1]
fit_i &lt;- 摘要(fit)$系数[“i”,1]

    预测 &lt;- data.frame(x=seq(-1,0,length.out=1000)) %&gt;%
        变异(y=1 / (1/fit_i - fit_r * x))

    p &lt;- ggplot(数据)+
        geom_bin2d(aes(x,y),bins=14)+
        geom_line(数据=预测,aes(x,y))+
        注释（“标签”，x=-0.7，y=0.5，
                 标签=paste0(“r:”,fit_r,”, i:”,fit_i))
    p
}

拟合图(d)


尽管随机添加了噪声，但函数生成的主要模式（靠近 0 和 x 轴）在热图中仍然可见。我希望模型能够很好地适应这个地方。
此时我能做些什么吗？我已经尝试过了

具有可能的 i 和 r 值的网格搜索 = 与 nls 相同的结果
optim具有不同的优化方法，具有最小化SS的功能
nlrob 来自使用不同方法的Robustbase

我在这一点上迷失了，不知何故必须有一种方法来创建一个强大的模型？不知何故，我需要减少对异常值的惩罚，但是怎么做呢？欢迎任何帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/647394/non-linear-regression-with-very-noisy-data-with-nls-in-r</guid>
      <pubDate>Thu, 16 May 2024 23:02:58 GMT</pubDate>
    </item>
    <item>
      <title>有向边是否可见？</title>
      <link>https://stats.stackexchange.com/questions/647364/is-the-directed-edge-visible</link>
      <description><![CDATA[
以上两个PAG（部分祖先图）都是在相同条件下使用FCI（快速因果推理）算法生成的，唯一的区别是右边的PAG是在从数据集中排除变量5后生成的。

有人可以帮我确定右侧 PAG 中 9 到 11 之间的有向边是否可见并解释一下此分析中涉及的步骤吗？
对于 9 和 11 可能存在不可测量的混杂因素，上述分析意味着什么？
正确的 PAG 是否表示 9 是 11 的父代或祖先？请解释一下。

谢谢
下面右侧 PAG 的特写：

下面左侧 PAG 的特写：
]]></description>
      <guid>https://stats.stackexchange.com/questions/647364/is-the-directed-edge-visible</guid>
      <pubDate>Thu, 16 May 2024 15:07:50 GMT</pubDate>
    </item>
    <item>
      <title>倾向评分匹配后的亚组分析</title>
      <link>https://stats.stackexchange.com/questions/647356/subgroup-analyses-after-propensity-score-matching</link>
      <description><![CDATA[假设倾向得分已经匹配群组。
倾向评分模型中包含的变量之一是性别。
主要cox模型研究两种药物缓解癌症的比较效果。
这是我一直在寻找的主要效果：
coxph(Surv(时间，状态) ~ 药物，数据 = 数据)

现在我想研究一种可能的调节（按性别）。
选项 1：
我可以使用上面的原始队列来调查可能的调节：
coxph(Surv(时间，状态) ~ 药物：性别，数据 = 数据)

因此，我有两个模型：一个用于主效应估计，一个用于调节。
选项 2：
根据格林＆amp; Stuart (2014)，估计单独的倾向评分模型可以显示出最佳的平衡。
因此，我创建了两个数据集（男性和女性）并分别计算了匹配的倾向得分。
接下来，我组合了两个匹配的数据集并计算：
coxph(Surv(时间，状态) ~ 药物：性别，数据 = 数据)

由于我使用卡尺进行 1:1 匹配，原始数据和组合分层方法确实具有不同的样本量，因为并非每个人都获得匹配的参考以及不同的匹配参考人。
问题：

对于选项 1，使用 drug:sex 计算主要效果 drug 的一个模型和可能直接调节的一个模型是否合法？或者我是否需要将两者作为 drug*sex 包含在一个模型中？

对于选项 2，我是否需要计算组合样本中的主效应？或者我是否使用组合数据只是为了调查调节并使用我的原始数据集来实现主要效果？
假设我想调查另一个按年龄类别（&lt;= 40 和 &gt; 40 岁）的调节。因此，我需要计算单独的倾向评分模型，将它们匹配并组合两个单独的数据集。但之前按性别分层的组合数据和按年龄类别分层的组合数据的主效应当然会有所不同。

一般来说，如何得出男性和女性的单独风险比和 CI？

]]></description>
      <guid>https://stats.stackexchange.com/questions/647356/subgroup-analyses-after-propensity-score-matching</guid>
      <pubDate>Thu, 16 May 2024 13:46:38 GMT</pubDate>
    </item>
    <item>
      <title>我可以限制偏最小二乘模型中的预测值吗？</title>
      <link>https://stats.stackexchange.com/questions/647424/can-i-restrict-the-predicted-values-in-partial-least-squares-model</link>
      <description><![CDATA[我正在使用 r-package pls，并且我想使用偏最小二乘法来创建数据预测。我使用的输入是土地覆盖百分比（裸土覆盖率-%，“土壤”）作为预测变量，其光谱作为响应变量（“列车”，我的整个数据的 70% 子集）。数据集的其余部分位于名为“test”的子集中。
“火车”的覆盖率始终在 0 到 100 之间，但预测有时会小于 0。
有没有办法预设模型，使其只能给出 0 到 100 之间的预测？
我的代码：
模型 &lt;- plsr(土壤 ~ ., 数据=训练, 比例=F, 验证=“CV”)
plsr_pred &lt;- 预测（模型，测试，ncomp=3）
我尝试深入研究该软件包的手册，但始终一无所获。]]></description>
      <guid>https://stats.stackexchange.com/questions/647424/can-i-restrict-the-predicted-values-in-partial-least-squares-model</guid>
      <pubDate>Thu, 16 May 2024 13:05:46 GMT</pubDate>
    </item>
    </channel>
</rss>