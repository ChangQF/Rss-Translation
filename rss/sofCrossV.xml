<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Fri, 03 Jan 2025 21:14:54 GMT</lastBuildDate>
    <item>
      <title>多变量柯西分布</title>
      <link>https://stats.stackexchange.com/questions/659506/multivariable-cauchy-distribution</link>
      <description><![CDATA[设$\mathbb{X}$为$\mathbb{R}^d$中的一个随机向量。如果其 PDF 可以描述为，则我们说 $\mathbb{X}$ 服从柯西分布（以 $\mathbf{0}\in \mathbb{R}^d$ 为中心），
$$ f_{\mathbb{X}}(\mathbf{x}) = \frac{\text{(constant)}}{\left( 1 + \mathbf{x}^t \Sigma^{-1} \mathbf{x}\right)^{(d+1)/2}}$$
对于某个正定矩阵 $\Sigma\in \mathbb{R}^{d\times d}$。
此分布有哪些应用？具体来说，当 $d&gt;1$ 时。
我知道柯西分布看起来很像正常分布，只是它有厚尾。但我更想知道为什么我们使用柯西分布的实际例子（而不是学术故事）。]]></description>
      <guid>https://stats.stackexchange.com/questions/659506/multivariable-cauchy-distribution</guid>
      <pubDate>Fri, 03 Jan 2025 19:57:13 GMT</pubDate>
    </item>
    <item>
      <title>伽马似然的共轭更新</title>
      <link>https://stats.stackexchange.com/questions/659505/conjugate-updating-of-gamma-likelihood</link>
      <description><![CDATA[我有严格为正的数据，并认为 Gamma 似然是适合该数据的合适选择。
作为起点，我想为数据集创建一个共轭贝叶斯分析，然后出于教育目的使用算法复制它，假设形状 (α) 和速率 (β) 都是未知的。我找到了 Miller (1980) 的论文，其中包含 Gamma 似然的共轭先验（也列在 https://en.wikipedia.org/wiki/Conjugate_prior 上），但我还不明白 α 矩的计算方式。
在他的论文中（此处）他在第 65 和 66 页指出，α 的边际后验与表达式 (5) 成正比，并且可以通过对该表达式进行数值积分轻松找到 α 的矩。不幸的是我不是数学家，所以有人能给我一些指导，告诉我如何用闭式表达式计算 α 的后验均值、方差等吗？他直接以方程的形式给出了 β 的近似值，但除了附录中的一些对我没有帮助的注释外，并没有对 α 做同样的处理。]]></description>
      <guid>https://stats.stackexchange.com/questions/659505/conjugate-updating-of-gamma-likelihood</guid>
      <pubDate>Fri, 03 Jan 2025 19:33:51 GMT</pubDate>
    </item>
    <item>
      <title>反事实分析中的可交换性诊断</title>
      <link>https://stats.stackexchange.com/questions/659504/diagnostics-for-exchangeability-in-counterfactual-analysis</link>
      <description><![CDATA[我的问题涉及反事实分析，即在替换一个或多个因素的每个级别后，使用模型来预测基础数据集中的每个观察值。下图来自 Stata 中 margins 命令文档中的一个示例（带有人工数据集），但使用了 R 中 emmeans 包中的新实现：
margex &lt;- haven::read_dta(&quot;https://www.stata-press.com/data/r18/margex.dta&quot;)
names(margex)[which(names(margex) == &quot;sex&quot;)] &lt;- &quot;male&quot;
margex.glm &lt;- glm(outcome ~ male * factor(group) + age, data = margex,
family = binomial)
require(emmeans)
emmeans(margex.glm, &quot;male&quot;, counterfactuals = &quot;male&quot;)
## 注意：由于涉及交互，结果可能会产生误导
## male prob SE df asymp.LCL asymp.UCL
## 0 0.160 0.0126 Inf 0.135 0.185
## 1 0.197 0.0100 Inf 0.177 0.216
## 
## 结果在以下水平上取平均值：actual_male 
## 使用的置信水平：0.95

创建于 2025-01-03，使用reprex v2.1.1
这里，感兴趣的因素是男性，它是主体是否为男性的指标。我们在整个数据集中替换男性 = 0（即假设每个人都是女性），并使用该模型预测结果；然后我们替换男性 = 1（每个人都是男性），并做同样的事情。男性预测正面结果的平均概率更高，我们可以继续测试这种差异。
这种方法的有效性需要可交换性的假设，这是技术性的，但在实际意义上，当我们用一个级别的男性替换另一个级别的时，我们说我们相信这个模型会做出正确的预测。但我们如何知道这个假设是站得住脚的？有一点让我警觉：上面的结果可以根据数据集中male的实际级别进行细分；如果我们这样做，结果如下：
ref_grid(margex.glm, counterfactuals = &quot;male&quot;) |&gt; confint()
## actual_male male prob SE df asymp.LCL asymp.UCL
## 0 0 0.0794 0.00621 Inf 0.0673 0.0916
## 1 0 0.2405 0.02000 Inf 0.2013 0.2796
## 0 1 0.1336 0.01270 Inf 0.1086 0.1585
## 1 1 0.2597 0.01050 Inf 0.2391 0.2802
## 
## 使用的置信水平：0.95

对于相同水平的male，数据集中实际男性和女性的预测之间存在巨大差异。此外，协变量 age 的均值在男性和女性之间有很大差异（分析未在此处显示，但很容易验证）。这让我想知道，通过切换 male 的值，预测是否是推断。
另一方面，直方图比较表明，女性和男性的年龄范围都很广泛，只是分布不同。这减轻了我对推断的担忧，让我更加相信模型能够正确预测事物。

无论如何，我的问题是：

是否有既定的诊断方法来检查反事实分析背后的假设是否站得住脚？

脚注

在撰写本文时，此代码仅在 emmeans 的开发版本上运行，可从 GitHub 安装。
Stata 数据集命名该指标sex 而不是 male。我将其重命名是因为统计学部分与良好的沟通有关。sex = 1 对应的性别并不明显，而 male = 1 对应的性别则很明显。
]]></description>
      <guid>https://stats.stackexchange.com/questions/659504/diagnostics-for-exchangeability-in-counterfactual-analysis</guid>
      <pubDate>Fri, 03 Jan 2025 19:00:22 GMT</pubDate>
    </item>
    <item>
      <title>处理一次膨胀计数数据而不是零膨胀计数数据</title>
      <link>https://stats.stackexchange.com/questions/659503/handling-one-inflated-count-data-instead-of-zero-inflated</link>
      <description><![CDATA[处理零膨胀数据时需要零膨胀模型和 Hurdle 模型，或者考虑到使用截断泊松或 NB 模型进行研究似乎更合适。但是，如果数据中不存在 0 计数，而是存在 1 的潜在膨胀，该如何处理？这是否与零膨胀类似，还是事件未在大量观察中发生（零膨胀）的情况是进行调整的具体原因？（也就是说，在建模计数方面，没有零的数据集中的一次膨胀与零膨胀数据集有何不同？）]]></description>
      <guid>https://stats.stackexchange.com/questions/659503/handling-one-inflated-count-data-instead-of-zero-inflated</guid>
      <pubDate>Fri, 03 Jan 2025 18:39:46 GMT</pubDate>
    </item>
    <item>
      <title>泊松回归模型是默认的吗？</title>
      <link>https://stats.stackexchange.com/questions/659502/is-the-poisson-regression-model-the-default</link>
      <description><![CDATA[泊松模型在研究中被广泛用于对计数数据进行建模，但是当存在过度分散时，就会使用其他模型（例如 NB、拟泊松）。如果不存在过度分散且变化与预期相等，您是否默认使用泊松回归模型，还是仍可以根据 gof 进行选择？]]></description>
      <guid>https://stats.stackexchange.com/questions/659502/is-the-poisson-regression-model-the-default</guid>
      <pubDate>Fri, 03 Jan 2025 18:38:33 GMT</pubDate>
    </item>
    <item>
      <title>glmmTMB 估计含义</title>
      <link>https://stats.stackexchange.com/questions/659499/glmmtmb-estimate-meanings</link>
      <description><![CDATA[我创建了一个广义线性混合模型，以查看疏伐对连通性的影响是否显著。我有 Period == Pre（疏伐前）和 Period == Post（疏伐后）和 Treatment == 疏伐（该地点已疏伐）和 Treatment == Control（该地点未疏伐）。基本上，这意味着我们有一个收获前时期，我们在此查看基线值，然后在发生疏伐之后的收获后值中，我想知道疏伐有什么影响。我使用子流域的随机效应来解释子流域之间的差异。我还进行了 emmeans 和成对比较，我发现在收获前后时期，对照处理有显著增加，但疏伐处理没有。这是否意味着稀疏化对连通性产生了负面影响？
以下是模型：
glmmTMB_model_gamma &lt;- glmmTMB(
Connectivity_Duration ~ Treatment * Period + (1 | Subwatershed),
family = Gamma(link = &quot;log&quot;), # Gamma
data = Connectivity_occurrences_no2018
) 

以下是结果：
Family: Gamma ( log )
公式：Connectivity_Duration ~ Treatment * Period + (1 | Subwatershed)
数据：Connectivity_occurrences_no2018

AIC BIC logLik 偏差 df.resid 
433.7 448.1 -210.8 421.7 76 

随机效应：

条件模型：
组名称 方差 标准差
子流域（截距） 0.3853 0.6207 
观察数：82，组：子流域，4

Gamma 系列的离散估计值（sigma^2）：2.82 

条件模型：
估计标准差误差 z 值 Pr(&gt;|z|) 
(截距) 3.5167 0.6986 5.034 4.81e-07 ***
TreatmentThinned -1.9785 0.9162 -2.160 0.03081 * 
PeriodPre -3.3751 0.6187 -5.455 4.89e-08 ***
TreatmentThinned:PeriodPre 3.0700 1.0089 3.043 0.00234 ** 
---
Signif。代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1```

# 获取相互作用的估计边际均值

em &lt;- emmeans(glmmTMB_model_gamma, ~ Treatment * Period)

# 对治疗前和治疗后的变薄组进行成对比较
contrast(em, method = &quot;pairwise&quot;, by = &quot;Treatment&quot;)
治疗 = 对照：
对比估计 SE df z.ratio p.value
治疗后 - 治疗前 3.375 0.619 Inf 5.455 &lt;.0001

治疗 = 变薄：
对比估计 SE df z.ratio p.value
治疗后 - 治疗前 0.305 0.797 Inf 0.383 0.7018

治疗期 emmean SE df asymp.LCL asymp.UCL
控制后 3.517 0.699 信息 2.147 4.89
稀疏后 1.538 0.593 信息 0.376 2.70
控制前 0.142 0.818 信息 -1.462 1.75
稀疏前 1.233 0.774 信息 -0.284 2.75
]]></description>
      <guid>https://stats.stackexchange.com/questions/659499/glmmtmb-estimate-meanings</guid>
      <pubDate>Fri, 03 Jan 2025 17:56:27 GMT</pubDate>
    </item>
    <item>
      <title>多状态模型：r Surv 函数</title>
      <link>https://stats.stackexchange.com/questions/659497/multi-state-models-r-surv-function</link>
      <description><![CDATA[我想在一个有 3 个阶段的模型中评估 Aalen-Johansen 估计量，该模型名为 1、2 和 3。可能的转换是 1-2、1-3、2-1 和 2-3。每个受试者都从第 1 阶段开始。
我的问题是，使用函数 Surv 然后使用 survfit，r 输出会创建一个初始状态 (s0)。许多受试者的轨迹是 1（初始阶段）-2-1-3。这意味着我丢失了这些信息，因为 r 认为轨迹是 (s0)-2-1-3。
我如何设置 (s0) = 1？我查看了文档，但没有找到如何设置。]]></description>
      <guid>https://stats.stackexchange.com/questions/659497/multi-state-models-r-surv-function</guid>
      <pubDate>Fri, 03 Jan 2025 17:47:25 GMT</pubDate>
    </item>
    <item>
      <title>如何在 R 中的 Cox 比例风险模型中提取控制臂的方差？</title>
      <link>https://stats.stackexchange.com/questions/659495/how-to-extract-the-variance-for-the-control-arm-in-a-cox-proportional-hazards-mo</link>
      <description><![CDATA[我正在使用 R 中的 coxph() 拟合 Cox 比例风险模型，该模型包含一个因子变量 treat，其中包括多个治疗组。具体来说，treatarm_1 是控制（参考）组，我还有其他治疗组：treatarm_2、treatarm_3 和 treatarm_4。
模型摘要提供了治疗组（treatarm_2、treatarm_3、treatarm_4）的系数、标准误差和方差，但我找不到对照组（treatarm_1）的方差，该组作为参考类别。
我理解对照组没有自己的系数，因为它隐式地表示在截距中。但是，我需要计算或提取对照组的方差，因为 BUGSnet 包（我用于网络荟萃分析）的文档指定我需要在多组试验中输入对照组的方差。
有人能解释一下我如何获得对照组的方差（如果可能的话），还是我假设它的方差为零？如果有其他方法，我将不胜感激任何建议！
提前谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/659495/how-to-extract-the-variance-for-the-control-arm-in-a-cox-proportional-hazards-mo</guid>
      <pubDate>Fri, 03 Jan 2025 16:37:02 GMT</pubDate>
    </item>
    <item>
      <title>Seber 和 Lee 的贝叶斯线性回归</title>
      <link>https://stats.stackexchange.com/questions/659492/bayesian-linear-regression-in-seber-and-lee</link>
      <description><![CDATA[我正在阅读 Seber 和 Lee 的《线性回归分析》（定理 3.7），贝叶斯线性回归中有些东西我不太理解。我们有以下模型：
$$\mathbf{Y} = \mathbf{X} \beta + \epsilon$$
其中 $\epsilon \sim \mathcal{N}(0, \sigma^2 I)$。
$\sigma^2$ 的先验为 $\text{Inverse Gamma} \left(\frac{d+2}{2}, \frac{a}{2}\right)$。给定 $\sigma^2$，$\beta$ 的先验为 $\mathcal{N}(\mathbf{m}, \sigma^2 \mathbf{V})$。然后后验与以下项成比例：
$$\left(\sigma^2\right)^{-(n + d + p + 2)/2} \exp\left(-\frac{1}{2\sigma^2} \left[ (\mathbf{y} - \mathbf{X} \beta)^\top (\mathbf{y} - \mathbf{X} \beta) + (\beta - \mathbf{m})^\top \mathbf{V}^{-1} (\beta - \mathbf{m}) + a \right] \right) =$$
$$\left(\sigma^2\right)^{-(n + d + p + 2)/2} \exp\left(-\frac{(Q+a)}{2\sigma^2} \right).$$
我们可以使用伽马积分对$\sigma^2$进行积分，这给出了$\beta$的后验，与$(Q+a)^{-(d+n+p)/2}$成比例。
通过一些代数运算，$Q$可以重写为
$$(\beta - \mathbf{m}^*)^\top \mathbf{V}_*^{-1} (\beta - \mathbf{m}^*)+\mathbf{y}^\top \mathbf{y} + \mathbf{m}^\top \mathbf{V}^{-1} \mathbf{m} - (\mathbf{m}^*)^\top \mathbf{V}_*^{-1} \mathbf{m}^*$$
最后：
$$(\beta - \mathbf{m}^*)^\top \mathbf{V}_*^{-1} (\beta - \mathbf{m}^*)+(\mathbf{y} - \mathbf{X}\mathbf{m})^\top (\mathbf{I} + \mathbf{X} \mathbf{V} \mathbf{X}^\top)^{-1} (\mathbf{y} - \mathbf{X}\mathbf{m}),$$
其中 $\mathbf{V}_* = (\mathbf{X}^T \mathbf{X} + \mathbf{V}^{-1})^{-1}$ 且 $\mathbf{m}^* = \mathbf{V}_* (\mathbf{X}^T\mathbf{y} + \mathbf{V}^{-1}\mathbf{m})$。
我的问题是，重写的目的是什么$\mathbf{y}^\top \mathbf{y} + \mathbf{m}^\top \mathbf{V}^{-1} \mathbf{m} - (\mathbf{m}^*)^\top \mathbf{V}_*^{-1} \mathbf{m}^*$ 等于 $(\mathbf{y} - \mathbf{X}\mathbf{m})^\top (\mathbf{I} + \mathbf{X} \mathbf{V} \mathbf{X}^\top)^{-1} (\mathbf{y} - \mathbf{X}\mathbf{m})$？我们能得到什么好处？我认为这与解释有关？]]></description>
      <guid>https://stats.stackexchange.com/questions/659492/bayesian-linear-regression-in-seber-and-lee</guid>
      <pubDate>Fri, 03 Jan 2025 14:42:23 GMT</pubDate>
    </item>
    <item>
      <title>我应该使用什么程序/函数来运行卷积神经网络，以根据生成模拟运动数据的参数来训练模拟运动数据</title>
      <link>https://stats.stackexchange.com/questions/659491/what-program-function-should-i-use-to-run-a-convolutional-nn-to-train-simulated</link>
      <description><![CDATA[我被文献淹没了，我看到的每个使用 Pytorch 或 TensorFlow 的示例问题都与我的不同。我在网格上有 N 个数据模拟 - 它们是纬度和经度的矩阵。数据本身是连续的，但我将它们分成网格上的方块。它们是由具有 M 个参数的运动模型生成的。我想根据相应的模拟数据集训练模拟每个数据集的参数。
如果 A_i 是矩阵，行作为纬度，列作为经度，值作为该网格方块内的出现次数，而 P_i 是保存生成每个 A_i 的参数的向量，我该如何以编程方式运行 CNN？目标是能够预测生成给定测试集的参数。
提前谢谢您。]]></description>
      <guid>https://stats.stackexchange.com/questions/659491/what-program-function-should-i-use-to-run-a-convolutional-nn-to-train-simulated</guid>
      <pubDate>Fri, 03 Jan 2025 14:38:27 GMT</pubDate>
    </item>
    <item>
      <title>BAM mgcv 算法的可重复性</title>
      <link>https://stats.stackexchange.com/questions/659490/reproducibility-of-bam-mgcv-algorithm</link>
      <description><![CDATA[我经常处理大型空间数据集，其中 mgcv 中实现的 bam() 算法非常适合。对于我的分析来说，点估计的可重复性是一个关键问题，不幸的是，我经常看到 BAM 预测的结果取决于所用数据集中数据点的顺序。
最小可重复示例
以下内容基于由协变量 x、y 和目标变量 z 组成的 15.000 个数据点的数据集，可在此处下载：https://drive.google.com/file/d/16dZ66KmT4CrQHkVQtw7vRP065SoztUNg/view?usp=drive_link
另请注意，在执行每个代码示例之前下面，数据集已重新加载并使用相同的随机种子进行了混洗。
首先考虑使用 bam() 拟合的结果：
set.seed(1)

model1 &lt;- mgcv::bam(z ~ s(x, y, k = 100),
data = dataset,
family = Gamma(link = log),
method = &quot;REML&quot;)

dataset &lt;- dataset[sample(nrow(dataset)),]

model2 &lt;- mgcv::bam(z ~ s(x, y, k = 100),
data = dataset,
family = Gamma(link = log),
method = &quot;REML&quot;)

#calculate response on scale of linear predictor
dataset$pred_model1 &lt;- as.vector(predict.gam(model1, dataset))
dataset$pred_model2 &lt;- as.vector(predict.gam(model2, dataset))
plot(dataset$pred_model1, dataset$pred_model2)

这将生成以下图表：

现在考虑 gam() 的结果：
model1 &lt;- mgcv::gam(z ~ s(x, y, k = 100),
data = dataset,
family = Gamma(link = log),
method = &quot;REML&quot;)

数据集 &lt;- 数据集[sample(nrow(数据集)),]

模型2 &lt;- mgcv::gam(z ~ s(x, y, k = 100),
数据 = 数据集,
family = Gamma(link = log),
method = &quot;REML&quot;)

#计算线性预测器尺度上的响应
数据集$pred_model1 &lt;- as.vector(predict.gam(model1, dataset))
数据集$pred_model2 &lt;- as.vector(predict.gam(model2, dataset))

plot(数据集$pred_model1, dataset$pred_model2)


这将生成以下图表：

所以我的问题是：这种行为是预料之中的，还是我这边的一个错误？如果这只是使用 bam() 时必须忍受的事情，那么除了始终确保数据点的顺序相同之外，还能做些什么来确保可重复性？
我已经通过尝试 k=1000 个基函数来测试它是否与有限的空间分辨率有关。在这里我发现了同样的问题。然而，我确实看到将数据集大小减少到只有 1000 个数据点可以大大减少问题。然而，这不是理想的解决方案，因为我想使用所有数据。]]></description>
      <guid>https://stats.stackexchange.com/questions/659490/reproducibility-of-bam-mgcv-algorithm</guid>
      <pubDate>Fri, 03 Jan 2025 13:43:22 GMT</pubDate>
    </item>
    <item>
      <title>为什么均匀分布产生的“白噪声”有时会具有自相关性？</title>
      <link>https://stats.stackexchange.com/questions/659486/why-is-white-noise-generated-from-uniform-distribution-sometimes-autocorrelate</link>
      <description><![CDATA[我试图理解不同时间序列模型的属性。要成为白噪声，$w_t$ 必须满足三个条件：

$E(w_t) = 0$，
$Var(w_t) = \sigma^2$，并且
$cov(w_t, w_s) = 0$，但它不必是正态分布的。如果是，它就称为高斯噪声。

在实践中，大多数情况下使用正态分布来模拟白噪声（至少从我在 R 或 python 中的不同实现中观察到的情况来看）。我开始想知道我是否可以使用任何其他具有零均值的分布，然后执行以下操作：
library(forecast)
set.seed(7)
white_noise2 = runif(200, min = -1, max = 1) # R 中均匀分布的随机样本
tsdisplay(white_noise2, plot.type = &quot;histogram&quot;, points = FALSE)


Box.test(white_noise2, lag = 10, type = &quot;Ljung-Box&quot;) # H0：对于某些 j，p_x(j) != 0，不是 p_x(10) != 0
# 极小的 p 值 =&gt; 测试认为一定存在一些自相关 

问题

我认为这是偶然的，有时甚至对于真实的 i.i.d. 变量，我们也可以抽取具有高自相关的样本 - 这与分布的选择无关。我说得对吗？
什么样本量足以假设存在真正的自相关？我有一个粗略的想法，我应该根据检验统计量的分布（在 Ljung-Box 检验中，在滞后 h 之前缺乏自相关）知道这一点。在零假设下，即 ($H_0: \forall_{j \in \{1, ... h\}} \quad \rho_x(j) = 0$)，检验统计量 $Q = n \sum \hat \rho^2_x(j) \sim \chi^2(h)$，其中 $h$ 是我们测试的最大滞后数，我不知道下一步该怎么做。
]]></description>
      <guid>https://stats.stackexchange.com/questions/659486/why-is-white-noise-generated-from-uniform-distribution-sometimes-autocorrelate</guid>
      <pubDate>Fri, 03 Jan 2025 12:35:42 GMT</pubDate>
    </item>
    <item>
      <title>如何从逻辑回归的引导程序中获取 p 值？</title>
      <link>https://stats.stackexchange.com/questions/659465/how-to-obtain-p-values-from-a-bootstrap-of-a-logistic-regression</link>
      <description><![CDATA[我有一个二元响应变量y和一组协变量(x_1, x_2, ..., x_n)。在执行多元逻辑回归时（在我的例子中使用 R 和 glm 函数：glm(y ~ x1 + x2 + x3 + ... + xn, family = binomial)），我可以获得 $p$ 值来检验协变量的系数是否显著，即 $H_0:\beta_j = 0$。
由于我的数据的维度（超过 100000 行和 5000 列），我无法执行多元逻辑回归来获取 $p$ 值（我的数据已经过过滤，即我无法执行变量选择）。我有如此庞大的数据集，以至于我必须对数据进行子采样才能容纳在我的计算机内存中。因此，我选择执行引导程序（b=引导样本数），但在子样本中（占总行数的 $p\%$）以获得多元逻辑回归的系数，如下所示：

我使用替换执行行选择，保持采样的二进制响应变量中 0/1 值的分布，以行的形式降低数据集的维数。
我将 glm 函数拟合到简化的数据集并获得系数和 p 值。
我重复此过程 b 次，获得系数和 p 值的向量。

每个变量的最终系数（在原始数据集中）是每个引导样本中获得的系数之间的平均值。
我的问题是：向量的平均值是多少每个样本中获得的 p 值是最终的 p 值吗？
恐怕不是，但在这种情况下，我如何获得逻辑回归引导程序的 p 值？
您肯定会建议我使用惩罚逻辑回归 (lasso)。我已经尝试过了，计算速度非常快。但是，使用后者，我仍然无法获得这些系数显著性的 p 值。如果您有关于如何获得这些最后的 p 值的参考，这对我也很有用。]]></description>
      <guid>https://stats.stackexchange.com/questions/659465/how-to-obtain-p-values-from-a-bootstrap-of-a-logistic-regression</guid>
      <pubDate>Thu, 02 Jan 2025 19:07:17 GMT</pubDate>
    </item>
    <item>
      <title>在 lme 中，混合中断时间序列模型中是否应仅排除干预之前/之后的观察结果？</title>
      <link>https://stats.stackexchange.com/questions/659464/in-lme-should-the-observations-only-before-after-an-intervention-be-excluded-in</link>
      <description><![CDATA[我们正在使用中断时间序列 (ITS) 模型检查 y 是否在 事件 之后在水平和/或斜率上发生变化。鉴于每个用户在 时间 上都有多个观察结果，我们使用以下混合模型：
m = 
lme(y ~ x + time + event + time:event, 
random = ~time|user_id, 
correlation = corAR1(form = ~1|user_id), 
weights = varExp(form = ~time), 
data = df)

有些用户的 y 值仅在事件发生前，有些用户的 y 值仅在事件发生后。
在拟合上述模型之前，是否应该排除这些用户（大约占总数的 1/3）？]]></description>
      <guid>https://stats.stackexchange.com/questions/659464/in-lme-should-the-observations-only-before-after-an-intervention-be-excluded-in</guid>
      <pubDate>Thu, 02 Jan 2025 18:24:37 GMT</pubDate>
    </item>
    <item>
      <title>在 rugarch 包中为 arfima 模型建立不同的 DS 平稳性模型</title>
      <link>https://stats.stackexchange.com/questions/659453/modelling-different-ds-stationarity-for-arfima-models-in-rugarch-package</link>
      <description><![CDATA[众所周知，时间序列有两种主要的平稳类型：趋势平稳（TS 序列），如 x_{t} = f(t) + e_{t，其中 e_{t 是平稳过程；差分平稳（DS 序列），如 (1 - L)^d x_{t} = mu + e_{t，其中 e_{t 是平稳过程。
因此，arfimaspec 方法仅包含 include.mean 和 d 作为规范中的差分阶数。但据我所知，没有办法在 DS 序列中添加 mu，其中 d &gt; 0。而且也没有办法添加混合型平稳性，例如 (1 - L)^d x_{t} = f(t) + e_{t?
我错了吗？也许可以通过 arfimaspec 中的外部回归器添加它？
还有一个简短而无关紧要的问题：arfimaforecast/ugarchforecast 是否能为滞后值 &gt; 1 生成正确的均值预测？]]></description>
      <guid>https://stats.stackexchange.com/questions/659453/modelling-different-ds-stationarity-for-arfima-models-in-rugarch-package</guid>
      <pubDate>Thu, 02 Jan 2025 15:29:10 GMT</pubDate>
    </item>
    </channel>
</rss>