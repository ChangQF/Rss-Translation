<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Tue, 11 Feb 2025 12:33:12 GMT</lastBuildDate>
    <item>
      <title>loess() 与自卷式黄土平滑器之间的差异</title>
      <link>https://stats.stackexchange.com/questions/661221/discrepancy-between-loess-and-roll-your-own-loess-smoother</link>
      <description><![CDATA[为了更好地理解 R 的 loess() 的作用，我尝试根据 ?loess 上的描述编写自己的 LOESS 函数。它产生的结果与 loess() 获得的结果相似，但不完全相同。如果您能提供任何关于导致这些差异的见解，我将不胜感激。我认为这个问题对于 CV 来说很好，因为我的目标是更好地理解统计程序。
# 自己动手实现 LOESS 函数
predict_loess &lt;- function(x_star, x, y, span) {
if (span &lt; 1) {
n &lt;- ceiling(length(x) * span)
cutoff &lt;- sort(abs(x - x_star))[n]
max_dist &lt;- cutoff
} else {
n &lt;- length(x)
cutoff &lt;- max(abs(x - x_star))
max_dist &lt;- span * max(abs(x - x_star))
}
x_retained &lt;- x[abs(x - x_star) &lt;= cutoff]
y_retained &lt;- y[abs(x - x_star) &lt;= cutoff]
weights &lt;- (1 - (abs(x_retained - x_star)/max_dist)^3)^3
d &lt;- data.frame(x_retained, y_retained, weights)
mod.lm &lt;- lm(y_retained ~ poly(x_retained, 2), data = d, weights = 1*weights)
predict(mod.lm, newdata = data.frame(x_retained = x_star))
}

# 示例 1
plot(mpg ~ disp, mtcars)
x_stars &lt;- seq(71, 472, 1)

mod.loess &lt;- loess(mpg ~ disp, mtcars, span = 1/2)
lines(x = x_stars, y = predict(mod.loess, newdata = data.frame(disp = x_stars)), col = &quot;blue&quot;)
predictions_loess &lt;- sapply(x_stars, predict_loess, x = mtcars$disp, y = mtcars$mpg, span = 1/2)
lines(x = x_stars, y = predictions_loess, col = &quot;red&quot;)


# 示例 2
plot(mpg ~ disp, mtcars)
mod.loess &lt;- loess(mpg ~ disp, mtcars，span = 3/4)
x_stars &lt;- seq(71, 472, 1)
lines(x = x_stars，y = predict(mod.loess，newdata = data.frame(disp = x_stars))，col = &quot;blue&quot;)
predictions_loess &lt;- sapply(x_stars，predict_loess，x = mtcars$disp，y = mtcars$mpg，span = 3/4)
lines(x = x_stars，y = predictions_loess，col = &quot;red&quot;)


# 示例 3
plot(mpg ~ disp, mtcars)
mod.loess &lt;- loess(mpg ~ disp, mtcars, span = 2)
x_stars &lt;- seq(71, 472, 1)
lines(x = x_stars, y = predict(mod.loess, newdata = data.frame(disp = x_stars)), col = &quot;blue&quot;)
predictions_loess &lt;- sapply(x_stars, predict_loess, x = mtcars$disp, y = mtcars$mpg, span = 2)
lines(x = x_stars, y = predictions_loess, col = &quot;红色&quot;)

]]></description>
      <guid>https://stats.stackexchange.com/questions/661221/discrepancy-between-loess-and-roll-your-own-loess-smoother</guid>
      <pubDate>Tue, 11 Feb 2025 12:10:28 GMT</pubDate>
    </item>
    <item>
      <title>如何从数学上正确计算每个协变量对总模型概率预测的概率加法？</title>
      <link>https://stats.stackexchange.com/questions/661218/how-to-mathematically-properly-calculate-the-probabilistic-addition-of-each-cova</link>
      <description><![CDATA[抱歉，事先已注明。

y&#39; (P) = 1 / (1 + exp(-sum(betas times Xs))) 1

我想知道我的每个 x 对 P 贡献了多少 p，以便它们的总和恰好等于 P。
我的模型的参数是：
logreg_coefs = (139.8640, 11.3660, 61.3583, 115.9492, 237.9015, 38.8623, -3.5466)


假设我有协变量：
协变量 = (0.5, 0.3, 0.2, 0.1, 0, 0, 1)

如果我将 1 用于各个协变量，我会得到奇怪的数字，例如，对于零协变量值，我得到 p = 1/2（期望得到它零...）。
我尝试对各个 ps 求和，然后取份额，但我得到的值 &gt; 0，其中我的协变量为零，因此 b*x 给出零。
稍后更新
我回想起了通过增加模型的阶数（从仅截距到完全协变量存在）来逐步改进模型的做法。考虑到这一点，我可以重现累积概率计算，并对概率值进行一步减差分。至少我现在看到的是更正确的值，并且具有完美的求和结果。
python 中的代码执行以下操作：
logreg_coefs = (139.8640, 11.3660, 61.3583, 115.9492, 237.9015, 38.8623, -3.5466)

exogs = (0, 0.02, 0.03, 0.004, 0.005, 0.006, 1)

exog_ps = []

bx = 0

for x, b in zip(reversed(exogs), reversed(logreg_coefs)):
bx += b * x
exog_ps.append(1 / (1 + np.exp(-bx)))

打印(exog_ps)

x_adds_p = []

exog_ps_reversed = list(reversed(exog_ps))

对于 i 在范围(len(exog_ps_reversed)-1)内：
x_adds_p.append(exog_ps_reversed[i] - exog_ps_reversed[i + 1])

x_adds_p.append(exog_ps[0])

打印(x_adds_p)

打印(sum(x_adds_p))

logreg_prob = 1 / (1 + np.exp(-1 * np.sum(np.array(exogs) * np.array(logreg_coefs))))

打印(logreg_prob)

打印(logreg_prob - sum(x_adds_p))

]]></description>
      <guid>https://stats.stackexchange.com/questions/661218/how-to-mathematically-properly-calculate-the-probabilistic-addition-of-each-cova</guid>
      <pubDate>Tue, 11 Feb 2025 09:59:05 GMT</pubDate>
    </item>
    <item>
      <title>当经验分布收敛时，NLL-交叉熵等价性对非IID数据成立吗？</title>
      <link>https://stats.stackexchange.com/questions/661216/does-the-nll-cross-entropy-equivalence-hold-for-non-iid-data-when-the-empirical</link>
      <description><![CDATA[在这个先前的问题中，已确定对于 IID 数据，负对数似然 (NLL) 等同于模型与经验分布之间的交叉熵。
经验分布由以下公式给出：
$$
\hat{P}_n(x) = \frac{1}{n}\sum_{i=1}^{n}\delta(x - x_i)
$$
当数据为非 IID 时，在某些情况下可以收敛。
在这种情况下，NLL 和交叉熵之间的等价性是否仍然成立，或者在处理非 IID 数据时是否还有其他考虑因素？
有任何见解或参考吗将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/661216/does-the-nll-cross-entropy-equivalence-hold-for-non-iid-data-when-the-empirical</guid>
      <pubDate>Tue, 11 Feb 2025 09:32:19 GMT</pubDate>
    </item>
    <item>
      <title>具有不确定性的泊松过程的中值预期上限</title>
      <link>https://stats.stackexchange.com/questions/661210/median-expected-upper-limit-for-a-poisson-process-with-uncertainties</link>
      <description><![CDATA[考虑在存在不确定的背景速率$b$的情况下确定过程信号速率$s$的上限的问题。背景速率受到另一个测量的限制，其中观察到$b_{obs}$个事件。然后，观察到$n_{obs}$个事件的总可能性由以下公式给出：
$$
L(s,b| n_{obs}, b_{obs}) = Pois(n_{obs}| s+b) \times Pois(b_{obs} | b)
$$
这里感兴趣的参数是$s$。我知道如何建立置信区间，或者对于这个问题更重要的是，使用各种频率学派技术和玩具蒙特卡罗实验来提取上限。现在我所苦苦挣扎的是如何计算“预期”中位数上限。几篇文章（我稍后会添加参考资料）只是说，应该在背景假设中执行“玩具 MC 实验”，将它们视为数据，然后从那里构建上限的分布。如何生成玩具？具体来说，$b$ 使用什么值？
任何帮助都将非常有帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/661210/median-expected-upper-limit-for-a-poisson-process-with-uncertainties</guid>
      <pubDate>Tue, 11 Feb 2025 05:56:06 GMT</pubDate>
    </item>
    <item>
      <title>通过模拟进行对数秩检验的功效</title>
      <link>https://stats.stackexchange.com/questions/661209/power-of-logrank-test-through-simulation</link>
      <description><![CDATA[对数秩检验样本量公式由 Lachin 和 Foulkes (1986) 制定，题为“评估样本量和生存分析的功效，同时考虑患者入组不均匀、失访、不依从和分层”。我正在运行一个玩具模拟来查看公式的准确性。按照论文的符号，患者在 R 年的累积期内被招募，并被跟踪到研究结束 T 年。假设 R = 3、T =5、指数生存、均匀累积，并且在研究结束前没有其他审查，geDesign 包中的 nSurvival 函数使用 Lachin 和 Foulkes (1986) 方法，并给出样本量 = 368 以达到 90% 的功效：
# 事件发生时间样本量计算 (Lachin-Foulkes)
library(gsDesign)

ss &lt;- nSurvival(
lambda1 = .3, lambda2 = .2, eta = 0, Ts = 5, Tr =3,
sided = 1, alpha = .05
)
ss

以下是我用来验证此方法的模拟代码：
n &lt;- 368
followup &lt;- 2
eff &lt;- 0
Nsim &lt;- 20000
level &lt;- 0.05
lamda1 &lt;- .2
lamda0 &lt;- .3
p &lt;- 1/2
R &lt;- 3

for (i in 1:Nsim){
trt &lt;- rbinom(n,1,p)

cumentrytime &lt;- runif(n,0,R) #统一累积
censorT &lt;- R + followup #研究结束 T =5

T1 &lt;- rexp(n,lamda1) #指数生存
T0 &lt;- rexp(n,lamda0)
T &lt;- T1
T[trt==0] &lt;- T0[trt==0]

statustrue &lt;- (T+cumentrytime &lt; censorT) #如果事件时间在结束之前，则 status = 1研究
T[statustrue==0] &lt;- censorT-cumentrytime[statustrue==0] # 审查对象的曝光时间

logrank_testfinal &lt;- survdiff(Surv(T, statustrue) ~ trt)
pvaluefinal &lt;- pchisq(logrank_testfinal$chisq, length(logrank_testfinal$n)-1, lower.tail = 
FALSE)
if (pvaluefinal &lt; level ) eff &lt;- eff+1 
}

eff/Nsim

结果功效约为 83%。模拟和公式之间 7% 的功效差异是否在预期范围内（假设我的模拟进行了公平比较）？如果不是，是否有另一个样本量计算公式可以给出与模拟更一致的结果？]]></description>
      <guid>https://stats.stackexchange.com/questions/661209/power-of-logrank-test-through-simulation</guid>
      <pubDate>Tue, 11 Feb 2025 03:26:49 GMT</pubDate>
    </item>
    <item>
      <title>偏回归系数线性模型中的缩放坐标（纬度和经度）</title>
      <link>https://stats.stackexchange.com/questions/661202/scaling-coordinates-latitude-and-longitude-in-a-linear-model-for-partial-regre</link>
      <description><![CDATA[我有一个数据集，我想比较一下偏回归系数。我在多个地方都读到，预测变量应该是均值中心化的，并按 1 个标准差缩放，以便于实现这一点，特别是当变量的尺度相差很大时。但是，我的一个预测变量恰好是经度。一般示例：
响应变量 ~ 中心化和缩放变量 1 + 中心化和缩放变量 2 + 经度 + 
中心化和缩放变量 1：中心化和缩放变量 2 + 
中心化和缩放变量 1：经度 + 
中心化和缩放变量 2：经度)

似乎惯例是将所有变量中心化/缩放或不缩放，但这让我想知道缩放和中心化对于纬度和经度是否必要且合适。我偶然发现了这篇 StackOverflow 帖子，似乎暗示答案可能是“否”因为它扭曲了坐标的含义：
（https://stackoverflow.com/questions/48426533/variation-partitioning-using-latitude-and-longitude-as-explanatory-variables）
但是，如果我主要对系数感兴趣，我不太明白在多元线性回归的背景下，缩放和居中纬度/经度是否不合适？
感谢您对此的任何想法！]]></description>
      <guid>https://stats.stackexchange.com/questions/661202/scaling-coordinates-latitude-and-longitude-in-a-linear-model-for-partial-regre</guid>
      <pubDate>Mon, 10 Feb 2025 22:44:18 GMT</pubDate>
    </item>
    <item>
      <title>根据生存函数的对数直观地了解风险函数</title>
      <link>https://stats.stackexchange.com/questions/661201/intuition-for-hazard-function-in-terms-of-logarithm-of-survival-function</link>
      <description><![CDATA[此帖子有助于解释风险函数的直觉。其中，风险函数被解释为
$$h(t) = \frac{f(t)}{S(t)},$$
其中 $f(t)$ 是 PDF，$S(t)$ 是生存函数。这导致了身份
$$h(t) = -\frac{d}{dt} \log (S(t)). $$
从中获得任何直觉吗？风险函数是假设患者存活到时间 t，则在时间 t 时的瞬时死亡率。令我惊讶的是，它不知何故等于生存函数对数变换的变化率。]]></description>
      <guid>https://stats.stackexchange.com/questions/661201/intuition-for-hazard-function-in-terms-of-logarithm-of-survival-function</guid>
      <pubDate>Mon, 10 Feb 2025 22:12:18 GMT</pubDate>
    </item>
    <item>
      <title>您是否知道应用 t-SNE 时具有这种行为的任何数据集？</title>
      <link>https://stats.stackexchange.com/questions/661194/do-you-know-of-any-dataset-with-this-behavior-when-applying-t-sne</link>
      <description><![CDATA[
我正在寻找一个在应用 t-SNE 时表现出这种行为的数据集。t-SNE 是一种降维算法，有时可以分离原本属于同一簇的数据点。
在本文的图 9（https://arxiv.org/abs/2009.01512）中，您可以清楚地看到这种现象。作者提出了一种保持簇完整的拓扑降维算法（TopoMap），并将其与 t-SNE 进行了比较。很明显，t-SNE 最终会将本应保留在单个群集中的点分开。
您遇到过这种现象吗？如果遇到过，您能分享数据集及其上下文吗？我正在做一个本科研究项目，非常感谢任何帮助。]]></description>
      <guid>https://stats.stackexchange.com/questions/661194/do-you-know-of-any-dataset-with-this-behavior-when-applying-t-sne</guid>
      <pubDate>Mon, 10 Feb 2025 20:33:58 GMT</pubDate>
    </item>
    <item>
      <title>具有拉普拉斯先验的拉普拉斯分布的后验</title>
      <link>https://stats.stackexchange.com/questions/661183/posterior-of-a-laplace-distribution-with-a-laplace-prior</link>
      <description><![CDATA[我正在练习研究生统计课上的一些概念，并尝试推导平方损失函数 $L(\theta,a)=(\theta-a)^2$ 的贝叶斯规则。我有一个拉普拉斯分布，其位置参数为 $\theta$，单位尺度为（即 $X\sim \text{Laplace}(\theta,1)$），似然值为 $f(x;\theta)=\frac{\exp\{-\sum_{i=1}^n|x_i-\theta|\}}{2^n}$。此外，我有一个拉普拉斯先验，其位置为$\eta$，单位尺度为$\pi_\Theta(\theta)=\frac{\exp\{-|\theta-\eta|\}}{2}$。
首先，我并不完全确定如何进行此计算，但我已开始推导后验，如下所示：
$$\pi_{\Theta|X}(\theta|x)\propto\exp\Big\{-\sum_{i=1}^n|x_i-\theta|-|\theta-\eta|\Big\}$$
但我不知道如何简化我的表达式。如果它们都是正态分布，我就会知道完成平方并用 $\theta$ 来写我的表达式，这样我就能得到另一个正态分布。但是，在这种情况下，我对模数符号感到困惑。我以前没有使用过拉普拉斯分布，所以任何帮助我都会很感激。谢谢！
编辑：要回答贝叶斯规则的问题，我认为我必须找到一个$a$来最小化
$$\mathbb{E}[L(\Theta,a)|X=x]\propto\int_{-\infty}^\infty (\theta-a)^2 \exp\Big\{-\sum_{i=1}^n|x_i-\theta|-|\theta-\eta|\Big\}d\theta$$
但如果没有更多关于我的后验的信息，这会变得很困难。]]></description>
      <guid>https://stats.stackexchange.com/questions/661183/posterior-of-a-laplace-distribution-with-a-laplace-prior</guid>
      <pubDate>Mon, 10 Feb 2025 16:30:10 GMT</pubDate>
    </item>
    <item>
      <title>这是最大似然估计的可能替代方法吗？</title>
      <link>https://stats.stackexchange.com/questions/661174/is-this-a-possible-alternative-to-maximum-likelihood-estimation</link>
      <description><![CDATA[如果问题很简单，请原谅我，因为我来自纯数学背景。直观地说，最大似然估计量是从样本计算出的统计数据，以便最大化观察到的数据的概率。在我看来，以下未知参数的估计量更自然（根据 Glivenko-Cantelli 定理）：
假设我们的模型遵循分布 $F_{\theta_0}$，它是分布系列 $\{F_{\theta}\}_{\theta\in I}$ 的成员。假设 $X_1,X_2,X_3,...$ 为 iid 分布，且服从分布 $F_{\theta_0}$ （因此 $\theta_0$ 是真实参数）。可以寻找估计量 $\hat{\theta}_n(X_1,X_2,...,X_n)$，该估计量定义为 $\theta$ 的值，使得分布 $F_{\theta}$ 最接近（即在 $L^2$ 意义上）$X_1,X_2,..,X_n$ 的经验分布。文献中是否探讨过此估计量？它是否具有合理的属性？为什么 MLE 估计量比我描述的估计量更有利？
非常感谢]]></description>
      <guid>https://stats.stackexchange.com/questions/661174/is-this-a-possible-alternative-to-maximum-likelihood-estimation</guid>
      <pubDate>Mon, 10 Feb 2025 09:32:52 GMT</pubDate>
    </item>
    <item>
      <title>如果一个人（非）故意忽略了所有可用数据的 10％，那么最高的准确度是多少？</title>
      <link>https://stats.stackexchange.com/questions/661168/if-one-unintentionally-ignores-10-of-all-available-data-what-is-the-highest</link>
      <description><![CDATA[我不记得当时的场合了，但我相信是一位语言学家提出，如果忽略 10% 或 15% 的数据，那么从人们所关注的 85% 的数据中就永远无法得出任何有意义的结论。
从统计学的角度来看，这种情况会发生吗？还是取决于人群遵循哪种分布？]]></description>
      <guid>https://stats.stackexchange.com/questions/661168/if-one-unintentionally-ignores-10-of-all-available-data-what-is-the-highest</guid>
      <pubDate>Mon, 10 Feb 2025 05:55:22 GMT</pubDate>
    </item>
    <item>
      <title>估计具有外生状态的状态空间模型</title>
      <link>https://stats.stackexchange.com/questions/661071/estimating-state-space-model-with-exogenous-states</link>
      <description><![CDATA[我正在尝试使用 R 中的 DLM 包来估计状态空间模型，其中观测和状态方程如下：
$y_t=\beta_1a_t + B_t\beta_2(\frac{u_t-v_t}{u_t}) + C_t\beta_3(\frac{u_t-v_t}{u_t}) + \epsilon_t$
$v_t = v_{t-1}+ \zeta_t$
其中 $\epsilon_t\sim N(0,\sigma_\epsilon^2)$ 和 $\zeta_t\sim N(0,\sigma_\zeta^2)$
我有$y_t, a_t, B_t, C_t, u_t$的数据（时间序列）
我想估计 beta 并找到时间序列$v_t$。
我完全不确定如何估计这个模型，我只有一个状态方程，但我不确定我的状态在这里是什么。由于必须同时估计参数$\beta$和序列$v_t$，我无法将此模型与我读过的模型联系起来。
如果在这方面有任何帮助，我将不胜感激。
我认为我需要将其表示为状态空间模型，然后应用带有卡尔曼滤波的 EM 算法来估计参数和状态变量。例如，以下代码估计 $\beta$、$\sigma_\epsilon^2$ 和 $\sigma_\zeta^2$ 以及状态 $v_t$:
library(dlm)

# 观测方程
observation_equation &lt;- function(beta, a_t, B_t, C_t, u_t, v_t) {
beta[1] * a_t + B_t * beta[2] * ((u_t - v_t) / u_t) + C_t * beta[3] * ((u_t - v_t) / u_t)
}

# 定义状态空间模型
build_dlm &lt;- function(Q, R) {
# 我认为这个 dlmModPoly 将充当 v_t = v_{t-1} + \zeta_t
dlmModPoly(order = 1, dV = R, dW = Q)
}

# def 平方误差和
objective_function &lt;- function(params, y_t, a_t, B_t, C_t, u_t, v_t) {
beta &lt;- params[1:3]
y_pred &lt;- sapply(1:length(y_t), function(t) observer_equation(beta, a_t[t], B_t[t], C_t[t], u_t[t], v_t[t]))
error &lt;- y_t - y_pred

sum(error^2)
}

# beta、Q 和的初始猜测R
beta_init &lt;- c(0.5, 0.5, 0.5)
Q_init &lt;- 0.1
R_init &lt;- 0.1
params_init &lt;- c(beta_init, Q_init, R_init)
#初始化变量
Q_estimated = Q_init
R_estimated = R_init

# EM 算法
for (iteration in 1:10) {
# E-Step：使用当前 beta、Q 和 R 估计 v_t
model &lt;- build_dlm(Q_estimated, R_estimated)
fit &lt;- dlmFilter(y_t, model) # 卡尔曼滤波器应用
v_estimated &lt;- dropFirst(fit$m) # 估计状态 v_t

# M-Step：使用估计的参数更新模型
result &lt;- optim(params_init, objective_function, y_t = y_t, a_t = a_t, B_t = B_t, C_t = C_t, u_t = u_t, v_t = v_estimated)
params_estimated &lt;- result$par
beta_estimated &lt;- params_estimated[1:3]
Q_estimated &lt;- params_estimated[4]
R_estimated &lt;- params_estimated[5]

# 更新下一次迭代的初始参数
params_init &lt;- c(beta_estimated, Q_estimated, R_estimated)
}

其中 a_t、B_t、C_t、u_t 是已知且长度相同的时间序列。
这准确吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/661071/estimating-state-space-model-with-exogenous-states</guid>
      <pubDate>Fri, 07 Feb 2025 01:47:16 GMT</pubDate>
    </item>
    <item>
      <title>条件与边际：概率、可能性和模型</title>
      <link>https://stats.stackexchange.com/questions/660175/conditional-vs-marginal-probability-likelihood-and-models</link>
      <description><![CDATA[我很难理清这些想法。
1) 条件概率与边际概率：这是我最了解的一个，它依赖于概率的基本定律。
如果我们有两个连续随机变量 $X$ 和 $Y$。
$X$ 的边际概率密度函数，表示为 $f_X(x)$，是通过对 $Y$ 所有可能值的联合 PDF 进行积分获得的：
$$f_X(x) = \int_{-\infty}^{\infty} f_{X,Y}(x,y) dy$$
给定 $Y=y$，$X$ 的条件概率密度函数：
$$f_{X|Y}(x|y) = \frac{f_{X,Y}(x,y)}{f_Y(y)}$$
$$f_{X|Y}(x|y) = \frac{f_{Y|X}(y|x)f_X(x)}{f_Y(y)}$$
到目前为止一切正常。
2) 条件似然与边际似然：这个我也理解，因为它是一个第一部分的扩展。
我可以定义一个联合似然函数$L(\theta, \phi|X)$为：
$$L(\theta, \phi|X) \propto f_X(X|\theta, \phi)$$
从这里，边际似然和条件似然可以写成：
$$L_M(\theta|X) = \int_{-\infty}^{\infty} L(\theta, \phi|X) d\phi$$
$$L_C(\theta|X,\phi) = L(\theta, \phi|X)$$
3) 条件模型与边际模型（第 1 部分） 事情开始让我感到困惑。我以前听说过“条件和边际”这两个术语用于混合效应回归模型。例如，在纵向/聚类模型的背景下，我听说过以下内容：

像 GEE（一般估计方程）这样的回归框架被称为边际模型，因为它们估计整个总体的边际平均值。虽然 GEE 能够在估计阶段使用数据中存在的聚类级相关性，但最终模型无法在聚类级别提供任何统计推断。 GEE 只能描述整个人口层面上正在发生的事情。

$$ \text{logit}(P(Y_{ij} = 1|X_{ij})) = X_{ij}\beta^* $$

另一方面，混合/随机效应等回归框架被称为条件模型，因为它们可以通过其随机效应结构在集群级别提供统计推断。举例来说，聚类级别均值可以看作是条件均值（即以聚类为条件）。

$$ \text{logit}(P(Y_{ij} = 1|X_{ij}, b_i)) = X_{ij}\beta + b_i $$
我认为在我看来这一切都是合理的。
4) 条件模型与边际模型（第 2 部分）：我感到困惑的根源来自这里：https://en.wikipedia.org/wiki/Conditional_logistic_regression。虽然我并没有完全理解这一点，但这似乎是一种固定效应回归，我们不再对估计集群级别效应感兴趣。相反，我们似乎根据某些集群级别信息集来匹配人员，以避免变量混淆。这是维基百科上关于条件逻辑回归的一个示例 - 这次我们不是估计聚类级别的影响（就像在随机影响中所做的那样），而是对它们进行匹配以控制它们的影响：
$$P(Y_{i1}=1, Y_{i2}=0|X_{i1},X_{i2}, Y_{i1}+Y_{i2}=1) = \frac{\exp(\beta^TX_{i1})}{\exp(\beta^TX_{i1}) + \exp(\beta^TX_{i2})}$$
因此，似乎在所有这些情况下，被条件化的术语及其条件化方式都会发生变化。
我说得对吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/660175/conditional-vs-marginal-probability-likelihood-and-models</guid>
      <pubDate>Fri, 17 Jan 2025 17:36:04 GMT</pubDate>
    </item>
    <item>
      <title>后验最大值总是与边缘最大值相同吗？</title>
      <link>https://stats.stackexchange.com/questions/599704/is-the-posterior-maximum-always-the-same-as-the-marginals</link>
      <description><![CDATA[当我看到条件概率、边际和联合分布的图时，它们大多使用高斯分布绘制。我不清楚这是否适用于所有其他分布。例如，在此图像中 
条件 f(x1|b) 将始终在 f(x1) 的 argmax 处达到峰值，因为联合分布是高斯分布，并且“切片”会为边际分布提供另一个相同的高斯分布（按比例）。但情况总是如此吗？即，当 f(x1) != f(x1|b) 时，它们是否仍共享相同的最大值？或者，换句话说。无论形状如何，最大化后验与最大化边际在结果上是否相同？]]></description>
      <guid>https://stats.stackexchange.com/questions/599704/is-the-posterior-maximum-always-the-same-as-the-marginals</guid>
      <pubDate>Wed, 21 Dec 2022 10:12:50 GMT</pubDate>
    </item>
    <item>
      <title>关于评估（OLS）多个（2）种治疗方法的 RCT 的 ATE 的问题</title>
      <link>https://stats.stackexchange.com/questions/588961/question-on-estimating-ols-the-ate-of-rct-with-multiple-2-treatments</link>
      <description><![CDATA[已更新：
我没有足够的积分来评论，所以...
谢谢 Ben，你确实正确地解释了我的问题。有三个治疗类别：对照组、A 组和 B 组。谢谢你澄清，从
Y=治疗+协变量来看，A 组和 B 组的系数是相对于对照组的治疗效果。
另一方面，如果我想测量 A 组相对于 B 组的治疗效果，我该怎么做？
最后，一种或两种治疗的统计显著性是否意味着对照组（基线）的统计不显著？我猜不是，但如果截距可以通过解释缺失变量的变化而显著，那么我该如何测试对照组是否显著？
谢谢！
原文：
如果有两种治疗方法（对照组，比如说 A 和 B），我想测量 A 相对于对照组的效果，以及 A 相对于 B 的效果，我是否应该运行回归分析：
Y=INTERCEPT+A，使用治疗 B 子集数据，并且
Y=INTERCEPT+A，使用对照组子集数据？
如果是这样，如果我将所有条件都包含在一个回归分析中（Y=INTERCEPT+A+B），系数的解释是什么？
您可能已经看出来，我对 RCT 评估非常陌生。是否有任何几乎强制性的稳健性检查需要我运行？
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/588961/question-on-estimating-ols-the-ate-of-rct-with-multiple-2-treatments</guid>
      <pubDate>Fri, 16 Sep 2022 03:25:18 GMT</pubDate>
    </item>
    </channel>
</rss>