<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Mon, 02 Dec 2024 18:24:36 GMT</lastBuildDate>
    <item>
      <title>使用调查包计算 glm 模型时 R 平方的替代方法</title>
      <link>https://stats.stackexchange.com/questions/658161/alternative-to-r-squared-when-calculating-glm-model-using-survey-package</link>
      <description><![CDATA[我正在使用欧洲社会调查撰写我的硕士论文。数据需要加权，因此我必须使用 survey 包及其 svyglm 函数进行回归分析，而不是使用普通的 lm（我正在使用 R/RStudio）。回归本身运行良好，但是 svyglm 没有给出 R 平方的任何值。那么这里最好的解决方法是什么？
我读过关于伪 R 平方的文章（这也是 ChatGPT 建议的哈哈），但我认为它基于最大似然。但是，当尝试计算 Nagelkerkes R 平方时，RStudio 向我发出了一条警告消息，我的 svyglm 对象未使用最大似然计算。我没有在回归调用中指定任何非高斯族参数，因为我想计算一个线性模型，这就是文档建议的这里
尽管如此，我还是得到了一个值，但它与没有加权的 lm 模型中的值有很大不同：没有权重和抽样设计，R 平方为 0.03，从 svyglm 模型计算出的 Nagelkerkes R 平方为 0.79。即使加权改变了这个值，但如此巨大的差异肯定是这里出了问题。
你在这里建议什么方法？我应该坚持使用伪 R 平方吗？如果是，那用哪一个？或者我应该尝试提取残差平方和和总平方和来手动计算标准 R 平方？
感谢您的建议！
PS：对于那些说我应该跳过它的人：在之前的一篇论文中，我的讲师批评我在使用调查包时没有报告 R 平方。所以我必须找到一种方法。]]></description>
      <guid>https://stats.stackexchange.com/questions/658161/alternative-to-r-squared-when-calculating-glm-model-using-survey-package</guid>
      <pubDate>Mon, 02 Dec 2024 18:02:18 GMT</pubDate>
    </item>
    <item>
      <title>当一个变量具有季节性而另一个变量不具有季节性时，协整</title>
      <link>https://stats.stackexchange.com/questions/658158/cointegration-when-one-variable-is-seasonal-and-another-is-not</link>
      <description><![CDATA[我有两个变量：一个具有 12 个月的季节性模式，另一个是季节性调整的。我需要进行 10 年的长期预测。为此，如果存在协整，可以尝试误差修正模型。
这些经验策略是否有效？

在协整方程中使用季节性（作为因变量）和非季节性（独立变量）？在这种情况下，残差可能是具有季节性模式的白噪声。那么，它们不是平稳的吗？

估计与季节性虚拟变量（类似于控制变量）的协整关系。在这种情况下，我的残差表现出与均衡水平的波动，并且可以是平稳的。


我发现的大多数论文在 ECM 模型的预测中都使用季节性序列或季节性调整。如果我需要预测因变量的趋势和季节性波动怎么办……]]></description>
      <guid>https://stats.stackexchange.com/questions/658158/cointegration-when-one-variable-is-seasonal-and-another-is-not</guid>
      <pubDate>Mon, 02 Dec 2024 17:22:31 GMT</pubDate>
    </item>
    <item>
      <title>对PCA的质疑：为什么载荷常常被忽视？</title>
      <link>https://stats.stackexchange.com/questions/658157/doubts-about-pca-why-are-loadings-often-overlooked</link>
      <description><![CDATA[我对 PCA 的存在性存有疑虑。我经常看到它用于遗传学，在遗传学中，你研究的基因组可能你并不完全了解它们的功能。在这种情况下，PCA 用于捕获数据集中的潜在变异性并生成新的不相关变量（主成分）。
但是，当将 PCA 应用于具有已知有形变量的数据集时（尤其是当目标是降低维度或可视化异常值时），我注意到很少对这些变量的负载进行后续分析。在我的特定情况下，我使用有形变量，并且我经常有兴趣了解它们之间的关系以及它们在成分中的权重。然而，在大多数研究中，我只发现解释方差的百分比，仅此而已。
这让我很疑惑：为什么不更多地强调解释负载？载荷对于理解原始变量的行为方式及其对主成分的贡献是否不重要？对我来说，载荷对于解释变量之间的关系以及确定它们对变异性的影响似乎至关重要。我是否遗漏了什么，或者这只是 PCA 分析中一个未被充分探索的领域？
我希望我的问题有意义。提前感谢您的见解！]]></description>
      <guid>https://stats.stackexchange.com/questions/658157/doubts-about-pca-why-are-loadings-often-overlooked</guid>
      <pubDate>Mon, 02 Dec 2024 17:07:52 GMT</pubDate>
    </item>
    <item>
      <title>从 R 中的多个 ROC 曲线中选择最佳预测因子</title>
      <link>https://stats.stackexchange.com/questions/658159/select-best-predictor-from-multiple-roc-curves-in-r</link>
      <description><![CDATA[这是我的数据
structure(list(USI3 = structure(c(2L, 1L, 2L, 2L, 1L, 2L, 1L, 
1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 1L, 2L, 1L, 1L), levels = c(&quot;non&quot;, 
&quot;oui&quot;), class = &quot;factor&quot;), SBEcl3 = structure(c(4L, 3L, 3L, 1L, 
3L, 4L, 4L, 1L, 2L, 4L, 4L, 2L, 1L, 4L, 2L, 2L, 3L, 2L, 4L, 4L
), levels = c(&quot;Q3&quot;, &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q4&quot;), 类 = &quot;因素&quot;), VBEcl3 = 结构(c(3L, 
2L, 1L, 3L, 1L, 3L, 3L, 1L, 2L, 3L, 3L, 2L, 1L, 3L, 2L, 2L, 1L, 
2L, 3L, 3L), 级别 = c(&quot;Q2&quot;, &quot;Q1&quot;, &quot;Q3&quot;), 类 = &quot;因素&quot;), 
SOFA3 = 结构(c(1L, 2L, 3L, 3L, 1L, 3L, 2L, 3L, 3L, 1L, 
2L, 2L, 2L, 1L, 2L, 3L, 1L, 2L, 2L, 2L), 水平 = c(&quot;Q1&quot;, 
&quot;Q2&quot;, &quot;Q3&quot;), 类别 = &quot;因子&quot;, LACTATES3 = 结构(c(2L, 
3L, 1L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 2L, 1L, 1L, 3L, 
3L, 3L, 1L, 1L), 水平 = c(&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;), 类别 = &quot;因子&quot;, 
SBE3 = c(5.88755625371722, -5.83367949101861, -5.16855590395164, 
    1.94584567145157、-4.46237190410756、2.92799867956303、6.99250801087927、 
    0.414319711015225、-16.1438604651896、5.80900771418004、5.08271450621078、 
    -7.1973116153256、-1.30327738092311、4.05722685252242、-15.2431163349488、 
-18.1380051674948, -4.84876594310452, -11.5092300657808, 
9.46936571654563, 16.4607368929384), VBE3 = c(4.83306549999999, 
-5.17690968000001, -3.96411408000001, 4.33224666999999, -3.45727284, 
1.75496799999999, 7.36360999999999, 0.618853640000002, -17.29309464, 
    5.33871410999998、6.48677951999998、-4.91616858000001、-0.740172520000016、 
    6.13709857999999、-15.35942096、-18.24841597、-3.61614233000002、 
    -12.1641, 10.34413375, 19.15572), SOF3 = c(2, 5, 6, 6, 2, 
    6, 4, 8, 14, 1, 3, 5, 3, 2, 4, 11, 2, 5, 4, 4), LACT3 = c(1.9, 
3.4, 1.4, 0.8, 1.9, 18.4, 0.5, 2.2, 10.8, 0.8, 2.4, 7.1, 
1.9, 1.5, 1.1, 19, 3.1, 4.7, 1.1, 1), RL3 = 结构(c(2L, 
2L, 2L, 1L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 1L, 2L, 
1L, 2L, 1L, 1L), 水平 = c(&quot;非&quot;, &quot;是&quot;), 类别 = &quot;因子&quot;), 
OXYGENE3 = 结构（c（2L，2L，2L，2L，1L，2L，2L，2L，1L， 
2L，2L，2L，2L，1L，1L，2L，1L，2L，1L，2L，2L），级别 = c（“非”， 
“是”），类 = “因素”），NEW3 = c（5，6，8，6，2，11，6， 
7，6，7，12，5，10，2，1，10，5，4，4，8），AGE3 = c（88，53， 
71，73，58，71，83，77，58，77，35，75， 57, 64, 68, 52, 58, 
81, 78, 77), ATB3 = 结构(c(2L, 2L, 1L, 2L, 2L, 2L, 2L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L, 2L, 1L), 水平 = c(&quot;非&quot;, 
&quot;是&quot;), 类别 = &quot;因素&quot;), SEXE3 = 结构(c(1L, 1L, 2L, 
2L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 2L, 
1L, 1L), levels = c(&quot;Femme&quot;, &quot;Homme&quot;), class = &quot;factor&quot;)), row.names = c(NA, 
20L), class = &quot;data.frame&quot;)

#Packages
library(ggplot2)
library(dplyr)
library(caret)
library(plotROC)
library(pROC)
library(ROCR)

#3 回归模型
modele1 &lt;- glm(USI3 ~ SBEcl3 + AGE3 + SEXE3 + RL3 + ATB3 + OXYGENE3 + NEW3 , data = data3, family = binomial)
modele2 &lt;- glm(USI3 ~ LACTATES3 + AGE3 + SEXE3 + RL3 + ATB3 + OXYGENE3 + NEW3 , data = data3, family = binomial)
modele3 &lt;- glm(USI3 ~ SOFA3 + AGE3 + SEXE3 + RL3 + ATB3 + OXYGENE3 + NEW3 , data = data3, family = binomial)

#预测模型
predict(modele1)
predict(modele2)
predict(modele3)

#3 ROC 曲线
rocs &lt;- list()
rocs[[&quot;modele1&quot;]] &lt;- roc(data3$USI3, predict(modele1))
rocs[[&quot;modele2&quot;]] &lt;- roc(data3$USI3, predict(modele2))
rocs[[&quot;modele3&quot;]] &lt;- roc(data3$USI3, predict(modele3))
ggroc (rocs, legacy.axes = TRUE)

#Results

我想确定预测 USI 入院风险（USI3）的最佳判别分数（SBE3、LACT3、SOF3）。我将这些连续变量转化为定性变量，并将它们纳入我的模型中。我从我的回归模型中做出预测，这些预测非常差（AUC1 = 0.74，AUC2 = 0.72，AUC3 = 0.79)。
这种方法对你来说合适吗？如何有更好的预测？你还有其他方法可以建议给我吗？如何使用ROC曲线分析提前选择ICU入院的不同预测因素的阈值？
提前谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/658159/select-best-predictor-from-multiple-roc-curves-in-r</guid>
      <pubDate>Mon, 02 Dec 2024 16:54:32 GMT</pubDate>
    </item>
    <item>
      <title>在 R 函数 rank_trace 中，是否存在一个共同的阈值来接受排名？</title>
      <link>https://stats.stackexchange.com/questions/658156/in-the-r-function-rank-trace-does-there-exist-a-common-threshold-value-to-accep</link>
      <description><![CDATA[在用于降阶回归的 R 包 rrr（文档）中，有一个函数 rank_trace。
它返回一个图，其中回归系数矩阵的每个秩都对应一个点。
通常，如果该点接近原点$(0,0)$，那么我们更希望这个等级是可以接受的。
我的问题是，例如在$p$值中，如果$p&gt;0.05$，即$0.05$是$p$的阈值，我们通常愿意接受一个假设。
尽管我知道这个界限不是通用的，但我仍然想知道，在处理数据（例如，来自试验）时，$\max\{x,y\}$是否存在任何共同的阈值，其中$(x,y)$是对应于某个等级的点，可以接受这个等级？]]></description>
      <guid>https://stats.stackexchange.com/questions/658156/in-the-r-function-rank-trace-does-there-exist-a-common-threshold-value-to-accep</guid>
      <pubDate>Mon, 02 Dec 2024 16:31:36 GMT</pubDate>
    </item>
    <item>
      <title>“最近 k 个合作伙伴”的抽样分布</title>
      <link>https://stats.stackexchange.com/questions/658155/sampling-distribution-for-most-recent-k-partners</link>
      <description><![CDATA[我正在尝试开发一个贝叶斯模型，以了解在分层为群体的人群中，伙伴关系如何形成/结束。挑战：我们只有最近 $k=3$ 个合作伙伴（非代表性样本 - 但那是另一个故事）的数据（群体成员、持续时间以及合作关系是否持续）。这是我目前所得到的（问题在最后）：

让 $N_i$ 为 $i$ 组的真实人口规模。
让 $f_{ij}$ 为 $i$ 组中的个人与 $j$ 组中的个人建立伙伴关系的平均每人比率。

那么 $F_{ij} = f_{ij} N_i = f_{ji} N_j$ 就是在人口层面形成伙伴关系的总比率，它是对称的（尽管 $f_{ij}$ 不是）。


让 $d_{ij}$ 成为 $i$ 组和 $j$ 组之间伙伴关系的平均持续时间（必须是对称的）。

那么 $X_{ij} = f_{ij} d_{ij}$ 就是对于组 $i$ 中的每个个体，与 $j$ 建立积极伙伴关系的预期数量。



问题：对于组 $i$ 中的个体，我们如何定义概率分布 $\theta_{j|i,k}$，从而得到组索引 $j$ 的“最近”事件？ $k=3$ 合作伙伴会被抽签吗？
假设：是否只是：
$j~\sim~\theta_{j|i,k} = \frac{X_{ij}}{\sum_j X_{ij}}$
不依赖于$k$？我还担心这不会使用任何有关合作关系是否持续的信息。]]></description>
      <guid>https://stats.stackexchange.com/questions/658155/sampling-distribution-for-most-recent-k-partners</guid>
      <pubDate>Mon, 02 Dec 2024 16:26:20 GMT</pubDate>
    </item>
    <item>
      <title>使用 PC 分数对存在/不存在数据进行建模</title>
      <link>https://stats.stackexchange.com/questions/658153/modelling-presence-absence-data-with-pc-scores</link>
      <description><![CDATA[我有一些动物数量与环境变量的 PCA 分数的数据，如下所示。计数数据中的 .5 是因为有两个人计数，然后我们取了平均值。
 data &lt;- data.frame(
pc1 = c(0.1, 0.3, 0.5, 2.7, 0.9, 1.1, 0.3, 1.5, 1.7, 2.9),
pc2 = c(3.1, 1.3, 2.7, 2.7, 2.1, 1.3, 2.3, 3.5, 1.7, 3.9),
count = c(0,1.5, 0, 0, 2.5, 0, 0, 1, 0.5, 0)
)

我想测试 PC 分数（环境变量）是否对计数有影响。
我使用：
lm.count &lt;- lm(count ~ pc1 + pc2, data)
summary (lm.count)

输出：
调用：
lm(formula = count ~ pc1 + pc2, data)

残差：
最小值 1Q 中位数 3Q 最大值 
-1.3547 -0.3614 -0.2009 0.5609 1.8412 

系数：
估计标准差。误差 t 值 Pr(&gt;|t|) 
(截距) 1.300000 0.241209 5.390 0.000163 ***
pc1 0.004687 0.158655 0.030 0.976920 
pc2 -0.118962 0.170177 -0.699 0.497848 
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：12 个自由度上的 0.9342
多重 R 平方：0.0392，调整后的 R 平方：-0.1209
F 统计量：2 和 12 DF 上的 0.2448，p 值：0.7867

但我想知道大量的零计数信息是否会扭曲数据并意味着使用此模型是不正确的。 Chat GTP 建议我尝试使用逻辑模型来表示存在和不存在：
logistic_model &lt;- glm(count &gt; 0 ~ pc1 + pc2, family = binomial, data = data)
summary(logistic_model)

输出：
调用：
glm(formula = count &gt; 0 ~ pc1 + pc2, family = binomial, data = data)

偏差残差：
最小 1Q 中位数 3Q 最大 
-2.2854 0.3479 0.5064 0.5594 0.7567 

系数：
估计标准差。误差 z 值 Pr(&gt;|z|) 
(截距) 1.98844 0.83717 2.375 0.0175 *
pc1 0.37118 0.52065 0.713 0.4759 
pc2 0.05496 0.52303 0.105 0.9163 
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

（二项式系列的分散参数取为 1）

零偏差：14 个自由度上的 11.780
残差偏差：12 个自由度上的 11.239
AIC：17.239

Fisher 评分迭代次数：5

这样好些了吗？模型摘要完全不显著，但当将模型预测与 PC1 轴绘制在一起时，相关性几乎完美。所以我确信有些事情出错了。。
这是代码（最后是真实数据图）：
predicted_probs &lt;- predict(logistic_model, type = &quot;response&quot;)
data$predicted_probs &lt;- predict_probs

plot(data$pc1, data$predicted_probs,
xlab = &quot;pc1&quot;, ylab = &quot;Predicted Probability of counts &gt; 0&quot;,
main = &quot;Logistic Regression: Predicted Probability vs PC1&quot;,
pch = 19, col = &quot;blue&quot;)

我觉得模型重要性和绘制的预测之间的不匹配表明有些事情出错了。也许模型是正确的，但绘图是错误的？或者反过来。但如果没有相关性，我预计图中的点会到处都是。
这是图：
]]></description>
      <guid>https://stats.stackexchange.com/questions/658153/modelling-presence-absence-data-with-pc-scores</guid>
      <pubDate>Mon, 02 Dec 2024 16:19:25 GMT</pubDate>
    </item>
    <item>
      <title>与病理分布的卷积第 2 部分</title>
      <link>https://stats.stackexchange.com/questions/658151/convolution-with-a-pathological-distribution-part-2</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/658151/convolution-with-a-pathological-distribution-part-2</guid>
      <pubDate>Mon, 02 Dec 2024 16:10:59 GMT</pubDate>
    </item>
    <item>
      <title>条件概率和朴素贝叶斯分类器之间的区别</title>
      <link>https://stats.stackexchange.com/questions/658150/difference-between-conditional-probability-and-naive-bayes-classifier</link>
      <description><![CDATA[我有这个数据集



a
b
c
K




1
0
1
1


1
1
1
1


0
1
1
0


1
1 
0
0


1
0
1
0


0
0
0
1


0
0
0
1


0
0
0
1


0
0
1
0



我尝试计算概率
使用朴素贝叶斯分类器计算 P(K=1 ∣ a=1 ∧ b=1 ∧ c=0)
如果我使用贝叶斯定理扩展表达式，我会得到正确的结果（即 1/2）。
我不明白的是当我尝试直观方法时，即：
假设 a=1 ∧ b=1 ∧ c=0 是事件 D
那么问题问我们 P(K=1 ∣ D)，这应该意味着 P(K=1 ∩ D) / P(D)，对吗？
好吧，当我计算 a=1、b=1 和 c=0 的行时，我只计算一行（第 4 行）。
当我查看 K=1 和 D 同时适用的行时，我计数 0 个这样的行。（第 4 行的 K 为 0）。
因此，我通过这种方式得到的答案是 0/1，即 0。但我认为正确答案是 1/2。
有人能向我解释为什么后一种逻辑不起作用吗？我研究了很多，但仍然不明白为什么它不起作用。
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/658150/difference-between-conditional-probability-and-naive-bayes-classifier</guid>
      <pubDate>Mon, 02 Dec 2024 15:33:46 GMT</pubDate>
    </item>
    <item>
      <title>实验设计的结构和生成方法</title>
      <link>https://stats.stackexchange.com/questions/658149/structure-of-the-experimental-design-and-generating-approach</link>
      <description><![CDATA[我对田间试验有以下具体需求，并希望在了解其处理和单元结构后生成设计。有，

有 40 个基因型/品种。 10 种基因型各组成一个预先分配的组，因此有 4 组基因型
一个组可以是两个级别/类别中的任一个 - 两系和三系
基因型在 3 个完整的重复中重复
每个重复由 2 个块组成
每个块由 2 个完整的（包含所有 10 种基因型）子块组组成，其中一个来自两个级别/类别
子块的组分配是随机的。
每个子块内的基因型都是随机的

有了上述详细信息，我已经能够使用 tidyverse 函数和分组结构在 R 中生成所需的设计。

v_df &lt;- tibble(`品种名称` = paste0(&quot;V&quot;, 1:40), `空间分配` = rep(c(&quot;三行&quot;, &quot;两行&quot;, &quot;两行&quot;, &quot;三行&quot;), each = 10)) %&gt;%
mutate(`Group` = rep(1:4, each = 10)) %&gt;% 
group_by(`Group`) %&gt;% 
nest() %&gt;%
expand_grid(replication = 1:3) %&gt;% 
排列(replication) %&gt;% 
mutate(block = rep(1:6, each = 2)) %&gt;% 
group_by(block) %&gt;% 
mutate(`data` = sample(data, 2, replace = FALSE)) %&gt;%
ungroup() %&gt;% 
mutate(genotype = purrr::map(data, ~sample_n(.x, size = 10, replace = FALSE))) %&gt;% 
select(-data) %&gt;% 
unnest_longer(genotype) %&gt;% 
unpack(cols = genotype) %&gt;% 
group_by(replication, block) %&gt;% 
mutate(x = row_number()) %&gt;% 
ungroup() %&gt;% 
mutate(y = as.numeric(interaction(replication, block))) %&gt;% 
mutate(Group = as.factor(Group))

这将生成以下布局图（绘图代码包含在本文底部）：

我可以推断出重复是完整的并且被限制在块中。所以说它是一个 RCBD 没问题。但是，子块呢？将它们分配在块内并使用特定的分组结构进行复制超出了我对设计和理论的理解。
首先，让我感到困惑的是，这是否是一个有效的设计。如果是，那么它属于哪一类设计？我希望更好地了解这种和类似设计的用法。
由于设计在阻塞方面施加了约束，它会猜测某些 r 包/函数已经比我的冗长代码更有效地实现了该功能。在答案中提供代码指针会很有帮助。
# 图形代码
ggplot() +
geom_tile(data = v_df, aes(x, y, fill = `Space assignment`),
color = NA, linewidth=1.2, alpha = 0.6) +
scale_fill_discrete() +
geom_tile(data = v_df, aes(x = x, y = y),
color = &quot;black&quot;, fill = NA) +
geom_text(data = v_df, aes(x = x, y = y,
label = stringr::str_wrap(`Variety name`, width = 8)), size = 1.85) +
guides(fill = &quot;none&quot;) +
theme_void()
]]></description>
      <guid>https://stats.stackexchange.com/questions/658149/structure-of-the-experimental-design-and-generating-approach</guid>
      <pubDate>Mon, 02 Dec 2024 15:31:08 GMT</pubDate>
    </item>
    <item>
      <title>局部投影累积变量[关闭]</title>
      <link>https://stats.stackexchange.com/questions/658148/local-projection-cumulative-variable</link>
      <description><![CDATA[我很难理解局部预测中累积因变量的概念，特别是当它写成$( y_{t+h} - y_{t-1} )$时。例如，如果我在左侧有通货膨胀率，应该如何计算？
在 R 中的 lpirfs 包中，它们似乎按字面意思计算为$( y_{t+h} - y_{t-1} )$。因此，如果$ y_{t+h} = 5$和$y_{t-1} = 2 $，则得到$3$。但是，我认为累积通货膨胀率应该是从 $t-1$ 期间到 $t+h$ 期间的通货膨胀率之和，也就是 $2+5=7$。
提前致谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/658148/local-projection-cumulative-variable</guid>
      <pubDate>Mon, 02 Dec 2024 15:14:31 GMT</pubDate>
    </item>
    <item>
      <title>估计 SD[Z=X*Y] 哪一个是正确的？</title>
      <link>https://stats.stackexchange.com/questions/658147/estimate-sdz-xy-which-one-is-correct</link>
      <description><![CDATA[假设我们有两个变量 X 和 Y 的样本，样本大小为 n。我想计算 Z = X*Y 的标准差。我不知道下面两个选项哪个是正确的？
选项 1：
只需从样本中创建新变量 Z=X*Y，然后使用普通标准差公式：
$$ std(Z) = \sqrt \frac{\sum (Z-E[Z])^2}{n-1} $$
选项 2：
使用：$\text{Var}[X \cdot Y] = \mathbb{E}[X^2] \cdot \text{Var}[Y] + \mathbb{E}[Y^2] \cdot \text{Var}[X] + 2 \cdot \text{Cov}(X, Y) \cdot \mathbb{E}[X] \cdot \mathbb{E}[Y]$
然后估计 RHS 上的每个分量并得到 std(Z)]]></description>
      <guid>https://stats.stackexchange.com/questions/658147/estimate-sdz-xy-which-one-is-correct</guid>
      <pubDate>Mon, 02 Dec 2024 15:08:13 GMT</pubDate>
    </item>
    <item>
      <title>解释 GAMM 模型的残差</title>
      <link>https://stats.stackexchange.com/questions/658146/interpretting-residuals-from-a-gamm-model</link>
      <description><![CDATA[我尝试使用二项式数据 (link=logit) 在 r 中使用 mgcv 包运行 GAM。这是为了尝试描述哪些变量描述物种的存在，使用存在 (1) 和不存在 (0) 数据作为响应，使用一组环境和社会变量作为预测变量。我使用结合随机效应的多级方法。我的数据是空间自相关的，所以我还使用 x 和 y 来解释这一点。
我使用的代码似乎运行良好，但是，当我绘制残差时，我留下了两条不同的线，我不确定如何解释这一点或这是否正确。我对统计学也还不太熟悉。
我希望得到一些帮助，了解这种形状是否适用于二进制数据，以及这种图通常意味着什么。
spatial_model_gamm &lt;- gamm4(
Species1 ~ s(X, Y) + Variable1 + Variable2 + Variable3 + Variable4,
random = ~(1 | Dist_ID), 
data = Data,
family = binomial
)


]]></description>
      <guid>https://stats.stackexchange.com/questions/658146/interpretting-residuals-from-a-gamm-model</guid>
      <pubDate>Mon, 02 Dec 2024 14:51:41 GMT</pubDate>
    </item>
    <item>
      <title>即使基础模型是线性的，那么在集成中生成的模型也是非线性的吗？</title>
      <link>https://stats.stackexchange.com/questions/658143/in-ensemble-the-resulting-model-is-nonlinear-even-if-the-base-model-is-linear</link>
      <description><![CDATA[我有这个疑问，在线性基本模型集合的情况下，我确信（但我不知道对此的确切数学解释）所得集合仅适用于线性空间。另一方面，如果还存在非线性基础模型（例如 50%）会发生什么？所得模型是非线性的吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/658143/in-ensemble-the-resulting-model-is-nonlinear-even-if-the-base-model-is-linear</guid>
      <pubDate>Mon, 02 Dec 2024 12:57:05 GMT</pubDate>
    </item>
    <item>
      <title>二次型具有卡方分布的条件</title>
      <link>https://stats.stackexchange.com/questions/658138/condition-for-quadratic-form-to-have-a-chi-squared-distribution</link>
      <description><![CDATA[根据 Seber 和 Lee 的教科书定理 2.8：如果 $\mathbf{Y} \sim N_n(\mathbf{0},\Sigma)$ 且 $A$ 是对称的，则 $\mathbf{Y}^TA\mathbf{Y} \sim \chi^2_r$ 当且仅当 $A\Sigma$ 的特征值中的 $r$ 为 $1$ 且其余为零。
本书给出了 $\Rightarrow$ 方向的证明，但指出证明对于 $\Leftarrow$ 方向的证明，正好是 $\Rightarrow$ 方向的证明的逆向。
我试图逆转证明，然而，对于 $\Rightarrow$ 方向的证明，利用了 $R^TAR$ 是对称和幂等的事实，其中 $\Sigma = RR^T$ 来建立 $\operatorname{rank}(R^TAR) = \operatorname{trace}(R^TAR)$。这是证明的这一步，我不知道如何逆转，因为我们不知道 $R^TAR$ 是否对称且幂等。有人能给我一些说明吗？请注意，我们并没有假设 $A$ 或 $\Sigma$ 是可逆的。]]></description>
      <guid>https://stats.stackexchange.com/questions/658138/condition-for-quadratic-form-to-have-a-chi-squared-distribution</guid>
      <pubDate>Mon, 02 Dec 2024 10:48:45 GMT</pubDate>
    </item>
    </channel>
</rss>