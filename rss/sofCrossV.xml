<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Sun, 24 Nov 2024 01:24:57 GMT</lastBuildDate>
    <item>
      <title>理解合并回归模型的误差协方差</title>
      <link>https://stats.stackexchange.com/questions/657746/understanding-the-error-covariance-of-pooled-regression-model</link>
      <description><![CDATA[我正在阅读格林的《计量经济学分析》（第 7 版，2011 年）。在第 350 页，他讨论了随机效应回归模型：
$$
\begin{aligned}
y_{it} &amp;= x&#39;_{it} \beta + E[z&#39;_i \alpha] + \left[ z&#39;_i \alpha - E[z&#39;_i \alpha]\right] + \varepsilon_{it} \\
&amp;= x&#39;_{it} \beta + a + \varepsilon_{it} + (c_i - E[c_i | X_i]) \\
&amp;= x&#39;_{it} \beta + a + \varepsilon_{it} + u_i \\
&amp;= x&#39;_{it} \beta + a + w_{it}
\end{aligned}
$$
书中接着说未观察到的异质性（即$z&#39;_i\alpha$）会引起自相关：$t \ne s$时，$E[w_{it}w_{is}] = \sigma^2_u$。
我不相信我看到了这一点。如果我们取相对于时间的期望值 $t$，并注意到 $E_t[w_{it}] = \omega_i$
$$
\begin{aligned}
Cov_t(w_{it}, w_{is}) &amp;= E_t [(w_{it} - \omega_i)(w_{is} - \omega_i)]\\
&amp;= E_t(w_{it}w_{is}) + T \omega_i^2 \\
&amp;= E_t[(\varepsilon_{it} + u_i)(\varepsilon_{is} + u_i)] + T \omega_i^2 \\
&amp;= E_t[\varepsilon_{it} \varepsilon_{is}] + E_t[u_i^2] + T \omega_i^2 \\
&amp;= T(u_i^2 + \omega_i^2) \qquad \text{ for } t \ne s
\end{aligned}
$$
显然，从上面可以看出
$$
\begin{aligned}
E_t(w_{it}w_{is}) &amp;= E_t[(\varepsilon_{it} + u_i)(\varepsilon_{is} + u_i)] \\
&amp;= E_t[\varepsilon_{it} \varepsilon_{is}] + E_t[u_i^2] \\
&amp;= Tu_i^2 \qquad \text{ for } t \ne s
\end{aligned}
$$
他们是如何得到$\sigma^2_u$的？]]></description>
      <guid>https://stats.stackexchange.com/questions/657746/understanding-the-error-covariance-of-pooled-regression-model</guid>
      <pubDate>Sat, 23 Nov 2024 23:22:16 GMT</pubDate>
    </item>
    <item>
      <title>GAM 残差和 ACF 的后验模拟</title>
      <link>https://stats.stackexchange.com/questions/657744/posterior-simulation-of-residuals-and-acf-for-gams</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/657744/posterior-simulation-of-residuals-and-acf-for-gams</guid>
      <pubDate>Sat, 23 Nov 2024 22:56:10 GMT</pubDate>
    </item>
    <item>
      <title>对于两个独立的 glmmTMB 模型，sjPlot::tab_model() 中存在相同的随机效应方差值 (sigma^2)，这是 R 的问题</title>
      <link>https://stats.stackexchange.com/questions/657742/r-issue-with-the-same-random-effect-variance-value-sigma2-in-sjplottab-mode</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/657742/r-issue-with-the-same-random-effect-variance-value-sigma2-in-sjplottab-mode</guid>
      <pubDate>Sat, 23 Nov 2024 22:13:03 GMT</pubDate>
    </item>
    <item>
      <title>鲁宾规则从小鼠估算数据集和均方根库中预测的值</title>
      <link>https://stats.stackexchange.com/questions/657741/rubins-rules-predicted-values-from-mice-imputed-datasets-and-rms-library</link>
      <description><![CDATA[我正在中途开始分析，所以我的起点是使用小鼠创建的多个估算数据集。
##################################################################################
# 加载库
library(rms)
library(mice)
library(dplyr)

set.seed(123) # 为了可重复性

# 观察次数
n &lt;- 100

# 结果
y &lt;- rbinom(n, size = 1, prob = 0.07)

# bmi
bmi &lt;- runif(n, min = 16, max = 60)
bmi[sample(1:n, size = round(0.12 * n))] &lt;- NA # 引入缺失值

# tiktok_ban
tiktok_ban &lt;- sample(1:90, size = n, replace = TRUE)
#tiktok_ban[sample(1:n, size = round(0.05 * n))] &lt;- 0 # 强制某些值为 0

# sex
child_sex &lt;- sample(c(&quot;Male&quot;, &quot;Female&quot;), size = n, replace = TRUE, prob = c(0.49, 0.51))
child_sex[sample(1:n, size = round(0.05 * n))] &lt;- NA # 引入缺失值

# 合并为数据框
df &lt;- data.frame(y, bmi, tiktok_ban, child_sex)

# 查看第一行数据集
head(df)

##################################################################################

imputed_df &lt;- mice(df, print = FALSE, m = 20, seed = 24415, method = &quot;pmm&quot;, printFlag = FALSE)

imputed_df_l &lt;- mice::complete(imputed_df, &quot;long&quot;, include = FALSE)

我能够在 mice 插补数据集上拟合模型并获得汇总估计值和预测值。我正在使用 rms 包中的 Predict 函数。
#####################################################################################

d &lt;- imputed_df_l
dd &lt;- datadist(d); options(datadist=&#39;dd&#39;)

Hmisc::describe(imputed_df_l$tiktok_ban)

k &lt;- attr(rcs(imputed_df_l$tiktok_ban, 6), &#39;parms&#39;)
k

h &lt;- function(x) {
z &lt;- cbind(rcspline.eval(x, k),
#sin=sin(2*pi*x/12), cos=cos(2*pi*x/12),
jump=x &gt;= 20)
attr(z, &#39;非线性&#39;) &lt;- 2 : ncol(z)
z
}

###########################################################################################
m1 &lt;- lapply(1:20, function(i){
f &lt;- lrm(y ~ child_sex + bmi +
gTrans(tiktok_ban, h),
data= subset(imputed_df_l, .imp == i))
pred &lt;- Predict(f, tiktok_ban)
return(pred)
})

我的目标是检查结果如何随时间变化。20 个估算数据集的预测值存储为列表对象。
m1[[1]], m1[[2]], .....m1[[20]]

但是，我不确定如何将 Rubin 规则应用于这些预测值，因为 Predict 函数不提供标准错误。
请就汇集这些预测值的最佳方法提供建议？感谢您的指导。
感谢您的时间]]></description>
      <guid>https://stats.stackexchange.com/questions/657741/rubins-rules-predicted-values-from-mice-imputed-datasets-and-rms-library</guid>
      <pubDate>Sat, 23 Nov 2024 22:10:22 GMT</pubDate>
    </item>
    <item>
      <title>在 Mann Whitney U 检验中支持零假设后，进行事后功效分析是否合适？样本量不相等</title>
      <link>https://stats.stackexchange.com/questions/657740/is-it-appropriate-to-do-a-post-hoc-power-analysis-after-the-null-hypothesis-is-f</link>
      <description><![CDATA[嗨，在 Mann Whitney U 检验中支持零假设后进行事后功效分析是否合适？样本量不相等，我想知道它是否功效不足。对于像链接的帖子，我不确定这是否合适。谢谢
样本量和功效检测]]></description>
      <guid>https://stats.stackexchange.com/questions/657740/is-it-appropriate-to-do-a-post-hoc-power-analysis-after-the-null-hypothesis-is-f</guid>
      <pubDate>Sat, 23 Nov 2024 21:24:17 GMT</pubDate>
    </item>
    <item>
      <title>是否有更好的回归线适合以下数据</title>
      <link>https://stats.stackexchange.com/questions/657739/is-there-a-better-regression-line-that-fit-the-following-data</link>
      <description><![CDATA[全部，
下面是 x 和 y 的散点图。我正在尝试找到最适合它的回归曲线。线性（红色）和三次（黑色）回归曲线非常相似。想知道是否有更好的回归技术来拟合这些数据。下面是我的 python 脚本数据。

#!/usr/bin/env python3
# -*- 编码：utf-8 -*-

将 matplotlib.pyplot 导入为 plt
将 numpy 导入为 np
将 statsmodels.api 导入为 sm

f = open(&#39;../../../data_files/regression/output.txt&#39;)

_col1=[]
_col2=[]
_col3=[]
for ll in f:
a=ll.split(&#39;,&#39;)[0]
_col1.append(float(a))

b=ll.split(&#39;,&#39;)[1]
_col2.append(float(b))

c=ll.split(&#39;,&#39;)[2]
_col3.append(float(c))

x=np.array(_col1)
y=np.array(_col2)
t=np.array(_col3)

x_with_ones=np.array((np.ones(len(x)),x)).T

model1 = sm.OLS(y,x_with_ones).fit()

_x_test=np.array([0.008,0.009,0.010,0.011,0.012])
x_test1=np.array((np.ones(5),_x_test)).T

out1=model1.predict(x_test1)
print(model1.summary())
#%%
#多元回归
x_poly = np.array((np.ones(len(x)),x,x**2,x**3))
model2=sm.OLS(y,x_poly.T).fit()
x_test2=np.array((np.ones(len(_x_test)),_x_test,_x_test**2,_x_test**3)).T
out2= model2.predict(x_test2)
print(model2.summary())

plt.figure()
plt.scatter(x,y)
plt.plot(_x_test,out1,&#39;-r&#39;,label=&#39;linear&#39;)
plt.plot(_x_test,out2,&#39;-k&#39;,label=&#39;polynomial (cubic)&#39;)
plt.legend()

数据文件已上传至box.com 这里
谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/657739/is-there-a-better-regression-line-that-fit-the-following-data</guid>
      <pubDate>Sat, 23 Nov 2024 21:09:24 GMT</pubDate>
    </item>
    <item>
      <title>使用 ACF 和 PACF 进行 ARMA 建模的问题</title>
      <link>https://stats.stackexchange.com/questions/657737/problems-with-using-acf-and-pacf-for-arma-modelling</link>
      <description><![CDATA[
这是我的变量$\Delta y_t,$的一阶差分的ACF和PACF，我使用了ADF检验、PP检验、Schmidt Phillips检验和DFGLS检验，得到了与我的变量$\Delta y_t$ 的积分阶为 0，但从我们所学的知识来看，这些图似乎并不表明它是平稳的。
我一直在尝试在 $\Delta y_t,$ 上拟合 ARMA 模型，我们所学的方法是查看两个图中的最高显着滞后来确定 AR 和 MA 过程的阶数，然后使用 BG 检验自相关来解析模型（如果没有相关性）。
我的 AR 滞后是 PACF 的 11，MA 滞后是 ACF 的 16。我试图解析模型，但得到的结果非常不一致且不可预测。我正在使用 eviews，它不允许我输入这么多项，所以我从 ARMA (10,0,10) 开始。对于 ARMA(10,0,10)，我得到模型是非平稳的，因为其中一个倒置 AR 根为 1，并且残差之间存在高度序列相关性。但是对于 ARMA(10,0,9)，我得到它是平稳的，并且没有任何序列相关性。对于 ARMA (4,0,2)，我得到它是平稳的，但具有序列相关性。
我不明白我错在哪里。请帮忙。]]></description>
      <guid>https://stats.stackexchange.com/questions/657737/problems-with-using-acf-and-pacf-for-arma-modelling</guid>
      <pubDate>Sat, 23 Nov 2024 19:32:22 GMT</pubDate>
    </item>
    <item>
      <title>使用小样本减少极端概率预测</title>
      <link>https://stats.stackexchange.com/questions/657735/reducing-extreme-probability-predictions-using-a-small-sample</link>
      <description><![CDATA[假设一场比赛中有 2 名赛车手，我知道每个赛车手的成绩列表（数字越小越好）。假设第一个赛车手的成绩如下：
X1 = [6, 8, 10]

第二个赛车手的成绩如下：
X2 = [9, 11]

因此，所有赛车手的向量长度不必相同。我想要做的是计算每个赛车手获胜的概率。我假设每个赛车手的时间发生概率等于 1/N，其中 N 是该赛车手的样本数。因此，对于这个例子，第一个赛车手获胜的概率是：
1/3 * 2/2 + 1/3 * 2/2 + 1/3 *1/2 = 5/6

问题是，如果我们将 X2 = [11, 12]，那么它会计算出第一个赛车手将始终获胜，这是一个有点极端的预测，因为真正的比赛时间可能会遵循某种钟形曲线。所以我基本上需要一种将极端预测转化为不那么极端的方法。例如，转换
[1, 0] -&gt; [0.9, 0.1]

而合理预测的某些值应该保持不变
[0.7, 0.3] -&gt; [0.7, 0.3]（或与原始值非常相似）

是否有一些函数可用于转换这样的值？]]></description>
      <guid>https://stats.stackexchange.com/questions/657735/reducing-extreme-probability-predictions-using-a-small-sample</guid>
      <pubDate>Sat, 23 Nov 2024 18:12:38 GMT</pubDate>
    </item>
    <item>
      <title>投资组合损失的概率分布</title>
      <link>https://stats.stackexchange.com/questions/657733/probability-distribution-of-portfolio-loss</link>
      <description><![CDATA[我尝试做这个练习，但有些地方不太对劲。我们需要计算，参考一年的时间范围，预期违约次数和违约概率等于由 200 笔贷款组成的投资组合的预期违约次数，每笔贷款的违约概率 (PD) 等于 1%。建议使用泊松分布。我是这样计算预期违约次数的 $E(D) = n\times PD = 200\times0.01 = 2$
使用泊松分布，我计算出违约概率等于预期违约次数 (2)，即 $P(X=2) = \frac{\lambda^x e^{-\lambda}}{x!}$ = $\frac{2^2 e^{-2}}{2!}$ = 0.27
下一点不清楚：
利用上一点的概率，假设损失与 20000 次违约次数成正比，完成下面给出的投资组合损失概率分布：
\begin{matrix}
\textbf{金额} &amp; \textbf{概率} \\
0 &amp; 0.16 \\
20000 &amp; ? \\
40000 &amp; ? \\
60000 &amp; 0.22 \\
80000 &amp; 0.08 \\
100000 &amp; 0.02 \\
\end{matrix
有人能帮我填一下这个表格吗？
如果表中的初始值（无默认值）与 0.16% 的概率相关，那么我在第一点的答案可能不正确，因为 $P(X=0) \frac{\lambda^x e^{\lambda}}{x!} = e^{-2}= 0.135$
那么 X=1 等于 X=2 的概率是 $P(X=1) \frac{\lambda^x e^{\lambda}}{x!} = \lambda e^{-2}= 0.27$
但是，如果我们将这些概率添加到表中的概率中，它就超出了值 1. 我该如何解决这个问题？]]></description>
      <guid>https://stats.stackexchange.com/questions/657733/probability-distribution-of-portfolio-loss</guid>
      <pubDate>Sat, 23 Nov 2024 17:58:57 GMT</pubDate>
    </item>
    <item>
      <title>我对这个多元线性回归的评价正确吗？</title>
      <link>https://stats.stackexchange.com/questions/657728/is-my-evaluation-for-this-multiple-linear-regression-correct</link>
      <description><![CDATA[我正在研究多元线性回归，遵循 RegenerativeToday 在 https://www.youtube.com/watch?v=wH_ezgftiy0 上的教程，使用 https://github.com/rashida048/Datasets/blob/master/insurance.csv 上的保险数据集。不过，我比视频更进一步，将 MSE、MAE、调整后的 R2 和 RMSE 应用于我的模型。我担心的问题是，我得到的数字似乎非常大。对于训练数据：
训练数据中的观测数：535
因变量：6
R2：0.738388485444704
调整后的 R2：0.7354156273247574
均方误差：40267096.874797866
平均绝对误差：4539.378629153684
均方根误差：6345.636049664199

对于测试数据：
测试数据中的观测数：803
因变量：6
R2：0.7544700183565812
调整后的 R2： 0.7526192898517313
均方误差：34,610,344.63969177
平均绝对误差：4166.692650134549
均方根误差：5883.0557229803435

如果我理解正确的话，这意味着我可以预期模型的预测与实际保险费用会有 34,610,344 美元的偏差。有人能告诉我这个数据集是否需要这个吗？
我的代码，如果你需要的话，在这里：
import matplotlib.pyplot as plt
from scipy import stats
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import pandas as pd
import numpy as np
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error

insurance = pd.read_csv(&#39;insurance.csv&#39;)

insurance[&#39;sex&#39;] = insurance[&#39;sex&#39;].astype(&#39;category&#39;)
insurance[&#39;sex&#39;] = insurance[&#39;sex&#39;].cat.codes
insurance[&#39;smoker&#39;] = insurance[&#39;smoker&#39;].astype(&#39;category&#39;)
insurance[&#39;smoker&#39;] = insurance[&#39;smoker&#39;].cat.codes
insurance[&#39;region&#39;] = insurance[&#39;region&#39;].astype(&#39;category&#39;)
insurance[&#39;region&#39;] = insurance[&#39;region&#39;].cat.codes

x = insurance.drop(columns = &#39;charges&#39;)
y = insurance[&#39;charges&#39;]

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.6, random_state=0)

lr = LinearRegression()
lr.fit(x_train, y_train)

y_intercept = lr.intercept_
coefficient = lr.coef_

y_predict_train = lr.predict(x_train)
plt.scatter(y_train, y_predict_train)
plt.xlabel(&quot;实际费用&quot;)
plt.ylabel(&quot;预测费用&quot;)
plt.show()

n_train = len(y_train)
print(f&quot;训练数据中的观测值数量：&quot;, n_train)
p = len(x.columns)
print(f&quot;依赖变量：&quot;, p)

#R2
r2 = r2_score(y_train, y_predict_train)
print(f&quot;R2：&quot;, r2)
#调整后的 R2：1 - (1-R^2)*((n-1)/(n-p-1))。在这种情况下，n 为 len(y_train)=535，且 p = 6
ar2 = 1 - (1-r2)*((n_train-1)/(n_train-p-1))
print(f&quot;Adjusted R2: &quot;, ar2)
#MSE
mse = mean_squared_error(y_train, y_predict_train)
print(f&quot;Mean Squared Error: &quot;, mse)
#MAE
mae = mean_absolute_error(y_train, y_predict_train)
print(f&quot;Mean Absolute Error: &quot;, mae)
#RMSE
sqmse = np.sqrt(mse)
print(f&quot;Root Mean Squared Error: &quot;, sqmse)

y_predict_test = lr.predict(x_test)
plt.scatter(y_test, y_predict_test)
plt.xlabel(&quot;实际费用&quot;)
plt.ylabel(&quot;预测费用&quot;)
plt.show()

n_test = len(y_test)
print(f&quot;测试数据中的观测值数量：&quot;, n_test)
p = len(x.columns)
print(f&quot;依赖变量：&quot;, p)
#显示 R2
r2 = r2_score(y_test, y_predict_test)
print(f&quot;R2：&quot;, r2)
ar2 = 1 - (1-r2)*((n_test-1)/(n_test-p-1))
print(f&quot;调整后的 R2：&quot;, ar2)
#MSE
mse = mean_squared_error(y_test, y_predict_test)
print(f&quot;均方误差：&quot;, mse)
#MAE
mae = mean_absolute_error(y_test, y_predict_test)
print(f&quot;平均绝对误差：&quot;, mae)
#RMSE
sqmse = np.sqrt(mse)
print(f&quot;均方根误差：&quot;, sqmse)
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/657728/is-my-evaluation-for-this-multiple-linear-regression-correct</guid>
      <pubDate>Sat, 23 Nov 2024 15:49:48 GMT</pubDate>
    </item>
    <item>
      <title>针对区域调整的回归线与特定区域的回归线</title>
      <link>https://stats.stackexchange.com/questions/657727/regression-lines-adjusted-for-region-vs-region-specific-regression-lines</link>
      <description><![CDATA[我想了解黑色回归线和蓝色回归线之间的区别（幻灯片第 10 页）。
蓝色：针对区域调整的回归线，分别针对 N 和 S 区域绘制。
黑色：区域特定回归线
谢谢



]]></description>
      <guid>https://stats.stackexchange.com/questions/657727/regression-lines-adjusted-for-region-vs-region-specific-regression-lines</guid>
      <pubDate>Sat, 23 Nov 2024 15:43:04 GMT</pubDate>
    </item>
    <item>
      <title>逻辑模型中的优势比</title>
      <link>https://stats.stackexchange.com/questions/657716/odds-ratio-in-a-logistic-model</link>
      <description><![CDATA[我在 R 中拟合了一个逻辑回归模型，获得了 95% 的准确率、0.98 的 AUC 得分、0.4 的 Brier 得分，灵敏度和特异性值约为 90%，因此我认为这是一个好的模型，而且我确信我没有过度拟合它，因为样本量足够大，我使用嵌套交叉验证进行训练，之前使用该数据集的工作具有相似的指标得分。但是当我使用来评估优势比时
# 优势比的整洁模型
OR_forward &lt;- tidy(model_forward, conf.int = TRUE, exp = TRUE)
# 查看
print(OR_forward)

我获得的模型
| term | 估计 | std.error | 统计 | p.value | conf.low | conf.high |
| -------------------- | --------------- | ---------------- | ---------------- | -------------- | --------------- | ---------------- |
| (截距) | 0.9803722 | 0.5585423 | -0.0354905 | 0.9716886222 | 0.34167844 | 3.099333e+00 |
| perimeter_worst | 138.4584082 | 1.6246777 | 3.0347988 | 0.0024069620 | 8.85712651 | 6.073470e+03 |
| smoothness_worst | 2.8558969 | 0.6659321 | 1.5758153 | 0.1150683769 | 0.86645297 | 1.232178e+01 |
| 纹理最差 | 21.1155988 | 0.8005182 | 3.8100470 | 0.0001389404 | 5.43421791 | 1.362067e+02 |
| 半径 | 249.6495402 | 1.7514729 | 3.1516663 | 0.0016234171 | 18.82154660 | 1.576302e+04 |
| 凹面点最差 | 12.5199362 | 1.3407680 | 1.8849810 | 0.0594324041 | 1.06768453 | 2.285697e+02 |
| 分形维数 | 0.1506027 | 0.6689871 | -2.8298153 | 0.0046574880 | 0.03406688 | 4.961252e-01 |
| 凹度平均值 | 13.0852042 | 1.1904412 | 2.1601084 | 0.0307642776 | 1.28731054 | 1.542539e+02 |
| 纹理维数 | 0.1935264 | 0.8072612 | -2.0344610 | 0.0419051325 | 0.03440948 | 8.765000e-01 |

这对我来说很奇怪。我对数据执行的唯一操作是使用 来缩放它们
data[-1] &lt;- scale(data[-1]) # 第一列是分类的

我还绘制了残差
plot(residuals(model_forward)) #stats library


因为据我所知，异常值可能会影响模型的 OR，但我认为我不能简单地将它们从数据中删除。有人能帮我理解为什么我的 OR 这么高并降低它们吗，或者我应该如何解释这些值？]]></description>
      <guid>https://stats.stackexchange.com/questions/657716/odds-ratio-in-a-logistic-model</guid>
      <pubDate>Sat, 23 Nov 2024 10:55:35 GMT</pubDate>
    </item>
    <item>
      <title>Freeman-Tukey 变换的 metafor 发生率的反向变换 [关闭]</title>
      <link>https://stats.stackexchange.com/questions/657703/back-transformation-of-freeman-tukey-transformed-incidence-rates-in-metafor</link>
      <description><![CDATA[问题描述
我正在使用 metafor 包对同一疾病的不同治疗方法的术后复发率进行荟萃分析，但我正在努力对我们用作结果衡量标准的 Freeman-Tukey 变换发生率的反向变换进行编码。
代码
使用以下公式将个体效应大小计算为 Freeman-Tukey 变换发生率：
 ies = escalc(measure = &quot;IRFT&quot;, add = 0, data = Data, xi = total.recurrences,
ti = time)

我们指定了一个三级模型来解释研究间和研究内的异质性，并将其拟合到我们不同的治疗组以获得每个治疗组的汇总效应大小。
模型1：
 pes.sg = rma.mv(yi, vi, data = ies,
subset = treatment == &quot;insert subgroup&quot;, 
random = ~1 | study.id/es.id,
method = &quot;REML&quot;, test = &quot;t&quot;,dfs = &quot;contain&quot;, 
cvvc = TRUE) 

我们还对整个数据集使用了另一种多元回归参数化方法，将分组变量作为调节变量，以获得与单独分析相同的结果。
模型 2：
 pes = rma.mv(yi, vi, 
random = list(~treatment|study.id, ~treatment|es.id), 
mods = ~0+treatment,
data = ies, 
method = &quot;REML&quot;, struct = &quot;DIAG&quot;, test = &quot;t&quot;,dfs = &quot;contain&quot;,
sparse = TRUE)

现在我想使用 predict() 和 transf.iirft() 函数来获取模型 1 的反向转换汇总效应大小，或模型 2 的每个调节器treatment级别的反向转换平均结果。每个都有相应的置信区间和预测区间。我们希望报告原始规模上每个治疗组的估计平均发生率（及其 CI 和 PI），以便于解释我们的结果。
 predict(pes.sg, transf = transf.iirft(xi = ?, ti = ?))
predict(pes, newmods = c(dummies as required), transf = transf.iirft(xi = ?, ti = ?))

如果您能帮助我将汇总效应大小或调节器水平的平均结果进行反向转换，我将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/657703/back-transformation-of-freeman-tukey-transformed-incidence-rates-in-metafor</guid>
      <pubDate>Fri, 22 Nov 2024 22:28:48 GMT</pubDate>
    </item>
    <item>
      <title>探索性因子分析、斜向旋转、方差解释</title>
      <link>https://stats.stackexchange.com/questions/657692/exploratory-factor-analysis-oblique-rotation-variance-explained</link>
      <description><![CDATA[如何计算通过探索性因子分析获得的因子模型解释的方差的问题时常出现。这里有一个包含多种可能性的摘要：在 R 中使用斜旋转进行探索性因子分析后计算因子解释的方差
我使用的是 R，带有 psych 包，如代码片段所示：
library(psych)

fa_results &lt;- fa(df_sq1sq9, nfactors = 5, rotate = &quot;oblimin&quot;)
mean(fa_results$communalities)
print(fa_results)


平均共同性金额：0.7418824
摘要表还将 0.74 报告为斜交旋转的解释方差：
斜交旋转：

[...]
MR1 MR3 MR5 MR2 MR4
SS 载荷 2.45 1.50 1.07 1.05 0.60
比例方差 0.27 0.17 0.12 0.12 0.07
累积方差 0.27 0.44 0.56 0.68 0.74
解释比例 0.37 0.22 0.16 0.16 0.09
累积比例 0.37 0.59 0.75 0.91 1.00

因子相关性为 
MR1 MR3 MR5 MR2 MR4
MR1 1.00 0.59 0.64 -0.01 0.30
MR3 0.59 1.00 0.33 0.12 0.21
MR5 0.64 0.33 1.00 0.28 0.11
MR2 -0.01 0.12 0.28 1.00 -0.17
MR4 0.30 0.21 0.11 -0.17 1.00


如果我使用正交旋转进行相同的分析，例如varimax，那么我得到的解释总方差值相同。
Varimax 旋转：
[...]

MR1 MR3 MR2 MR5 MR4
SS 载荷 2.44 1.45 1.06 0.91 0.81
比例方差 0.27 0.16 0.12 0.10 0.09
累积方差 0.27 0.43 0.55 0.65 0.74
解释比例 0.37 0.22 0.16 0.14 0.12
累积比例 0.37 0.58 0.74 0.88 1.00


据我了解，正交旋转会在因子之间重新分配载荷，但解释总方差仍然是整个系统都一样。但是，我不确定斜向旋转，因为这些因素在它们解释的方差上重叠。在上面的例子中，我在一些因素之间存在显著的相关性，但我得到的总解释方差与方差最大值相同。在这种情况下，总解释方差是否也相同，还是我做错了什么？我需要反馈。谢谢！
更新：
我还查看了两种情况下 fa_results$loadings 的输出。它显示的方差最大值的摘要值不与 print(fa_results) 相同，但在斜向旋转的情况下，输出偏差更大。哪些值是正确的？
Oblimin：与 print(fa_results) 相比的偏差
Oblimin 旋转：
&gt;fa_results$loadings
[...]
MR1 MR3 MR5 MR2 MR4
SS 载荷 2.310 1.350 0.975 1.038 0.563
比例变异 0.257 0.150 0.108 0.115 0.063
累积变异 0.257 0.407 0.515 0.630 0.693

Varimax：与 print(fa_results) 相比的偏差。
Varimax旋转：
&gt;fa_results$loadings
[...]
MR1 MR3 MR2 MR5 MR4
SS 载荷 2.444 1.450 1.064 0.913 0.806
比例方差 0.272 0.161 0.118 0.101 0.090
累积方差 0.272 0.433 0.551 0.652 0.742
]]></description>
      <guid>https://stats.stackexchange.com/questions/657692/exploratory-factor-analysis-oblique-rotation-variance-explained</guid>
      <pubDate>Fri, 22 Nov 2024 17:10:04 GMT</pubDate>
    </item>
    <item>
      <title>为什么 R 中的二项式家族（link="log"）的 glm 有时需要起始值？</title>
      <link>https://stats.stackexchange.com/questions/657665/why-does-glm-in-r-with-family-binomiallink-log-sometimes-require-start-value</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/657665/why-does-glm-in-r-with-family-binomiallink-log-sometimes-require-start-value</guid>
      <pubDate>Fri, 22 Nov 2024 09:25:45 GMT</pubDate>
    </item>
    </channel>
</rss>