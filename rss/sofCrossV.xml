<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Sun, 01 Sep 2024 06:22:29 GMT</lastBuildDate>
    <item>
      <title>$\log\Gamma(x)$ 的期望，其中 $x$ 是对数正态分布</title>
      <link>https://stats.stackexchange.com/questions/653690/expectation-of-log-gammax-where-x-is-log-normal</link>
      <description><![CDATA[我试图在 gamma-gamma 模型上建立变分推理：
$$f(\alpha, Y) =\prod_{i=1}^n\text{Gamma}(y_i\mid\alpha,1)\times\text{Gamma}(\alpha\mid a, b)$$
ELBO 或证据下限是我们在变分推理中试图最大化的值（因为 ELBO + KL 散度加起来等于一个固定量，即“证据”。因此最大化 ELBO 相当于最小化 KL 散度。ELBO 的形成如下：
$$
\text{ELBO} = \text{E}_q\left[\log f(\alpha, Y) - \log q(\alpha)\right]
$$
然后通过对 $q$ 的参数进行区分，我们找到梯度，并可以对其进行优化。无论如何，
设 $q(\alpha) = \text{LogNormal}(\alpha\mid\mu,\sigma)$，ELBO 中的所有项都有相对简单的闭式期望。除了：$n\log\Gamma(\alpha)$。
有没有办法让这个积分以近似闭式的形式工作？
$$
\text{E}_q[\log\Gamma(\alpha)] = \int_0^{\infty}\log\Gamma(\alpha)\frac{1}{\alpha\sigma\sqrt{2\pi}}\exp\left\lbrace-\frac{1}{2\sigma^2}\left(\log(\alpha) - \mu\right)^2\right\rbrace \text{d}\alpha
$$
我尝试了 Stirling 的近似值 $\log\Gamma(x)$，令我惊讶的是，随着更多项的添加，它变得越来越糟。不幸的是，近似值的质量在 $x &lt; 1$ 时会下降，在接近 0 时变得非常糟糕。]]></description>
      <guid>https://stats.stackexchange.com/questions/653690/expectation-of-log-gammax-where-x-is-log-normal</guid>
      <pubDate>Sun, 01 Sep 2024 02:57:47 GMT</pubDate>
    </item>
    <item>
      <title>顺序统计概率 [重复]</title>
      <link>https://stats.stackexchange.com/questions/653689/order-statistic-probability</link>
      <description><![CDATA[如果问题询问 P(Y_{2} &lt; 2 &lt; Y_{4}) ，我该如何找到。其中 Y 是顺序统计量，Y1&lt;Y2&lt;Y3&lt;Y4&lt;Y5。]]></description>
      <guid>https://stats.stackexchange.com/questions/653689/order-statistic-probability</guid>
      <pubDate>Sun, 01 Sep 2024 02:55:18 GMT</pubDate>
    </item>
    <item>
      <title>紧急帮助使用什么统计测试来比较 A 组和 B 组以查看谁的效果更好并且两者都随着时间的推移进行了重复测量</title>
      <link>https://stats.stackexchange.com/questions/653688/urgent-help-on-what-statistical-test-to-use-for-comparing-group-a-and-group-b-to</link>
      <description><![CDATA[对于我的主要目标，我回答了我的假设，即在 150 个样本中，腋窝淋巴结厚度的变化是有影响的，并且根据箱线图会减少。我使用配对 t 检验来测试 (T6-T0) 的统计差异。其中 T6 是 6 个月后时间点的淋巴结厚度测量值，T0 是接种 Covid-19 疫苗后（接种疫苗后 12 周内）的淋巴结厚度。
参与者 A 进行了 T0 和 T6 扫描。
总样本量为 150 名参与者。
如果我想回答这种变化现象是否更多地发生在 0-54 岁（第 1 组）而不是 55-99 岁（第 2 组）中，我对要回答什么统计分析有点困惑？
一个简单的原始数据表可以帮助我确定我应该如何进行此操作？ （实际上我有 150 名参与者）
参与者 A= 0-54 岁组
参与者 B= 55-99 岁组
参与者分组 T0 淋巴结厚度（mm）T6 淋巴结厚度（mm）
参与者 A 5 3.8
参与者 A 4.2 2.1
参与者 B 3.8 1.7
参与者 A 4.2 2.8
参与者 B 5.0 3.2
为了进一步说明，
如果我设法将它们分成以下组，
参与者 A= 0-54 岁组
参与者 B= 55-99 岁组
表 1：参与者分组 T0 厚度（mm）T6 厚度（mm）
参与者 A 5 3.8
参与者 A 4.2 2.1
参与者 A 4.2 2.8
表 2：参与者分组 T0 厚度（mm） T6 厚度（mm）
参与者 B 3.8 1.7
参与者 B 5.0 3.2
我能否比较 A 组的 (T6-T0) 平均值是否高于/低于 B 组的 (T6-T0) 平均值？
如果假设 A 组的 (T6-T0) 为 3.0，而 B 组的 (T6-T0) 为 2.0，我能否得出结论，6 个月后淋巴结厚度的变化在 A 组中发生得更多？（因为 3.0 高于 2.0）。]]></description>
      <guid>https://stats.stackexchange.com/questions/653688/urgent-help-on-what-statistical-test-to-use-for-comparing-group-a-and-group-b-to</guid>
      <pubDate>Sun, 01 Sep 2024 02:13:05 GMT</pubDate>
    </item>
    <item>
      <title>订单统计 [关闭]</title>
      <link>https://stats.stackexchange.com/questions/653687/order-statistic</link>
      <description><![CDATA[如果问题询问 P(Y_{2} &lt; 2 &lt; Y_{4}) ，我该如何找到。其中 Y 是顺序统计量，Y1&lt;Y2&lt;Y3&lt;Y4&lt;Y5。]]></description>
      <guid>https://stats.stackexchange.com/questions/653687/order-statistic</guid>
      <pubDate>Sun, 01 Sep 2024 01:38:56 GMT</pubDate>
    </item>
    <item>
      <title>逻辑回归给出的 AUC 比朴素贝叶斯高得多的场景</title>
      <link>https://stats.stackexchange.com/questions/653685/scenarios-where-logistic-regression-gives-much-higher-auc-than-naive-bayes</link>
      <description><![CDATA[据我所知，在预测变量之间不存在协变的情况下，逻辑回归和朴素贝叶斯在预测准确性方面应该给出几乎相同的结果（以 ROC/AUC 等为衡量标准）。
我试图将此与使用逻辑回归比朴素贝叶斯对一组模拟数据的预测准确性高得多的观察结果相协调。
简而言之，我正在模拟一个非常简单的基因型-表型图模型，其中有 n 个位点（基因座）i=1...n，每个位点都有 0 或 1 个等位基因，概率为 p_i。在每个基因座上，0 等位基因对应于“野生型”，1 对应于“风险”，即第 i 个位点的 1 等位基因与比值比 OR_i &gt; 相关1. 每种基因型的疾病（或某种二元表型）风险是通过计算所有位点的 OR_i 乘积来计算的，并且对照/疾病表型的概率与某个基线值的 OR 成比例。请注意，在这个最简单的情况下，每个位点的影响在统计上是独立的，即 OR 在各个位点之间相乘。
尽管如此，对于这个基因型-表型图的简单乘法模型，我始终发现逻辑回归分类器的 AUC 比使用朴素贝叶斯的分类器高得多（我在 R 中使用 glm family=binomial 执行逻辑回归，并在 e1071 R 库中使用 naiveBayes 函数，两者均采用默认设置）。
我试图找出逻辑回归性能更好的合理解释。]]></description>
      <guid>https://stats.stackexchange.com/questions/653685/scenarios-where-logistic-regression-gives-much-higher-auc-than-naive-bayes</guid>
      <pubDate>Sat, 31 Aug 2024 22:33:31 GMT</pubDate>
    </item>
    <item>
      <title>创建带有集群引导程序的 lm 类对象（R），或者：sensemakr 的集群引导程序（）[关闭]</title>
      <link>https://stats.stackexchange.com/questions/653681/create-lm-class-object-with-cluster-bootstrap-in-it-r-or-cluster-bootstrap-f</link>
      <description><![CDATA[我一直在尝试使用 lm 进行一些集群引导，然后可以在包 sensemakr() 中使用它。如果您不熟悉它，它是 Cinelli &amp; 中一些想法的实现Hazlett（2020 年，皇家统计学会杂志：统计方法，B 系列）。
sensemakr() 的工作方式是运行一个回归模型，该模型生成 lm 或 feols 类对象，然后可以在 sensemakr() 中使用该对象。
library(palmerpenguins)
library(sensemakr)

penguin_dat&lt;-penguins

model_lm&lt;-lm(flipper_length_mm ~ sex + body_mass_g, data=penguin_dat)
summary(model_lm)

sensitivity1&lt;-sensemakr(model=model_lm, treatment=&quot;body_mass_g&quot;, benchmark_covariates=&quot;sexmale&quot;)
summary(sensitivity1)

我需要找到一种将具有更复杂错误结构的模型传递给 sensemakr 的方法，特别是具有聚类引导程序的模型。它目前采用 lm 模型，但我读到，如果您愿意使用开发版本，您可以尝试将 feols 模型从 fixest 传递给它（请参阅：https://stackoverflow.com/questions/78363310/use-sensemakr-with-fixest-feols-model-r）。不过，我自己还没有尝试过。
以下是我考虑过的选项：

将我之前的 lm 类对象（上一个示例中的 model_lm）用于 simpleboot 中的 lm.boot()，然后在 sensemakr 中使用该对象。问题：我在 simpleboot 中找不到 cluster-bootstrap 的任何功能。我担心我可能忽略了某些东西——我希望我只是忽略了这个功能，因为它可能是最简单的解决方案。
使用 fwildclusterboot 中的 wild cluster bootstrap。我不确定它会产生什么对象，并且由于依赖性问题，它已从 CRAN 中删除，因此我无法安装它（或查看参考手册）。
使用集群引导包（如 clusbootglm 或 lmeresampler），然后尝试将结果强制转换为 lm 类型对象。这有点超出我的 R 能力，但如果 #1 不起作用，我认为它可能是唯一的选择。
作为 #3 的示例，这里有一个使用 lmtest 中的 coeftest() 和 sandwich 中的 vcovBS() 的示例——但我不知道如何将其强制转换为 lm 对象，或者即使这是不是一个好主意：

library(palmerpenguins)
library(sandwich)
library(sensemakr)
library(lmtest)

penguin_dat&lt;-penguins

model_lm&lt;-lm(flipper_length_mm ~ sex + body_mass_g, data=penguin_dat)

clustered_bootstrap_model_lm&lt;-coeftest(model_lm, vcov = vcovBS, cluster = penguin_dat$species, R = 1000)


具有讽刺意味的是， sensemakr() 也在 Stata 中实现了这一点，并且执行聚类引导然后在另一个命令中使用标准错误非常简单。
sysuse auto2.dta
regress price mpg weight rep78, vce(bootstrap, reps(100)) cluster(foreign)
est sto m1

但是 Stata 实现不允许您传递模型，而是让您在 sensemakr 本身内运行回归……当您这样做时，它不允许更复杂的错误结构。
有人对如何做到这一点有什么想法吗？我非常感谢你能给出的任何建议。
引用：
Cinelli, C., &amp; Hazlett, C. (2020). 理解敏感性：扩展遗漏变量偏差。英国皇家统计学会杂志 B 系列：统计方法，82(1)，39-67。https://doi.org/10.1111/rssb.12348
Cinelli, C.、Ferwerda, J. 和 Hazlett, C. (2020)。sensemakr：R 和 Stata 中 OLS 的敏感性分析工具。可在 SSRN 上获取：https://ssrn.com/abstract=3588978 或 http://dx.doi.org/10.2139/ssrn.3588978]]></description>
      <guid>https://stats.stackexchange.com/questions/653681/create-lm-class-object-with-cluster-bootstrap-in-it-r-or-cluster-bootstrap-f</guid>
      <pubDate>Sat, 31 Aug 2024 18:54:32 GMT</pubDate>
    </item>
    <item>
      <title>ARIMA 模型系数估计</title>
      <link>https://stats.stackexchange.com/questions/653678/estimation-of-model-coefficients-of-arima-model</link>
      <description><![CDATA[假设我在 R 中有以下 ARIMA 模型估计
&gt; arima(x = LakeHuron, order = c(0,0,1), xreg = time(LakeHuron) - 1920)

调用：
&gt; arima(x = LakeHuron, order = c(0, 0, 1), xreg = time(LakeHuron) - 1920)

调用：
arima(x = LakeHuron, order = c(0, 0, 1), xreg = time(LakeHuron) - 1920)

系数：
ma1 截距时间(LakeHuron) - 1920
0.7822 579.0821 -0.0233
s.e. 0.0651 0.1400 0.0049

但是，我还分别使用线性回归计算了外生变量和自相关残差的模型系数，如下所示
&gt; model_lm = lm(&#39;y~x&#39;, data = data.frame(x = time(LakeHuron) - 1920, y = LakeHuron))
&gt; model_Res = lm(&#39;y~x-1&#39;, data.frame(y = resid(model_lm), x = c(NA, resid(model_lm)[-length(LakeHuron)])))
&gt; summary(model_lm )

调用：
lm(formula = &quot;y~x&quot;, data = data.frame(x = time(LakeHuron) - 1920, 
y = LakeHuron))

残差：
最小值 1Q 中值 3Q 最大值 
-2.50997 -0.72726 0.00083 0.74402 2.53565 

系数：
估计标准误差 t 值 Pr(&gt;|t|) 
(截距) 579.088786 0.115047 5033.507 &lt; 2e-16 ***
x -0.024201 0.004036 -5.996 3.55e-08 ***
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：96 个自由度上的 1.13

多重 R 平方：0.2725，调整后的 R 平方：0.2649

F 统计量：1 和 96 DF 上的 35.95，p 值：3.545e-08

&gt; summary(model_Res )

调用：
lm(formula = &quot;y~x-1&quot;, data = data.frame(y = resid(model_lm), 
x = c(NA, resid(model_lm)[-length(LakeHuron)])))

残差：
最小值 1Q 中值 3Q 最大值 
-1.94335 -0.48386 0.01758 0.43251 1.91083 

系数：
估计标准误差 t 值 Pr(&gt;|t|) 
x 0.79084 0.06556 12.06 &lt;2e-16 ***
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残差标准误差：96 个自由度上的 0.7125
（由于缺失，删除了 1 个观察值）
多重 R 平方：0.6025，调整后的 R 平方：0.5984

F 统计量：1 和 96 DF 上的 145.5，p 值：&lt; 2.2e-16

这两种方法似乎给出了类似的结果。但是我想知道从理论上讲，对于任何数据，情况是否总是如此？哪种方法更好，为什么？
我还有一个问题，我正在使用 MA 模型，在第二种方法中，我应该使用 自相关调整 SE 而不是正常 SE 吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/653678/estimation-of-model-coefficients-of-arima-model</guid>
      <pubDate>Sat, 31 Aug 2024 18:05:26 GMT</pubDate>
    </item>
    <item>
      <title>说统计模型是位置家族是什么意思？</title>
      <link>https://stats.stackexchange.com/questions/653675/what-does-it-mean-to-say-that-a-statistical-model-is-a-location-family</link>
      <description><![CDATA[我想知道说统计模型是位置族是什么意思。查看了一些定义，我得出了位置族定义的三种可能解释。
设$(\mathbb{R},\mathfrak{B}_\mathbb{R},P_\theta )_{\theta\in\Theta }$为一个统计模型，其中$\mathfrak{B}_\mathbb{R}$表示$\mathbb{R}$的 Borel $\sigma$-代数。对于所有 $\theta$，定义 $F_\theta :\mathbb{R\to R}$ 为 $F_\theta (x):=P_\theta ((-\infty ,x])$。
我的问题：下列哪个定义是正确的？
定义 1： 我们说 $(\mathbb{R},\mathfrak{B}_\mathbb{R},P_\theta )_{\theta\in\Theta }$ 是一个位置族，如果对于任何 $\theta\in\Theta$ 并且 $a\in\mathbb{R}$ 函数 $F:\mathbb{R}\to \mathbb{R}$ 由 $F(x):=F\!_{\theta} (x+a)$ 给出，属于集合 $\{F_\theta\}_{\theta\in\Theta }$。
定义 2： 我们说 $(\mathbb{R},\mathfrak{B}_\mathbb{R},P_\theta )_{\theta\in\Theta }$ 是一个位置族，如果存在 $\theta_0\in\Theta$，使得对于所有 $\theta\in\Theta$，都有 $a_\theta \in\mathbb{R}$，使得对于所有 $x\in\mathbb{R}$，都有 $F_\theta (x)=F_{\theta_0}(x-a_\theta )$。
定义 3：我们说 $(\mathbb{R},\mathfrak{B}_\mathbb{R},P_\theta )_{\theta\in\Theta }$ 是位置族，如果存在 $\theta_0\in\Theta$，使得以下命题为真：

对于所有 $a\in\mathbb{R}$，由 $F(x):=F\!_{\theta_0} (x+a)$ 给出的函数 $F:\mathbb{R}\to \mathbb{R}$ 属于集合 $\{F_\theta\}_{\theta\in\Theta }$；$\theta\in\Theta$ 存在 $a_\theta \in\mathbb{R}$ 使得对于所有 $x\in\mathbb{R}$，$F_\theta (x)=F_{\theta_0}(x-a_\theta )$。

例如，使用定义 2，很容易得出统计模型 $ (\mathbb{R},\mathfrak{B}_\mathbb{R},N(\mu ,\sigma ^2))_{\mu \in\mathbb{R}}$（其中 $\sigma^2&gt;0$ 固定）是一个位置系列。]]></description>
      <guid>https://stats.stackexchange.com/questions/653675/what-does-it-mean-to-say-that-a-statistical-model-is-a-location-family</guid>
      <pubDate>Sat, 31 Aug 2024 17:25:13 GMT</pubDate>
    </item>
    <item>
      <title>MatchIt 边际效应</title>
      <link>https://stats.stackexchange.com/questions/653667/matchit-marginal-effects</link>
      <description><![CDATA[我正尝试使用 MatchIt 估计治疗的 ATT，但不确定它是边际效应还是条件效应。在估计结果的插图中，它说：

此外，对于连续结果，当结果模型中存在治疗-协变量相互作用时，条件效应可能会被错误地解释为边际效应估计。如果协变量不是以目标人群中的平均值为中心（例如，ATT 的治疗组、ATE 的完整样本或 ATM 的剩余匹配样本），治疗系数将不对应于目标人群中的边际效应；它将对应于协变量值等于零时的治疗效果，这可能没有意义或不合理。当结果模型中包含协变量时，G 计算始终是估计效应的最安全方法，尤其是在存在治疗-协变量相互作用的情况下。

在这里，结果是连续的，在结果模型中，我有一个二元治疗、匹配变量 X（全部连续）和一个相互作用。由于我正在使用 G-Computation（我认为），这是否估计了边际效应？
m &lt;- matchit(D ~ X,
data = data,
method = &quot;cem&quot;, 
estimand = &quot;ATT&quot;, 
k2k = FALSE)

matchdata &lt;- match.data(m)

fit &lt;- lm(Y ~ D + X + D * X,
data = matchdata, weights = weights)

avg_comparisons(fit, variable = &quot;D&quot;,
vcov = &quot;HC3&quot;, 
newdata = subset(matchdata, D == 1),
wts = &quot;weights&quot;) 
]]></description>
      <guid>https://stats.stackexchange.com/questions/653667/matchit-marginal-effects</guid>
      <pubDate>Sat, 31 Aug 2024 09:50:38 GMT</pubDate>
    </item>
    <item>
      <title>在线性回归下推导 MSE($\hat{\beta}$)</title>
      <link>https://stats.stackexchange.com/questions/653651/deriving-mse-hat-beta-under-linear-regression</link>
      <description><![CDATA[我能够推导出 MSE，但是推导过程中有一部分我不太明白。这是我得到的结果：
事实：

$\mathbb{E}(​​\hat{\beta})=\hat{\beta}\space$（无偏估计量）
$\text{Cov}(\hat{\beta})= \sigma^2[(X^TX)^{-1}] $

根据定义，
$$MSE = \mathbb{E}[||\hat{\beta}-\beta||^2] $$
$$= \space \mathbb{E}[(\hat{\beta}-\beta)^T(\hat{\beta}-\beta)]$$
由于 $\hat{\beta}$ 是无偏的，
$$ \boldsymbol{= \text{tr}[\text{Cov}(\hat{\beta})]} *$$
$$= \text{tr}[\sigma^2(X^T X)^{-1}]$$
$\sigma^2$ 是标量，因此可以分解出来，
$$= \sigma^2 tr[(X^T X)^{-1}] $$
我感到困惑的是行 $*$，我不确定我们是如何得到方程式 $ \text{tr}[\text{Cov}(\hat{\beta})] $。以下是我目前所理解的：
通过偏差-方差分解，
$$ \space \mathbb{E}[(\hat{\beta}-\beta)^T(\hat{\beta}-\beta)]=\mathbb{V}(\hat{\beta})+[\mathbb{E}(​​\hat{\beta})-\beta]^T[\mathbb{E}(​​\hat{\beta})-\beta]$$
我们的估计量是无偏的，因此 $\mathbb{E}(​​\hat{\beta})-\beta= 0$。因此，
$$\mathbb{E}[(\hat{\beta}-\beta)^T(\hat{\beta}-\beta)]=\mathbb{V}(\hat{\beta})$$

首先，$\mathbb{V}(\hat{\beta})$ 应该是一个标量，但对我来说这真的没什么意义，这让我想到了下一个问题...
我假设 $V(\hat{\beta}) = \text{tr}[\text{Cov}(\hat{\beta})]$。这是为什么呢？
]]></description>
      <guid>https://stats.stackexchange.com/questions/653651/deriving-mse-hat-beta-under-linear-regression</guid>
      <pubDate>Sat, 31 Aug 2024 00:13:56 GMT</pubDate>
    </item>
    <item>
      <title>在 MCMC 中转换变量以获得与提议相匹配的先验分布</title>
      <link>https://stats.stackexchange.com/questions/653598/transforming-variables-within-mcmc-to-get-the-prior-distribution-to-match-propos</link>
      <description><![CDATA[我正在做贝叶斯 MCMC，我建议使用一些权重，比如狄利克雷分布中的 a_1:a_5，以确保总和为 1。但是，先前的（Beta）分布是基于这些权重的一些计算，b_1:b_5。我的理解是我应该进行转换。以下是 a 和 b 之间的关系：
a_1=b_1
a_2=(1-b_1)(b_2)
a_3=(1-b_1)(1-b_2)b_3
a_4=(1-b_1)(1-b_2)(1-b_3)b_4
a_5=(1-b_1)(1-b_2)(1-b_3)(1-b_4)b_5

我发现雅可比矩阵为：$(b_1 - 1)^4 \times (b_2 - 1)^3 \times (b_3 - 1)^2 \times (b_4 - 1)$
但我不确定接下来该怎么做。当找到先验密度时，我是否将输入乘以这个雅可比矩阵？下面是我的 R 代码，好像我忽略了先前和提议之间的不匹配。
 a&lt;-rDirichlet.acomp(1,mcmc_chain_weights[i,1:5]*(tuning_parameter))
b=rep(NA,5)
b[1]&lt;-a[1]
b[2]&lt;-a[2]/((1-b[1]))
b[3]&lt;-a[3]/((1-b[1])*(1-b[2]))
b[4]&lt;-a[4]/((1-b[1])*(1-b[2])*(1-b[3]))
b[5]&lt;-a[5]/((1-b[1])*(1-b[2])*(1-b[3])*(1-b[4]))

Hastings_ratio&lt;-L()*dbeta(b,1,tau)*dDirichlet(a_previous,alpha=a) / ...

请注意，tau 是一个常数，我将似然函数留空，因为它在这里无关紧要。任何帮助都将不胜感激。谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/653598/transforming-variables-within-mcmc-to-get-the-prior-distribution-to-match-propos</guid>
      <pubDate>Fri, 30 Aug 2024 03:22:33 GMT</pubDate>
    </item>
    <item>
      <title>测量两组内部距离差异的重要性</title>
      <link>https://stats.stackexchange.com/questions/653500/measure-the-significance-of-differences-in-internal-distances-in-two-groups</link>
      <description><![CDATA[我是一名语言学家，正在研究 169 名挪威女性作家和 169 名挪威男性作家的语法变异（使用树库），该变异基于八个屈折和句法属性。这八个属性是两种表达类别的备选方式之间的八个二元选择，称为“保守”和“激进”。对于给定属性，记录的是作者保守选择的百分比。因此，它将是 0 到 100 之间的值。因此，这八个属性定义了作者分布的八维空间。然后可以像往常一样计算任何两个作者之间的（欧几里得）距离，取点坐标平方差之和的平方根。两组之间的一个显着差异（在各个属性之间都稳定）是，在八维可能性空间中，男性比女性分散得更多，女性聚集得更密集，选择组合的变化较少。我计算一个群体的密度作为内部距离的平均值——即取每个群体成员与群体中其他作者的平均距离的平均值。该图显示了女性和男性与同性别其他成员的平均距离。男性的平均值为 69（标准差 16.6），女性的平均值为 60（标准差 15.3）。t 检验可以极高置信度地得出显著性，但——不是统计学家——我对 t 检验的适用性表示怀疑。群体成员的数值是相互依赖的，因此我们测试的是性别群体作为整体的属性，而不是两个群体中每个成员的可比属性。因此，我的问题是：是否有适合这种数据的显著性检验——或者我错误地认为 t 检验不合适（这很好）？评论中提到的表格：



作者
F1
F2
F3
F4
F5
F6
F7
F8




author1
92,1
98
 99,2
26,7
71,3
56,8
80
22,7


author2
55,2
73
93,1
6,4
30,9
49,2
37,2
23,8


作者3
97
99,7
100
49
99,1
62,8
86
39,7


作者4
99,5
98,7
100
6,5
50, 3
61,8
51
20,6


author5
23,2
37,9
99,9
5,6
27,2
78,4
57,8
28



]]></description>
      <guid>https://stats.stackexchange.com/questions/653500/measure-the-significance-of-differences-in-internal-distances-in-two-groups</guid>
      <pubDate>Wed, 28 Aug 2024 18:39:51 GMT</pubDate>
    </item>
    <item>
      <title>如何获取 GEE 模型的主要效果并跨插补数据集 R 进行合并</title>
      <link>https://stats.stackexchange.com/questions/653581/how-can-i-get-the-main-effects-of-a-gee-model-and-pool-across-imputed-datasets-r</link>
      <description><![CDATA[使用 mice，我估算了 5 个数据集，并将它们作为列表存储在 data_list 中。我想使用具有可交换相关结构的 GEE 模型，根据 baseline_status（3 个级别：A、B、C）预测存储在 vars_cont 中的结果（education_level、children、bmi）。在 GEE 模型之后，我想汇总 5 个估算数据集的结果。这适用于以下代码
# 函数在 data_list 的每个估算数据集中运行 gee 模型
model_cont &lt;- function(x) {
lapply(data_list, function(y)
geeglm(as.formula(paste(x, &quot;~ baseline_status&quot;)), 
family = &quot;gaussian&quot;, 
id = ID, 
data = y, 
corstr = &quot;exchangeable&quot;)
)
}

models_contC &lt;- as.list(seq(1,
length(exposures[exposures %in% vars_cont]))) 
# 创建列表以存储模型结果
names(models_contC) &lt;- Exposures[exposures %in% vars_cont] 
# 名称曝光
models_contC &lt;- pblapply(exposures[exposures %in% vars_cont], 
model_cont) # 运行

# 池化插补模型 
pool_contC &lt;- as.list(seq(1, 
length(exposures[exposures %in% vars_cont]))) 
# 创建列表以存储池化结果
names(pool_contC) &lt;- 曝光[exposures %in% vars_cont] 
# 命名曝光

for(j in seq_along(exposures[exposures %in% vars_cont])) {
pool_contC[[j]] &lt;- pool(models_contC[[j]])
}

我遇到的问题是，gee 的输出给了我两个效果基线状态 B (与 A 对比) 和 C (与 A 对比) 的效果对比。我想要基线状态的主要效果。我可以使用获得主效应
models_contC_aov &lt;- as.list(seq(1, 
length(exposures[exposures %in% vars_cont]))) 
# 创建列表以存储模型结果
names(models_contC_aov) &lt;- Exposures[exposures %in% vars_cont] 
# 命名曝光

models_contC_aov &lt;- lapply(models_contC, function(model_list) {
lapply(model_list, function(model) {
aov(model$formula, data = model$data)
})
})

但现在我无法在 5 个估算数据集中汇总这些主效应。如何获得 baseline_status 的汇总主效应？
# 可重现数据

# 为可重现性设置种子
set.seed(123)

n &lt;- 100

baseline_status &lt;- sample(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), n, replace = TRUE)

generate_data &lt;- function(n = 100, baseline_status) {
data.frame(
ID = 1:n,
education_level = sample(1:4, n, replace = TRUE), 
# 教育水平编码为 1 到 4
children = sample(0:5, n, replace = TRUE), 
# 0 到 5 岁的儿童人数
bmi = round(rnorm(n, mean = 25, sd = 4), 1),
# BMI 平均值为 25，标准差为 4
baseline_status = baseline_status 
# 基线状态一致
)
}

data_list &lt;- lapply(1:5, function(x) generate_data(n = n, 
baseline_status = baseline_status))

names(data_list) &lt;- paste0(&quot;imp&quot;, 1:5)
]]></description>
      <guid>https://stats.stackexchange.com/questions/653581/how-can-i-get-the-main-effects-of-a-gee-model-and-pool-across-imputed-datasets-r</guid>
      <pubDate>Wed, 28 Aug 2024 08:45:30 GMT</pubDate>
    </item>
    <item>
      <title>微观经济模型中的截断分布和风险率</title>
      <link>https://stats.stackexchange.com/questions/652853/truncated-distribution-and-hazard-rates-in-a-microeconomic-model</link>
      <description><![CDATA[我试图证明与劳动微观经济模型相关的一些内容：
t∈{1,2,3}，A∼N(0,1)（A 在各个时期内是固定的），
εt∼N(0,1)（εt 对于每个 εt 都是独立的），
c&gt;0 是从容易的工作晋升到困难的工作的临界点（它们只有两种工作）。
我试图表明，对于同一批人，t=3 时从事困难工作的工人的预期值大于 t=2 时从事困难工作的工人的预期值。含义：
E[A+ε3|(A+ε1&gt;c) ^ (A+ε2&gt;c)] &gt; E[A+ε2|A+ε1&gt;c]
（直观上看很明显，这是同一个组——第一次有一个限制，第二次有两个限制）。
我尝试用截断分布和风险率来解决这个问题：
如果我没记错的话，以 A+ϵt&gt;c 为条件的变量 A+ϵt 的截断正态分布由以下公式给出：λ(c)=ϕ(c)/( 1−Φ(c))，即风险率。
现在，我不确定如何处理 E[A+ε3|(A+ε1&gt;c) ^ (A+ε2&gt;c)]，它等于 λ(√c)、λ(√2c) 还是 2λ(c)？
我迷失在试图以某种方式证明它的过程中，我想也许有人可以帮忙我。]]></description>
      <guid>https://stats.stackexchange.com/questions/652853/truncated-distribution-and-hazard-rates-in-a-microeconomic-model</guid>
      <pubDate>Thu, 15 Aug 2024 09:49:29 GMT</pubDate>
    </item>
    <item>
      <title>具有空值的互相关函数</title>
      <link>https://stats.stackexchange.com/questions/652842/cross-correlation-function-with-null-values</link>
      <description><![CDATA[我正在分析与另一个特征的上升趋势相关的特征。为了消除噪音，我删除了除因变量 y 呈上升趋势的日期之外的所有日期，例如 7 天的时间段。对于我的独立变量，我查看的是 y 呈上升趋势的同一周，加上前两周，总共 21 天。
当我计算时间序列的互相关函数时，我的系数为 NaN，因为 7 天周期开始前两周对于因变量来说为空，因为它们不在趋势周期内。
为了便于理解，我使用了模仿 r ccf 函数的这个 python 函数：
from scipy import signal
import numpy as np
import pandas as pd

def ccf_values(series1, series2):
p = series1
q = series2
p = (p - np.mean(p)) / (np.std(p) * len(p))
q = (q - np.mean(q)) / (np.std(q)) 
c = np.correlate(p, q, &#39;full&#39;)
返回 c

ccf = ccf_values(df[&#39;y&#39;], df[&#39;x&#39;])
lags = signal.correlation_lags(len(df[&#39;y&#39;]), len(df[&#39;x&#39;]))
]]></description>
      <guid>https://stats.stackexchange.com/questions/652842/cross-correlation-function-with-null-values</guid>
      <pubDate>Thu, 15 Aug 2024 05:09:20 GMT</pubDate>
    </item>
    </channel>
</rss>