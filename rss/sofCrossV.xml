<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Fri, 22 Dec 2023 00:59:51 GMT</lastBuildDate>
    <item>
      <title>关于数据对数转换的有趣观察</title>
      <link>https://stats.stackexchange.com/questions/635466/an-interesting-observation-regarding-the-log-transformation-of-data</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/635466/an-interesting-observation-regarding-the-log-transformation-of-data</guid>
      <pubDate>Fri, 22 Dec 2023 00:42:00 GMT</pubDate>
    </item>
    <item>
      <title>不同状态下具有不同发射分布的 HMM 参数估计</title>
      <link>https://stats.stackexchange.com/questions/635465/parameter-estimation-for-hmm-with-different-emission-distribution-for-different</link>
      <description><![CDATA[我正在尝试解决参数估计问题，其中 HMM 对于不同状态具有不同的发射分布（即一个状态为高斯分布，另一种状态为指数分布）。然而，大多数使用 EM 算法的标准方法都假设相同的分布（例如仅高斯分布），其中可以显式评估 M 步骤。
我不太确定在多个依赖于状态的排放分布的情况下如何评估 M 步骤，并且我们将不胜感激！]]></description>
      <guid>https://stats.stackexchange.com/questions/635465/parameter-estimation-for-hmm-with-different-emission-distribution-for-different</guid>
      <pubDate>Fri, 22 Dec 2023 00:35:20 GMT</pubDate>
    </item>
    <item>
      <title>我们可以从置信区间推导出 2 类错误概率吗？</title>
      <link>https://stats.stackexchange.com/questions/635464/can-we-derive-type-2-error-probability-from-confidence-interval</link>
      <description><![CDATA[如果我们可以计算估计值的置信区间$\hat{\theta}$，然后我们还可以计算相关假设$\hat{\theta}=\theta_0$&lt; /a&gt;，这是特定样本出现 1 类错误的概率（即，当假设正确时拒绝假设）。
我们是否还可以使用这些置信区间来获取该假设和样本出现 2 类错误的概率（即，当假设不正确时接受该假设）？
直观上，我们似乎应该能够做到这一点，因为较窄的置信区间与更强大的测试成正比，这（根据定义）是较低的 2 类错误概率。]]></description>
      <guid>https://stats.stackexchange.com/questions/635464/can-we-derive-type-2-error-probability-from-confidence-interval</guid>
      <pubDate>Fri, 22 Dec 2023 00:19:57 GMT</pubDate>
    </item>
    <item>
      <title>如果两者都与第三个变量存在关系，为什么控制对撞机会打开一条路径，而控制混杂因素则会关闭一条路径？</title>
      <link>https://stats.stackexchange.com/questions/635463/why-does-controlling-for-a-collider-open-a-path-while-controlling-for-a-confoun</link>
      <description><![CDATA[当X和Y之间没有关联时，但是当由X和Y引起的第三个变量受到控制时，就会发生碰撞偏差，这“打开了一条路径”。 X 和 Y 之间的关系，并导致有偏差的估计/扭曲的关联。

同时，如果您控制混杂因素（导致 X 和 Y 的第三个变量），它会关闭路径，并删除 X 和 Y 之间的关联。

令我困惑的一个方面是，如果 X 和 Y 与混杂因素和碰撞器的第三个变量相关，为什么在一个实例中控制它会打开路径（碰撞器）并在另一个例子中关闭路径（混杂因素）？为什么X和Y引起Z意味着控制它打开路径，而如果X和Y由Z引起，控制它关闭路径？这是我有点难以理解的区别，因为在这两种情况下，它们都与 Z/第三个变量相关。]]></description>
      <guid>https://stats.stackexchange.com/questions/635463/why-does-controlling-for-a-collider-open-a-path-while-controlling-for-a-confoun</guid>
      <pubDate>Thu, 21 Dec 2023 23:54:57 GMT</pubDate>
    </item>
    <item>
      <title>保留任意两个值之间的比率的缩放</title>
      <link>https://stats.stackexchange.com/questions/635462/scaling-that-preserves-the-ratio-between-any-two-values</link>
      <description><![CDATA[是否有一个函数 $f$ 使得对于所有 $x$ （在 有界域）：

$f(x) \in [a,b]$
$r \times f(x) = f(rx)$

如果这让事情变得更容易，我们可以假设 $\forall x: x \geq 0$。虽然更通用的解决方案会很好。]]></description>
      <guid>https://stats.stackexchange.com/questions/635462/scaling-that-preserves-the-ratio-between-any-two-values</guid>
      <pubDate>Thu, 21 Dec 2023 23:34:17 GMT</pubDate>
    </item>
    <item>
      <title>随机对照试验需要因果图吗？</title>
      <link>https://stats.stackexchange.com/questions/635460/causal-diagrams-necessary-in-randomized-controlled-trials</link>
      <description><![CDATA[我理解正确管理的随机对照试验如何排除混杂因素，因为除了随机化（意味着从结果到治疗变量没有后门路径）之外，没有任何变量影响治疗/对照组分配。
这是否意味着在进行 RCT 时，无需像观察性因果推理研究那样绘制因果图 (DAG) 来识别混杂因素、碰撞因素、中介因素等？
在特殊情况下您会想要花时间构建 DAG 吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635460/causal-diagrams-necessary-in-randomized-controlled-trials</guid>
      <pubDate>Thu, 21 Dec 2023 22:03:22 GMT</pubDate>
    </item>
    <item>
      <title>具有缺失值的向量化线性回归</title>
      <link>https://stats.stackexchange.com/questions/635458/vectorized-linear-regression-with-missing-values</link>
      <description><![CDATA[我有一些关于在矩阵/数组运算期间处理丢失数据的问题。本质上，我正在做一个向量化线性回归，以在一些矩阵/数组运算中执行一堆线性回归。对于形状为 (2, 50, 3) 和 (2, 50) 的随机数据 X_many 和 y_many，我使用以下代码来估计系数矩阵：
X_op = np.einsum(&#39;ikj,ilj-&gt;ilk&#39;, (np.linalg.inv(np.einsum(&#39;ikj,ikl-&gt;ilk)) ijl&#39;，X_many，X_many））），X_many）
Beta_hat = np.einsum(&#39;ikj,ik-&gt;ij&#39;, X_op, y_many)

这里的问题是 X_many 缺少一些值。具体来说，在某些组中，某些变量值是完全不可用的。当我使用这些缺失值运行上面的代码时，矩阵中的整行系数都是 nan 。但是，如果我逐一进行回归，我可以忽略缺失值，估计一组系数，然后假设缺失值系数为 0。这样我仍然可以进行估计，但数据较少，因为一些系数将为 0（参见下面的代码）：
对于 zip 中的 x_i, y_i(X_many, y_many)：
    x_i = x_i[:, np.isfinite(x_i.sum(axis=0))]
    beta_hat_i = np.linalg.inv(x_i.T @ x_i) @ x_i.T @ y_i

有没有办法获得各个运行的系数，但仍然使用数组乘积方法？这让我想到，如果我可以用产生系数 0 的数据来估算缺失值，那么这两个答案将是相同的。插补全 0 不起作用，因为它会导致奇异矩阵错误，因此我决定使用第二好的替代方案，并插补与 y （白噪声）绝对相关性非常低的序列。我也不知道如何生成它，所以我有点暴力地强迫它，它有点工作？
TLDR：如何生成与 y 的相关性恰好为 0 的序列？如果我不能，那么是否有更好的插补方法或者只是一种允许我使用数组点积计算这些系数的方法？
重现结果的代码：
将 numpy 导入为 np
将 statsmodels.api 导入为 sm

# 数据生成
np.随机.种子(42)
人数 = 50
X = np.random.random((n, 2))
X = sm.add_constant(X)
贝塔 = [200, 100, 50]
e = np.random.random(n) * 25
y = np.dot(X, beta) + e

X2 = np.random.random((n, 2))
X2 = sm.add_constant(X2)
β2 = [500, 10, 5]
e2 = np.random.random(n) * 5
y2 = np.dot(X2, beta2) + e

X[:, 1] = np.NaN # 缺失值

X_many = np.array([X, X2])
y_many = np.array([y, y2])

打印（X_many.shape）
打印（y_many.shape）

对于 zip(X_many, y_many) 中的 x_i, y_i：
    x_i = x_i[:, np.isfinite(x_i.sum(axis=0))]
    beta_hat_i = np.linalg.inv(x_i.T @ x_i) @ x_i.T @ y_i
    打印（beta_hat_i）

np.随机.种子(42)
X_many_new = X_many.copy()
噪声 = np.random.normal(0, 1e12, (100, np.isnan(X_many_new).sum()))
X_many_new[np.isnan(X_many_new)] = 噪声[np.argmin(np.abs(np.corrcoef(噪声, y)[-1][:-1]))]

X_op = np.einsum(&#39;ikj,ilj-&gt;ilk&#39;, (np.linalg.inv(np.einsum(&#39;ikj,ikl-&gt;ijl&#39;, X_many_new, X_many_new))), X_many_new)
Beta_hat = np.einsum(&#39;ikj,ik-&gt;ij&#39;, X_op, y_many)
打印（Beta_hat）
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/635458/vectorized-linear-regression-with-missing-values</guid>
      <pubDate>Thu, 21 Dec 2023 21:52:13 GMT</pubDate>
    </item>
    <item>
      <title>如何识别内生变量和外生变量并在 R 中实现 IV 回归？</title>
      <link>https://stats.stackexchange.com/questions/635456/how-can-i-identify-endogenous-and-exogenous-variables-and-implement-an-iv-regres</link>
      <description><![CDATA[我想在 R 中使用 ivreg() 实现 IV 回归。我想使用 R 来实现这两个模型。我在识别外生变量和内生变量以进行 IV 回归时遇到问题。下面是以下等式：
lwage 作为 dep var 和 educ exper expersq black smsa South 作为回归量
第一阶段以nearc4为仪器。保存 dep 的预测值。变种插上它们
进入第二阶段回归

根据上面的方程，我如何识别内生变量和外生变量。
使用 R 函数进行 IV 回归：
ivreg_model &lt;- ivreg(lwage~educ+exper+expersq+black+smsa+south | nearc4, data=data)

结果：
&lt;前&gt;&lt;代码&gt;调用：
ivreg(公式 = lwage ~ educ + exper + expersq + 黑色 + smsa +
    南|近c4，数据=数据）

残差：
     最小 1Q 中值 3Q 最大
-2.24604 -0.36219 0.01269 0.37938 2.25907

系数：
            估计标准。误差t值Pr(&gt;|t|)
(截距) 3.76747 0.34886 10.799＜ 2e-16 ***
教育 0.18806 0.02629 7.153 1.06e-12 ***
经验 NA NA NA
经验 NA NA NA NA
黑色 娜娜娜娜
短信 NA NA NA
南 NA NA NA

诊断测试：
                            df1 df2 统计 p 值
弱工具 (educ) 1 3008 63.912 1.84e-15 ***
弱工具（专家） 1 3008 11.465 0.000718 ***
弱工具 (expersq) 1 3008 12.372 0.000442 ***
弱仪器（黑色） 1 3008 17.023 3.79e-05 ***
弱工具 (smsa) 1 3008 430.208 &lt; 2e-16 ***
弱仪器（南）1 3008 155.999 &lt; 2e-16 ***
吴-豪斯曼 1 3002 1.539 0.214858
萨根 -5 不适用 不适用
---
西尼夫。代码： 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

残余标准误差：3008 个自由度上为 0.5569
多重 R 平方：-0.5739，调整 R 平方：-0.5744
Wald 检验：1 和 3008 DF 上为 51.17，p 值：1.061e-12

运行模型时发出警告消息
警告消息：
在 ivreg.fit(X, Y, Z, 权重, 偏移量, 方法, ...) 中：
  回归量多于工具

如何在 R 中使用我上面提到的变量以正确的方式实现这个模型？
如何从上述变量中​​识别出外生变量和内生变量？]]></description>
      <guid>https://stats.stackexchange.com/questions/635456/how-can-i-identify-endogenous-and-exogenous-variables-and-implement-an-iv-regres</guid>
      <pubDate>Thu, 21 Dec 2023 21:17:20 GMT</pubDate>
    </item>
    <item>
      <title>了解地理空间坐标的标准化/标准化</title>
      <link>https://stats.stackexchange.com/questions/635455/understanding-the-normalization-standardization-of-geospatial-coordinates</link>
      <description><![CDATA[我正在构建一个神经网络来预测未来[纬度、经度、海拔]，但在处理这些特征时遇到困难。我已在此处查看了问题的答案和这里我仍在尝试了解有关规范化/标准化的要点。
按照我的理解，将纬度和经度转换为笛卡尔坐标是一种标准化的方式，这是正确的吗？当答案为“标准化”时，这是否意味着将数据放入 StandardScaler() 之类的东西中？
此外，第二个链接的帖子中有一条评论指出我不需要地球半径 R，因为无论如何它都会被标准化。为什么会这样呢？如果我对标准化数据进行逆变换，然后尝试将这些值转换回纬度和经度，我是否不需要 R？]]></description>
      <guid>https://stats.stackexchange.com/questions/635455/understanding-the-normalization-standardization-of-geospatial-coordinates</guid>
      <pubDate>Thu, 21 Dec 2023 21:14:02 GMT</pubDate>
    </item>
    <item>
      <title>Python中的MD模拟[关闭]</title>
      <link>https://stats.stackexchange.com/questions/635454/md-simulation-in-python</link>
      <description><![CDATA[我有一个分子动力学模拟代码。目的是计算 800 个具有 x、y 和 z 坐标的粒子的 Lennard Jones 势。我有一个包含 x、y 和 z 坐标的文本文件。我希望我的代码将这些坐标读取为 3 维空间中的位置。我应该添加哪行代码？代码现在是一维的，我如何修改它以使其成为位置和速度的 3 维]]></description>
      <guid>https://stats.stackexchange.com/questions/635454/md-simulation-in-python</guid>
      <pubDate>Thu, 21 Dec 2023 21:13:01 GMT</pubDate>
    </item>
    <item>
      <title>为什么在泊松回归中不总是使用协变量而不是偏移量？</title>
      <link>https://stats.stackexchange.com/questions/635451/why-not-always-use-covariate-instead-of-offset-in-poisson-regression</link>
      <description><![CDATA[我刚刚开始研究泊松回归并遇到了两个模型：
$$
\开始{对齐*}
\log{\mathbb{E}(​​count)} &amp;= \beta_0 + \beta_1x_1 + \beta_2x_2 + \log(T) \\\\
\log{\mathbb{E}(​​count)} &amp;= \beta_0 + \beta_1x_1 + \beta_2x_2 + \beta_T\log(T)
\结束{对齐*}
$$
其中 T 是时间/曝光。
我将从系数的解释开始。我们以 $\beta_1$ 为例。我将根据计数和比率进行解释。
偏移模型

当 $x_1$ 增加 1 个单位且 $x_2$ 保持不变时，日志计数增加 $\beta_1$。或者，等效地，将计数乘以 $e^{\beta_1}$。
当 $x_1$ 增加 1 个单位且 $x_2$ 保持不变时，对数率增加 $\beta_1$。或者，等效地，日志速率乘以 $e^{\beta_1}$。

我们正在建模的泊松分布的平均值和比率的解释是相同的。
以时间为协变量的模型

当$x_1$增加一个单位时，$x_2$保持不变并且&lt; span class=&quot;math-container&quot;&gt;$T$ 保持不变，则日志计数增加 $\beta_1$。或者，等效地，将计数乘以 $e^{\beta_1}$。
当$x_1$增加一个单位时，$x_2$保持不变并且&lt; span class=&quot;math-container&quot;&gt;$T$ 保持不变，则日志速率增加 $\beta_1$。或者，等效地，日志速率乘以 $e^{\beta_1}$。

在这种情况下，第二种解释并不那么简单，但可以很容易地从第一种导出。请记住 $rate = \frac{count}{T}$ ，并且根据第一种解释，$T $ 保持不变，计数乘以 $e^{\beta_1}$，则新速率为  $rate_{新} = \frac{count_{new}}{T_{new}} = \frac{e^{\beta_1} count_{old}}{T_{old}} = e^{\beta_1} 比率_{旧}$
我的观点

两种模型解释之间的唯一区别是粗体文本。
第二个模型不受 $T$ 系数为 $1$ 的限制，将成为一个更好的模特。
在两者之间进行选择有时取决于您是要对费率建模还是对计数建模。但是，您可以通过将计数除以 $T$ 来获得比率。因此，使用第二种模型在这方面不是问题。

问题
我知道使用偏移量是为了更容易解释。但仔细研究以上内容，差异并不那么大。鉴于第二个模型总是会给出更好的结果（我认为？）为什么不总是使用协变量时间模型？使用偏移量还有我所缺少的其他优点吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635451/why-not-always-use-covariate-instead-of-offset-in-poisson-regression</guid>
      <pubDate>Thu, 21 Dec 2023 20:38:12 GMT</pubDate>
    </item>
    <item>
      <title>将较小的公差区间组合为组合的 C&R</title>
      <link>https://stats.stackexchange.com/questions/635450/combining-smaller-tolerance-intervals-to-a-combined-cr</link>
      <description><![CDATA[我在医疗设备领域工作，我们经常使用公差区间来证明产品特性在一定程度上符合规范并具有一定的可信度。可靠性。
在我正在进行的当前验证中，我们正在根据三个独立批次计算无菌屏障密封拉开力的 R99C95 公差区间（正常变量方法，单面规格）。该协议被意外编写为每批次仅使用 10 个样品，而不是我们通常为每个变量分析批次使用 30 个样品。由于只有 10 个样本，其中 3 个数据集中有 2 个无法证明 R99C95。 （低均值、中等变异性导致负下限。）
之前一家公司的统计学家曾向我展示过一个公式，该公式显示，如果三个较小的公差区间（例如约 65% 的覆盖率）“批次水平覆盖率” （或者是信心较低？），全部通过了验收标准，然后据说输出已经证明了“整体”信心和信心。可靠性（通常类似于 R95C95、R99C95）
我无法通过搜索找到这样的公式/方法。我怀疑我漏掉了某个关键词，或者叫错了某个东西的名称。
是否有人熟悉将“整体”C&amp;R 与“运行级别”C&amp;R 要求相关联的方法和假设？
谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/635450/combining-smaller-tolerance-intervals-to-a-combined-cr</guid>
      <pubDate>Thu, 21 Dec 2023 20:32:20 GMT</pubDate>
    </item>
    <item>
      <title>为什么 Numpy 行向量的“副本”的维度会发生巨大变化？ [关闭]</title>
      <link>https://stats.stackexchange.com/questions/635449/why-is-a-copy-of-a-numpy-row-vector-having-its-dimensions-altered-drastically</link>
      <description><![CDATA[首先，我想说行向量 perCWE 和 perTWE 不是副本，我正在将引用地址传递给新变量！
我有一个 NDArray，它是一个 numpy 矩阵，我将一个 epsilon 标量添加到单个元素（我指定一行和列）在矩阵中，如下所示：
&lt;前&gt;&lt;代码&gt;epsilon = 0
model.w1[conIndex, i] += epsilon
model.w1[tarIndex, i] += epsilon

然后我提取发生该元素添加的行向量，如下所示：
perCWE = model.w1[conIndex, :]
perTWE = model.w1[tarIndex, :]

现在发生的奇怪的事情是，如果我在添加 epsilon 后用新的行向量减去原始行向量，它应该有一个行向量，其中一个元素是 epsilon，其余元素非常接近零（因为减法会得到像 $1e-10$ 这样的数字，这是可以接受的，因为它非常接近于零）。但最终发生的情况是，其中一个维度添加了 epsilon，其余维度是 $1e-3$ 周围或之上的随机组合。这太大了。这种情况仅发生在 perCWE 上，但不会发生在 perTWE 上，行向量没问题。
我不知道这是由于将 epsilon 添加到单个维度还是由于不执行 .copy() 而是传递了对行的引用 -内存中的向量。同样，考虑到 perTWE 工作完美这一事实，这甚至更奇怪。
这里是打印原始行向量与“更改后的”行向量的代码。行向量。它们应该接近 $0$ 因为它们是相同的（epsilon 是 $0$）。
注意：以下代码有效：
（原始行向量）-（新的“复制”行向量）

这是第一个“副本”的代码行向量：
print(f&quot;perCWE: {contextWE - model.w1[conIndex]}&quot;)

这是输出（尺寸与 $0$ 相差太远）：

这是第二个“副本”的代码行向量：
print(f&quot;perTWE: {targetWE - model.w1[tarIndex]}&quot;)

这是输出（您可以看到这看起来完全没问题，尺寸非常小，可以作为 $0$ 的占位符）：

为什么会出现这种情况？！我正在尝试执行梯度检查，这让我陷入困境，因为它在该计划中添加了扳手！]]></description>
      <guid>https://stats.stackexchange.com/questions/635449/why-is-a-copy-of-a-numpy-row-vector-having-its-dimensions-altered-drastically</guid>
      <pubDate>Thu, 21 Dec 2023 19:55:33 GMT</pubDate>
    </item>
    <item>
      <title>用于最大化观察到的响应和预测的响应之间的等级相关性的线性模型</title>
      <link>https://stats.stackexchange.com/questions/635447/linear-model-for-maximizing-rank-correlation-between-observed-and-predicted-resp</link>
      <description><![CDATA[线性回归建模为
$$Y = X\beta + \epsilon$$
对于响应变量$Y$（向量）、设计矩阵$X$和独立同分布高斯噪声 $\epsilon$ （向量）。
我不想最小化均方误差，而是想找到 $\beta$ ，这样 $Y 之间的排名相关性$ 和 $X\beta$ 最大化。因此，也许 $X\beta + \epsilon$ 术语应该封装为某种链接函数。
这个模型有研究过吗？这样的模型有名字吗？
如果是这样，

如何拟合和解释这些模型？
模型的常规假设是什么？
拟合系数可能不是唯一的，如何解决这个问题？
哪些现实世界的应用程序使用了该模型？

编辑：
我想我找到了线索：使用序数回归建模连续响应变量]]></description>
      <guid>https://stats.stackexchange.com/questions/635447/linear-model-for-maximizing-rank-correlation-between-observed-and-predicted-resp</guid>
      <pubDate>Thu, 21 Dec 2023 19:37:01 GMT</pubDate>
    </item>
    <item>
      <title>排列测试的正确公式[重复]</title>
      <link>https://stats.stackexchange.com/questions/635444/correct-formula-for-permutation-test</link>
      <description><![CDATA[为了我需要做：
测量原始网络上的目标变量并保存它洗牌我的原始数据（相关矩阵） - 随机（100x）创建测量该随机网络的目标变量的图表保存循环结束的数据比较分布随机目标变量，并在请求时保存原始变量。那么如果原始数据在随机变量的 95% 分布范围之外，则意味着它是显着的（随机数与原始变量不同）。
库（igraph）
 ###DADOSEXEMPLO##
值 &lt;- c(1, 5, 3, 8, 2, 9, 3, 2, 3 ,2, 5, 3, 6, 5, 1, 5, 3, 4, 2, 2, 5, 6, 5、7、1、2、
             8, 12, 5, 1, 5, 3, 6, 5, 9, 3,3,4,5,7,8,2,7,8,4,3,1,4,4 ) 矩阵网 &lt;-矩阵(valores, 7, 7) matcor &lt;- cor(matrixnet, method = “spearman”)

cor_pequena &lt;- 0.1
matcor[] &lt;- ifelse(matcor &lt; cor_pequena, 0, matcor)
矩阵网络 = graph.adjacency(matcor, mode = “无向”,
                                加权 = TRUE,
                                add.colnames = NULL，diag = FALSE）
度（矩阵网络）
#&gt; [1] 3 4 3 3 1 2 2

绘图（矩阵网络）

在这里，我计算图表的唯一值，在本例中为测量之间的值
`centr_betw(matrixnetwork，定向 = FALSE，归一化 = TRUE)$res`

这里我应用了排列“改变顶点值”与我想要应用的特定功能结合起来，在本例中为 Betw
set.seed(123) bootcentr_Betw &lt;- lapply(seq_len(Nperm), function(x){
randomnet &lt;- rewire(matrixnetwork, with=each_edge(0.5)) #以恒定概率重新连接顶点 E(randomnet)$weight &lt;- Sample(E(matrixnetwork)$weight) #打乱初始权重并将其随机分配给边 return(centr_betw(randomnet)$res) })

现在我需要将原始值与随机图的引导程序进行比较。
下面我尝试根据引导程序绘制原始的唯一值，复制我从其他地方获得的代码
`orig &lt;- centr_betw（矩阵网络，定向 = FALSE，归一化 = TRUE）$res

Nperm &lt;- 1e2
设置.种子(123)
bootcentr_Betw &lt;- 复制（Nperm，{
  randomnet &lt;- 重新连线（matrixnetwork，with =each_edge（0.5））
  E(randomnet)$weight &lt;- 样本(E(matrixnetwork)$weight)
  centr_betw(随机网)$res
})

op &lt;- par(mfrow = c(2, 4))
for(k in seq_along(orig)) {
  main &lt;- sprintf(“顶点：%d”，k)
  bootcentr_Betw[k,] |&gt;密度() |&gt;图（主=主，子=“观察与随机”）
  abline(v = orig[k], col = “红色”)
}

帕（操作）`

我的问题：
与其他问题的区别在于，我只有 1 个原始样本及其排列，而不是两个原始样本及其排列
我需要将来自矩阵引导的值与原始的唯一值进行比较，但我不知道如何对我的数据执行此操作。如果原始数据不在随机变量的 95% 分布范围内，则意味着它是显着的（随机数与原始变量不同）。
我无法进行统计来比较这些数据：观察值和该值的排列。
我可以使用这种形式来计算 p 值：大于或等于观察值的值（统计量）的数量，然后除以值的数量。在代码中，pval = sum(s &gt;= s0)/N;
我在互联网上找到了其他几个公式。但总的来说，我只是想知道一个正确的公式来计算 p 的值，考虑到我想比较原始值和该值 100x 的排列。
简而言之，我有一个值（x），我对这个值（x）进行了排列，我想比较这两个得到的p值，但我不知道到底如何]]></description>
      <guid>https://stats.stackexchange.com/questions/635444/correct-formula-for-permutation-test</guid>
      <pubDate>Thu, 21 Dec 2023 19:14:38 GMT</pubDate>
    </item>
    </channel>
</rss>