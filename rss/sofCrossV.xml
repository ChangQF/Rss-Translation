<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近的30个来自Stats.stackexchange.com</description>
    <lastBuildDate>Mon, 10 Feb 2025 06:26:12 GMT</lastBuildDate>
    <item>
      <title>如果一个（联合国）有意忽略所有可用数据的10％，那么最高准确性是多少？</title>
      <link>https://stats.stackexchange.com/questions/661168/if-one-unintentionally-ignores-10-of-all-available-data-what-is-the-highest</link>
      <description><![CDATA[我不记得场地，但我相信是一位语言学家，他认为，如果人们忽略了10％或15％的数据，那么从一个人专心考虑的85％的数据中就不会得出任何有意义的结论。 
在统计学方面，会发生这种情况还是取决于人口遵循的分布？？]]></description>
      <guid>https://stats.stackexchange.com/questions/661168/if-one-unintentionally-ignores-10-of-all-available-data-what-is-the-highest</guid>
      <pubDate>Mon, 10 Feb 2025 05:55:22 GMT</pubDate>
    </item>
    <item>
      <title>阅读部分依赖/条件期望图</title>
      <link>https://stats.stackexchange.com/questions/661167/reading-partial-dependence-conditional-expectation-plots</link>
      <description><![CDATA[我制作了以下图：  
我尚未完成，但请专注于第一行。 Y轴是我计算的条件期望（请参阅底部的代码），这是 $ [0,1] $ 的概率，而X轴是我的自变量（区域）。我对我的情节有些困惑，所有期望都显着高于 $ 0.5 $ ，我认为我会获得比没有更多的正值，但是这些都应该是少数群体。我使用smote使它们成为 $ 50/50 $ 余额，但我仍然认为有条件的期望不应该那么高，尤其是因为我的模型表现良好。 
以下是我的蒙特卡洛集成，以进行有条件的期望。
  def calculate_partial_dependence（model，x，features_index，grid_resolution = 100，sample_num = 20000）：
    “”
    计算功能对模型预测的部分依赖性。

    参数：
     - 型号：模型
    -X：数据集
    -Features_Index：为其计算部分依赖性的功能的索引。
    -grid_resolution：该功能网格中的点数。
    -sample_num：网格中每个点的均匀绘制数量

    返回：
     -  feature_values：计算部分依赖的特征的值。
    -pd_values：部分依赖值。
    “”
    #Fuck Sklearn我们自己踢了
    #min and Maxes    
    f = x [：，feature_index]
    x_deleted = np.delete（x，feature_index，axis = 1）

    a = np.min（f）
    b = np.max（f）
    值= np.linspace（start = a，
                    停止= b，
                    num = grid_resolution）
    期望= np.seros_like（values）

    kde = kerneldents（）
    如果x_deleted.shape [1]！= 0：
        对于IDX，枚举（值）中的条件：
            #find附近的X，然后计算“条件ish”密度，因为我们没有足够的值来实现实际条件密度
            XL = 0
            Q = 5
            xl＆lt; = 10：
                R =（条件-Q*（B-A）/GRID_RESOLUTION，条件 + Q*（B-A）/GRID_RESOLITY）
                #filter指数r
                x_temp = x_deleted [（f＆gt; = r [0]）＆amp; （f＆lt; = r [1]），：]
                xl = x_temp.shape [0]
                Q += 1

            #Generate样本分布
            generator = kde.fit（x_temp）.sample（sample_num）
            col = np.ones（（Sample_num，1））*条件
            样本= np.concatenate（（col，Generator），轴= 1）

            #Predict tagrip概率
            output = model.predict_proba（示例）[：，1]
            
            自从蒙特卡洛以来 
            期望[idx] = np.mean（输出）

    别的： 
        ＃NULL模型只有一个变量，因此我不需要``条件&#39;&#39;
        期望= model.predict_proba（values）[：，1]
    返回值，期望

 
我在这里误会了什么吗？我也尝试了像Sklearn这样的普通图书馆，以达到有条件的期望，他们给了我相同的答案。我的模型是腥的，还是我不明白我在看什么。]]></description>
      <guid>https://stats.stackexchange.com/questions/661167/reading-partial-dependence-conditional-expectation-plots</guid>
      <pubDate>Mon, 10 Feb 2025 03:12:27 GMT</pubDate>
    </item>
    <item>
      <title>如何分析离散数据</title>
      <link>https://stats.stackexchange.com/questions/661166/how-to-analyse-discrete-data</link>
      <description><![CDATA[我有一组数据来分析由两个离散变量组成的数据。第一个是通过/失败，第二个是字母2b，2p，2a，3b，3p，3a，3a，...等最高6B。
有没有办法查看数据并告诉第一个变量的字母等级可以通过哪个字母等级进行？
我在网上阅读了一点，发现了逻辑回归。那是正确的吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/661166/how-to-analyse-discrete-data</guid>
      <pubDate>Mon, 10 Feb 2025 02:09:19 GMT</pubDate>
    </item>
    <item>
      <title>如何确定偏斜的引导分布的平均值和95％置信区间</title>
      <link>https://stats.stackexchange.com/questions/661165/how-to-determine-the-mean-and-95-confidence-interval-of-a-skewed-bootstrapped-d</link>
      <description><![CDATA[我已经引导了我的数据1000（甚至是10,000），但是此引导分布偏斜，因此真实的组平均值与分布的模式更为一致，而不是平均值。。
在忠于真实群体的含义的同时，如何报告平均值和CI？我可以报告模式吗？
下面的编辑以具体示例阐明我的确切方法：
我正在使用线性SVM在2个上下文中解码2个条件。从20个受试者中，我从上下文A中有一个对每个受试者的解码精度迹线。我还从上下文B中有20个痕迹。我的目的是测试我可以在两个条件的情况下解码的上下文（a或b）。。
统计测试1：首先，要测试解码精度是否在组级别上是否超过偶然（对于上下文A＆amp; b，分别），我执行基于置换的群集大小的推断。简而言之，零设置为50％的机会水平，我通过将每个样品解码精度输出乘以+1或-1并找到明显的时间点来缩小样品标签。然后，我执行群集校正，并确定最早的显着时间点（即开始时间）。
统计测试2：然后，要测试哪个上下文（a或b）具有较早的发作时间，我通过随机进行替换来启动数据集1000次。简而言之，我用更换随机对20次进行样品，执行上述定义的统计测试，并节省第一个重要的时间点。重复此过程1000次后，我的发作时间分布（我计划从中得出平均自举的发作时间和置信区间）。
但是，第二个测试中的发病时间分布并非正态分布。我应该期望在更清洁，理想主义数据中有正态分布吗？如果结果是真实的，我可以报告模式+/- CI，而不是平均+/- CI，以说明数据的偏差？
我希望这是有道理的。非常感谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/661165/how-to-determine-the-mean-and-95-confidence-interval-of-a-skewed-bootstrapped-d</guid>
      <pubDate>Sun, 09 Feb 2025 21:35:46 GMT</pubDate>
    </item>
    <item>
      <title>脊回归估计量的剩余平方，Hoerl和Kennard（1970）中的等式（2.11）</title>
      <link>https://stats.stackexchange.com/questions/661159/residual-sum-of-squares-of-ridge-regression-estimator-equation-2-11-in-hoerl</link>
      <description><![CDATA[我无法“编译”来自等式的派生 $（2.10）$  to  $（2.11）$  in  ridge回归： Hoerl and Kennard（1970）的非正交问题的偏见估计：
 我缺少什么？ 

对于估计 $ \ hat {\ boldsymbol {\ beta}}}^*$ ，正方形的剩余总和是
  $$ \ boldsymbol {\ phi}^*（k）=（\ MathBf {y}  -  \ MathBf {x} \ hat {\ boldsymbol {\ boldsymbol {\ beta}}}} *）&#39;（\ mathbf {y}  -  \ Mathbf {x} \ hat {\ boldsymbol {\ beta}}}^*）\ tag {2.10}
可以以形式写的
  $$ \ boldsymbol {\ phi}^*（k）= \ Mathbf {y}&#39;\ Mathbf {y}  - （\ hat {\ boldsymbol ^*）&#39;\ Mathbf {X}&#39;\ MathBf {y} -k（\ hat {\ boldsymbol {\ beta}}}^*）&#39;（\ hat {\ boldsymbol {\ beta} } $$  
表达式表明 $ \ boldsymbol {\ phi}^*（k）$ 是正方形的总和。  $ \ hat {\ boldsymbol {\ beta}}}^*$ 的平方之和，取决于 $ \ hat {\ boldsymbol {\ beta}}}^*$ 。

其中

符号 $&#39;$ 表示转台操作员。
  $ \ boldsymbol {y} \ in \ Mathbb {r}^n $ 是响应向量。
  $ \ BOLDSYMBOL {X} \ in \ MATHBB {r}^{n \ times p} $ 是（完整）等级 $ P $ 。
  $ \ HAT {\ BOLDSYMBOL {\ beta}}}}^* =（\ MathBf {x}&#39;\ MathBf {x} + k \ boldsymbol {i}）^{ - 1} \ mathbf {x}&#39;\ Mathbf {y} $ 是岭回归估算器。


 尝试推导。 
派生的派生是相当基本的，而本文是开创性的，所以我不确定自己出了什么问题，或者我缺少什么。
在 $（2.10）$ 给予，中扩展括号
  $$ \ begin {align*}
\ boldsymbol {\ phi}^*（k）＆amp; =（\ mathbf {y}  -  \ Mathbf {x} \ hat {\ boldsymbol {\ beta}}}^*） x} \ hat {\ boldsymbol {\ beta}}}^*）\ tag {2.10} \\
＆amp; = \ MathBf {y}&#39;\ MathBf {y}  - （\ hat {\ boldsymbol {\ beta}}}^*） {x} \ hat {\ boldsymbol {\ beta}}}^* +（\ hat {\ boldsymbol {\ beta}}}^*）&#39;\ mathbf {x}&#39;\ mathbf {x} beta}}^*）\\
＆amp; \ overset {？} {=} \ MathBf {y}&#39;\ Mathbf {y}  - （\ hat {\ boldsymbol {\ beldsymbol {\ beta}}}^*）&#39;\ Mathbf {x}&#39; hat {\ boldsymbol {\ beta}}^*）&#39;（\ hat {\ boldsymbol {\ beta}}}^*）
\ end {align*} $$  
如果我的派生是正确的，那么在 $（2.11）$ 的中间的2个因子中，我们用什么参数来替换&lt;&lt; span class =“ Math-Container”&gt; $（\ Mathbf {X}&#39;\ MathBf {X}）$  with  $ k $ ？]]></description>
      <guid>https://stats.stackexchange.com/questions/661159/residual-sum-of-squares-of-ridge-regression-estimator-equation-2-11-in-hoerl</guid>
      <pubDate>Sun, 09 Feb 2025 16:01:12 GMT</pubDate>
    </item>
    <item>
      <title>时间分解给出了奇怪的结果</title>
      <link>https://stats.stackexchange.com/questions/661157/temporal-disaggregation-gives-strange-results</link>
      <description><![CDATA[我正在与临时分解一起玩一些（）。但是，我没有获得财务回报时间序列的有意义的结果。
基本上，该方法通过使用 $ \ beta $ 乘以高频预测器来预测高频值。
但是，为了确保预测的价值“阵容”正确地（在我的情况下，这意味着一定期段内的总回报需要在同一时期等于实际已知收益），使用分配矩阵分配残差。
，但是这些模型并没有以有意义的方式这样做。如果我自己必须这样做，我将简单地计算实际和预测的回报之间的总残差，然后按比例分配到每个高频预测的值（即，较高的值获得较高的残差）。。
然而，tempdisagg方法具有一些怪异的残差结构，最终导致时期开始时较高残留物，最后较低。为什么？那没有道理。
总结一下，我认为此软件包中使用的残差结构对财务返回时间序列有好处。谁能确认？
这是一个例子。假设我有几个月的回报等于10％。我正在尝试使用另一个与月度相关的时间序列将其转换为每周的回报。其他时间序列在本月的每周回报为0％，0％，4％，4％。让我们假设 $ \ beta = 1 $ 。然后，我们的tempdisagg方法将首先预测我们的每月时间序列每周收益也为0％，0％，4％，4％。那么总数为（这些是记录归还）8％。但是我们希望它等于10％。因此，这给出了2％的剩余。现在，我将均匀且成比例地分配它，即，我会得到我所期望的，0％，0％，5％，5％...但是Tempdisagg会在前端分配它，即您会得到1.5的东西％，0.5％，4％，4％。]]></description>
      <guid>https://stats.stackexchange.com/questions/661157/temporal-disaggregation-gives-strange-results</guid>
      <pubDate>Sun, 09 Feb 2025 15:09:26 GMT</pubDate>
    </item>
    <item>
      <title>哪种概率定律被用于得出分配运动定律</title>
      <link>https://stats.stackexchange.com/questions/661152/what-law-of-probability-is-being-used-for-deriving-law-of-motion-of-distribution</link>
      <description><![CDATA[我正在研究
基本上，我们有以下元素：状态空间 $ a \ times s = \ {\ bar {a} _1，\ dots，\ bar {a} _n \} \ times \ {\ bar {s} _1，\ dots，\ bar {s} _n \}，$ ，并且存在决策规则 $ g：a \ times a \ times s \ to $ 映射每个状态 $（a，s）$  to element  $ a&#39; = g（a，s）$  in  $ a，$ ，应解释为&#39;当今天的状态为 $（a，s）$ 明天的决策是 $ a&#39;$ &#39;。此外，还有一个随机变量 $（s_t）_ {t = 0}^\ int space  $ s $ 具有带有条件过渡概率的Markov属性 $ p（s_ {t+1} = s&#39;| s_t = s）$ 给定，其中&lt; Span class =“ Math-Container”&gt; $ s&#39;，s $ 中的S \，这些概率在过渡矩阵中文字。
然后，动力学如下：我们从初始状态 $（a_ {0}，s_ {0}）\ in a \ times s $  in ，然后是随机变量 $（s_t）_ {t = 1}^\ infty $ 为我们的系统 $（a_t，s_t）_ {t = 0}^\ infty $ 。
话虽如此，我们对联合无条件分布的演变感兴趣/span&gt;状态 $（a，s）$ 在任何时候 $ t $ t $ 时间。因此，我们得到了描述  $$ p（a_ {t+1} = a&#39;，s_ {t+1} = s&#39;）= \ sum_ {a_t {a_t \ in} \ sum_ {s_t \ in s} p（a_ {t+1} = a&#39;| a_t = a，s_t = s）p（s_ {t+1} = s&#39;| s_t = s） = s）。$$  
我有能力“直观地”理解这个方程式，但是我无法使用概率定律正式得出它。特别是，我尝试了允许我们以条件和边缘概率（即 $ p（x = x，y = y）= p（x = x = x）来编写联合概率的法律。 | y = y）p（y = y）= p（x = x | y = y）\ sum_xp（y = y | x = x）p（x = x）$ ，但我不查看如何将其转换为上面的表达式。
如果您能给我一些有关如何得出这个方程式的见解，我将非常感谢。
    ]]></description>
      <guid>https://stats.stackexchange.com/questions/661152/what-law-of-probability-is-being-used-for-deriving-law-of-motion-of-distribution</guid>
      <pubDate>Sun, 09 Feb 2025 07:08:50 GMT</pubDate>
    </item>
    <item>
      <title>有限样本量$ n $的最大似然估计的偏差限制</title>
      <link>https://stats.stackexchange.com/questions/661137/a-bound-for-the-bias-of-maximum-likelihood-estimates-for-finite-sample-size-n</link>
      <description><![CDATA[随机示例 $ x_1，\ dots，x_n $ 。每个 $ x_i $ 是来自函数 $ f（x; \ theta）$ 的IID。令 $ \ hat \ hat \ theta_ \ text {mle} $ 是真实参数的最大似然估计器（mle） theta $ 。
I know that the MLE is consistent and asymptotically efficient.我知道偏见可以写在 form ：
  $$ e（\ hat \ theta_ \ text {mle}  -  \ theta）= \ frac {b（\ theta）} {n} {1} {n^2} \ biggr）$$  
其中 $ \ hat \ theta_ \ text {mle} = h_n（x）$ ，带有 $ $的有限衍生物H $ 。
是否有有关MLE的 $ b（\ theta）$ 的信息？特别是某些上限？
我期望在 $ b（\ theta）$ 上有一定的绑定，取决于 $ x $ 的矩和 $ h $ 的衍生物。

特别是对于我的具体问题，每个 $ x_i $ 是一个bernoulli rv，成功概率 $ p（\ $ p（\） theta）$ 。  $ x = \ sum_i^n x_i $ 对于 $ \ theta $  &lt;&lt;&lt;&lt;&lt;
 MLE被隐式定义为
  $$ \ hat \ theta_ \ text {mle} = h_n（x）= \ left \ {\ theta \ in \ theta \ in \ theta：p（\ theta）= \ frac1n \ \ frac1n \ \ frac1n \ \ sum_ {i = 1}^n x_i \ right \} $$ 
与 $ h_n $ 相对于 $ x $ 。

另外，我也会对存在感兴趣，以防万一 $ b（\ theta）$ 已知。]]></description>
      <guid>https://stats.stackexchange.com/questions/661137/a-bound-for-the-bias-of-maximum-likelihood-estimates-for-finite-sample-size-n</guid>
      <pubDate>Sat, 08 Feb 2025 18:01:05 GMT</pubDate>
    </item>
    <item>
      <title>预期的掷骰数以滚动数字m次以n侧为单位</title>
      <link>https://stats.stackexchange.com/questions/661134/expected-number-of-rolls-necessary-to-roll-a-specific-number-m-times-with-a-n-si</link>
      <description><![CDATA[我想计算以给定的置信
我知道这与优惠券收集者的问题关于滚动的概率 m数字，而不是特定数字m次。
为了了解WW分布的外观，我对1000侧的模拟卷进行了模拟，以计算至少一次滚动数字1到10所需的掷骰数。 Fortran代码看起来像这样：
 运行= 100000000
侧= 100
滚动= 0

i = 1，运行
    run_rolls = 0

    做s = 1，10
        run_rolls = run_rolls + 1
        while（int（侧 * rand（） + 1） /= s）
            run_rolls = run_rolls + 1
        结束
    结束

    rolls（run_rolls）= rolls（run_rolls） + 1
结束
 
这会产生几乎与最佳拟合参数拟合对数正态分布的分布：
  shape = 2.20115409e-01
LOC = -4.32304744E+02
比例= 1.39866682E+03
 
看起来像这样：
    
以给定的置信度计算所需的预期模具数量的分析公式是什么？此问题会产生什么样的分布？
编辑：按照评论中的建议，我重新制定了这个问题。旧的标题过去是“预期的卷卷数，以滚动M数至少至少一次。但是我已经改写了它以更好地说明我的意图用户酶。]]></description>
      <guid>https://stats.stackexchange.com/questions/661134/expected-number-of-rolls-necessary-to-roll-a-specific-number-m-times-with-a-n-si</guid>
      <pubDate>Sat, 08 Feb 2025 16:57:40 GMT</pubDate>
    </item>
    <item>
      <title>我是否有正确的想法来解释贝叶斯推断中的超参数？</title>
      <link>https://stats.stackexchange.com/questions/661130/have-i-got-the-right-idea-for-interpreting-hyperparameters-in-bayesian-inference</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/661130/have-i-got-the-right-idea-for-interpreting-hyperparameters-in-bayesian-inference</guid>
      <pubDate>Sat, 08 Feb 2025 15:57:44 GMT</pubDate>
    </item>
    <item>
      <title>投资组合返回的线性回归</title>
      <link>https://stats.stackexchange.com/questions/661144/linear-regression-on-portfolio-returns</link>
      <description><![CDATA[我知道投资组合返回和每个资产类别中的共享，但没有这些资产类别的回报。我的想法是通过表单的线性回归估算不同资产类别的回报
  $$ r _ {\ text {ptf}} = \ beta_1 s_1 + \ dots + \ beta_n s_n s_n + \ epsilon $$   
其中 $ s_i $ 是资产类别的已知股份 $ \ {1，\ dots，n \} $ 和 $ \ beta_i $ 是要估算的系数，该系数最终代表资产类返回。
我觉得我会遇到多重共线性问题，因为我的资产类别的股票将总结到 $ 1 $ 。有什么方法可以解决这个问题？请注意，某些投资组合可能仅投资于某些资产类别，而在其他资产类别中则为零。
附加09.02.2025：
我知道数千个投资组合的回报，而不仅仅是一个。]]></description>
      <guid>https://stats.stackexchange.com/questions/661144/linear-regression-on-portfolio-returns</guid>
      <pubDate>Sat, 08 Feb 2025 09:49:44 GMT</pubDate>
    </item>
    <item>
      <title>如何将2个序数变量和1个二分法变量组合到一个（最好是连续）变量中？</title>
      <link>https://stats.stackexchange.com/questions/661118/how-to-combine-2-ordinal-variables-and-1-dichotomous-variable-into-a-single-pre</link>
      <description><![CDATA[我有3个变量，这些变量是SES（收入，教育和就业）的指标。前两个是序数（分别为12个级别和3个级别）。就业是二分的。有没有办法将它们组合到单个变量中以捕获参与者SES？我在R中这样做，以引用任何编码问题。]]></description>
      <guid>https://stats.stackexchange.com/questions/661118/how-to-combine-2-ordinal-variables-and-1-dichotomous-variable-into-a-single-pre</guid>
      <pubDate>Sat, 08 Feb 2025 04:55:13 GMT</pubDate>
    </item>
    <item>
      <title>当真正的beta是恒定值时，在多项式回归中会发生什么？ [关闭]</title>
      <link>https://stats.stackexchange.com/questions/661069/what-happens-in-multinomial-regression-when-the-true-beta-is-a-constant-value</link>
      <description><![CDATA[如果我的beta是所有类别的恒定数字，那么这如何影响运行回归或诸如套索之类的变量选择？我知道概率是1/k，其中k =类别数，但是有任何调整方法吗？
编辑：如果真正的beta类似于（1,1,1,1 ...），我已经注意到Glmnet和cv.glmnet始终选择NULL模型。只有当Beta是非恒定体时]]></description>
      <guid>https://stats.stackexchange.com/questions/661069/what-happens-in-multinomial-regression-when-the-true-beta-is-a-constant-value</guid>
      <pubDate>Fri, 07 Feb 2025 01:20:07 GMT</pubDate>
    </item>
    <item>
      <title>拟合3D逻辑回归，其中概率图的斜率不是恒定的</title>
      <link>https://stats.stackexchange.com/questions/661013/fitting-a-3d-logistic-regression-where-the-probability-graphs-slope-is-not-cons</link>
      <description><![CDATA[我正在尝试使用逻辑回归来预测给定事件在可能的x和y输入范围内为1的概率。问题是，当我在各个点保持x常数时，2D逻辑回归的形状非常不同，我不知道如何构建3D逻辑回归，该回归在这些形状之间正确流动。
我已经整理了一个简单的演示，并提供了一些数据，以更好地说明我要实现的目标。
 导入matplotlib.pyplot作为PLT
导入numpy作为NP
来自sklearn.linear_model导入logisticRegress


＃通用示例数据----------------------------------------------------------------------------------------------------------------------------------------------------------- ---
＃暗示具有逐渐坡度的物流功能集中在Y范围的中心的点
x1 = [0，0，0，0，0，0，0，0，0，0，0，0]
y1 = [1，2，3，4，5，6，7，8，9，10]
z1 = [0，0，1，0，1，0，1，1，0，1，1]

＃暗示具有渐进坡度较小坡度的物流功能的点数
x2 = [5，5，5，5，5，5，5，5，5，5，5]
y2 = [1，2，3，4，5，6，7，8，9，10]
z2 = [0，0，0，0，1，0，1，1，0，1，1]

＃暗示着具有陡峭斜率牢固偏向Y范围的巨大坡度的物流功能的点
x3 = [10，10，10，10，10，10，10，10，10，10，10]
y3 = [1，2，3，4，5，6，7，8，9，10]
z3 = [0，0，0，0，0，0，0，1，0，1，1，1]


＃在x的每个值下绘制逻辑回归，以显示当时的一般回归形状-------------------------------------------------------------------------------------------------------------------------------------------
def fit_and_show_logistic_regression（y_data，z_data，title）：
    y = np.array（y_data）.Reshape（（ -  1，1））
    z = np.array（z_data）

    log_regression = logisticRegress（lunnty = none）.fit（y，z）

    y_steps = np.Arange（0，10，0.1）.Reshape（（ -  1，1））
    z_prediction = log_regression.predict_proba（y_steps）[：，1]
    ＃像我这样的人注意▼
    ＃需要[：1]，因为preadion_proba返回这样的列表[prog_of_being_zero，prog_of_being_one]
    ＃the [：1]过滤到prob_of_being_zero部分，以便您获得一对一的输入和输出

    ＃plt.title（标题）
    ＃plt.scatter（y，z）
    ＃plt.plot（y__steps，z_prediction）
    ＃plt.show（）

    返回[y_steps，z_prediction]


x1_regression = [0在范围内（100）]
y1_regression，z1_Regression = fit_and_show_logistic_regression（y1，z1，显示logistic回归时的样子时

x2_Regression = [5 for i在范围内（100）]
y2_regression，z2_Regression = fit_and_show_logistic_regression（y2，z2）显示logistic回归时的外观时，

X3_Regression = [10在范围内（100）]
y3_regression，z3_Regression = fit_and_show_logistic_regression（y3，z3，显示logistic回归时的样子时


＃在3D中一次显示所有内容------------------------------------------------------------------------------------------------------------------------------------ ----------------------------------------------
无花果= plt.figure（）
ax = fig.add_subplot（投影=&#39;3d&#39;）
ax.set_xlabel（&#39;x&#39;）
ax.set_ylabel（&#39;y&#39;）
ax.set_zlabel（&#39;z&#39;）

all_x = x1 + x2 + x3
all_y = y1 + y2 + y3
all_z = Z1 + Z2 + Z3
ax.Scatter（all_x，all_y，all_z）
ax.plot3d（x1_regression，y1_regression，z1_regression）
ax.plot3d（x2_regression，y2_regression，z2_regression）
ax.plot3d（x3_Regression，y3_regression，z3_regression）


plt.show（）
 
演示中的数据产生了一个看起来像这样的3D图：
   
 问题：是否有一种方法可以在3D空间中执行逻辑回归，从而产生光滑的表面？]]></description>
      <guid>https://stats.stackexchange.com/questions/661013/fitting-a-3d-logistic-regression-where-the-probability-graphs-slope-is-not-cons</guid>
      <pubDate>Wed, 05 Feb 2025 20:04:13 GMT</pubDate>
    </item>
    <item>
      <title>预测因子和结果之间有不同关联的顺序回归</title>
      <link>https://stats.stackexchange.com/questions/660366/ordinal-regression-with-different-associations-between-predictor-and-outcome</link>
      <description><![CDATA[我是研究回归分析的新手，我正计划计算序数回归模型。
我有一个序数因变量，有5个可能的结果。我有几个预测指标，有些是连续的，有些是分类的。
我知道，对于一个分类预测指标，无法实现一定的结果。
例如，A，B和C组可以在任何结果类别1-5中，但D组只能在结果类别1-4中。
这似乎是一个问题，但我尚未发现如何处理它。有人可以将我指向正确的方向吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/660366/ordinal-regression-with-different-associations-between-predictor-and-outcome</guid>
      <pubDate>Wed, 22 Jan 2025 10:24:32 GMT</pubDate>
    </item>
    </channel>
</rss>