<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Sat, 04 May 2024 21:13:22 GMT</lastBuildDate>
    <item>
      <title>对零膨胀二进制数据进行建模以显示组是否不同</title>
      <link>https://stats.stackexchange.com/questions/646511/modelling-zero-inflated-binary-data-to-show-whether-groups-are-different</link>
      <description><![CDATA[我在 2x2 设计中有两个预测变量，产生四个条件，并且我正在尝试查看一个预测变量（一致性：一致或不一致）对因变量的影响（参与者是否对以下问题回答“是”或“否”）句子中的每个单词，这是一个区域）。回答“是”需要参与者继续完成试验，“否”意味着试验结束（因此没有替换 - 不确定这是否真的很重要，并且由于我将每个区域视为离散决策，所以我认为每个区域的数据并不重要）自相关 - 但如果您不同意，请告诉我）。我最终试图评估每个感兴趣区域的一致性效应（即，我将在每个区域运行一个模型，以评估某个区域的“是”响应的累积数量在一致和不一致条件之间是否存在显着差异）。
我运行了一个 GLME 模型，该模型具有二项式族和 cloglog 链接以及刺激项和参与者的随机效应（我的领域的标准），但该模型在接近 100% YES 的区域中给了我显着的一致性结果所有条件的选择 - 例如，在一个区域，1440 个值中只有 3 个为 NO。然后我意识到这种方法并不能回答我的问题：在一致和不一致条件下“是”回答的累积比例是否显着不同。
我正在考虑的一个选择是使用贝叶斯参数估计来显示组是相同的，但我不确定这种方法对于零膨胀分数有多稳健（即，没有响应被编码为 0，并且我的数据在 3 个“是”响应 (=1) 到 290 个“是”响应之间不断膨胀。
我过去使用过零膨胀 beta 回归模型，但考虑到二进制 DV，我不确定这里最好的方法是什么。我真的很感激任何人可以提供的任何建议！我最熟悉混合效应建模（即，也许我可以使用另一个因变量？）或贝叶斯方法，但我对任何事情都持开放态度。
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/646511/modelling-zero-inflated-binary-data-to-show-whether-groups-are-different</guid>
      <pubDate>Sat, 04 May 2024 21:03:27 GMT</pubDate>
    </item>
    <item>
      <title>如何解释双因素实验设计的 glm 结果</title>
      <link>https://stats.stackexchange.com/questions/646509/how-to-interpret-results-of-a-glm-from-a-double-factor-experimental-desing</link>
      <description><![CDATA[我用两个因子“酶”和“FeedMixture”进行了实验，有 4 个不同的水平。 “FeedMixture”是因子类型的变量。下面我模拟了一个响应变量并提供了我的 df 的示例：
set.seed(123)
读取次数 &lt;- 84
响应 &lt;- round(rnorm(num_reads,mean = 50,sd =20))
响应 &lt;- pmax(pmin(响应, 100), 0)
FM &lt;- 样本（c（“_A”、“_B”、“_C”、“_D”）、num_reads、替换 = TRUE）
酶&lt;-样本(c(500,1500,3000),num_reads,replace = TRUE)
df &lt;- data.frame(r_var = 响应, FM = FM, Enzyme = 酶)
rm&lt;-glm(r_var~FM+酶+FM:酶,数据 = df)

结果如下：
调用：glm(公式 = r_var ~ FM + Enzyme + FM:Enzyme, data = df)

系数：（截距） FM_B FM_C FM_D 酶 FM_B：酶 FM_D：酶 FM_C：酶
              34.223841 19.199688 4.867659 26.737532 0.006747 -0.009241 -0.002555 -0.009512

自由度：总共 83 个（即空）； 76 残余零偏差：32450 残余偏差：29600 AIC：749

我有两个问题，请:)
据我所知，自从“FM”开始以来，是“FM_A”的一个因素。被认为是指截距，因此我们仅对“截距”、“FM_B”、“FM_C”进行估计。和“FM_D”。
1.- 我应该如何解释“酶”的估计值？它只是对“酶”因子的估计值吗？或者是相互作用“酶：拦截”？不管是哪一个，另一个在哪里？
2.- 我可以用这些估计值建立方程还是强制我得到 lsmeans？如何决定？
非常感谢！
红外]]></description>
      <guid>https://stats.stackexchange.com/questions/646509/how-to-interpret-results-of-a-glm-from-a-double-factor-experimental-desing</guid>
      <pubDate>Sat, 04 May 2024 19:39:29 GMT</pubDate>
    </item>
    <item>
      <title>如何从拟合的 OpenMx 模型中获取随机斜率和随机截距的估计值？</title>
      <link>https://stats.stackexchange.com/questions/646508/how-to-get-estimated-value-of-random-slopes-and-random-intercepts-from-a-fitted</link>
      <description><![CDATA[我使用 OpenMx 安装了随机截距和斜率模型，我想知道如何获取预测斜率的值 $U_{1j}$ 和截距 &lt; span class=&quot;math-container&quot;&gt;$U_{0j}$？有没有我可以使用或手动计算的函数？
这是我安装的模型：
$$
Y_{ij} = \beta_{0j} + \beta_{1j} X_{ij} + e_{ij}
$$
$$
\beta_{0j} = \gamma_{00} + U_{0j}
$$
$$
\beta_{1j} = \gamma_{10} + U_{1j}
$$
$$
\开始{b矩阵}
U_{0j} \\
U_{1j}
\end{bmatrix} \sim 正常(\mathbf{0}, \begin{bmatrix}
\tau_0 &amp; \tau_{01} \\
\tau_{01} &amp; \tau_{1}
\end{b矩阵})
$$
$$
e_{ij} \sim 正常(0, \sigma_e)
$$
这里是模拟分层数据并拟合 OpenMx 模型的代码。我有上面指定的所有估计参数。
库(dplyr)
图书馆（tidyr）
库（OpenMx）

J &lt;- 100 #簇数
n_j &lt;- 30#观察次数

gamma_00 &lt;- 5
gamma_10 &lt;- 3
mu_x &lt;- 4


sim.dat &lt;- data.frame(J_ID = 1:J) |&gt;;
  突变（U_0j = rnorm（J，平均值= 0，sd = 1），
         U_1j = rnorm(J, 平均值 = 0, sd = 1),
         伽玛_00 = 伽玛_00,
         伽玛_10 = 伽玛_10,
         n_j = n_j) |&gt;
  行式（）|&gt;
  变异（X =列表（rnorm（n_j，mu_x，sd = 1）），
         R = 列表(rnorm(n_j, 0, sd = 1))) |&gt;
  unnest(cols = c(X, R)) |&gt;;
  变异(Y = gamma_00 + U_0j + (gamma_10 + U_1j) * X + R)


sim.dat.obs &lt;- sim.dat|&gt;;
  选择（J_ID，X，Y）|&gt;
  变异（J_ID = as.factor（J_ID））

J_obs &lt;- sim.dat.obs |&gt;;
  选择（J_ID）|&gt;
  清楚的（）

J_cluster_name &lt;-“J_ID”

J_latent &lt;- c(“U_0”，“U_1”)

J_data &lt;- mxData(J_obs, 类型 = “原始”,
                 主键 = J_cluster_name)

J_var &lt;- mxPath(来自 = J_latent,
                箭头 = 2，值 = 1，
                连接=“单个”，
                标签= c(“tau0”,“tau1”))
J_cov &lt;- mxPath(来自 = J_latent,
                箭头 = 2，值 = 0，
                连接=“唯一.双变量”，
                标签=“tau01”）

J_model &lt;- mxModel(“Level_J”, type = “RAM”,
                   潜在变量 = J_潜在，
                   J_数据，
                   J_var，
                   J_cov）
## I级（学生）--------
I_obs &lt;- mxData(sim.dat.obs, type = “raw”)

I_manifest &lt;- c(“X”,“Y”)


I_means &lt;- mxPath(from = “一”,
                  至=c(“X”)，
                  标签 = c(“mu_x”),
                  值 = 1)
I_var &lt;- mxPath(from = c(“X”, “Y”),
                标签= c(“sigma_x”,“sigma_r”),
                箭头=2，
                值 = 1)



I_fixed &lt;- mxPath(from = c(“一”,“X”),
                    至=“Y”，
                    值 = 1，
                    标签= c(“gamma_00”,“gamma_10”))

I_randomslope &lt;- mxPath(from = c(“Level_J.U_1”),
                          to = c(“Y”)，
                          标签 = c(“数据.X”),
                          免费=假，
                          joinKey = J_cluster_name)

I_randomint &lt;- mxPath(from = c(“Level_J.U_0”),
                        to = c(“Y”)，
                        值 = 1，
                        免费=假，
                        joinKey = J_cluster_name)

I_model&lt;- mxModel(“Level_I”, type = “RAM”,
                  清单变量 = I_manifest,
                  J_模型，
                  我_obs，
                  我的意思是，
                  我_var，
                  我解决了，
                  I_随机斜率，
                  I_randomint)
I.fit &lt;- mxRun(I_model)
]]></description>
      <guid>https://stats.stackexchange.com/questions/646508/how-to-get-estimated-value-of-random-slopes-and-random-intercepts-from-a-fitted</guid>
      <pubDate>Sat, 04 May 2024 19:33:31 GMT</pubDate>
    </item>
    <item>
      <title>如何从两个泊松变量之和中消除协方差？</title>
      <link>https://stats.stackexchange.com/questions/646506/how-to-remove-the-covariance-from-the-sum-of-two-poisson-variables</link>
      <description><![CDATA[我们如何从两个泊松随机变量之和中消除协方差？
我生成了两个具有相同 lambda 的泊松分布变量序列，并向这两个序列添加了第三个泊松分布变量以创建相关变量。
每个变量的均值和方差仍然相等。
当我对它们求和时，平均值是平均值之和，但由于协方差，方差不是方差之和。确实如此
$$var(x1+x2) = var(x1)+var(x2)+2cov(x1,x2)$$
我可以使用什么算法来消除协方差以恢复泊松分布？]]></description>
      <guid>https://stats.stackexchange.com/questions/646506/how-to-remove-the-covariance-from-the-sum-of-two-poisson-variables</guid>
      <pubDate>Sat, 04 May 2024 19:13:53 GMT</pubDate>
    </item>
    <item>
      <title>变量模型中误差的似然公式是什么？</title>
      <link>https://stats.stackexchange.com/questions/646505/what-is-the-likelihood-formula-for-an-error-in-variable-model</link>
      <description><![CDATA[我正在比较不同模型的能力，以解释我对 (X,Y) 与 AIC 的联合观察，我需要其可能性。
如何计算维基百科上指定的变量模型中的错误 (X,Y) 的可能性：https://en.wikipedia.org/wiki/Errors-in-variables_models#Motivating_example
和屏幕截图在这里：

它只是 L(η)*L(ε) 吗？是否还有其他常见的回归似然指标？例如，我知道对于标准回归 y = α + βx + ε，L(ε) 等于 L(y|x)，对吗？我也会对这些类型的可能性感兴趣。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/646505/what-is-the-likelihood-formula-for-an-error-in-variable-model</guid>
      <pubDate>Sat, 04 May 2024 19:10:04 GMT</pubDate>
    </item>
    <item>
      <title>为什么SHAP公式没有说明|S| =|F|-1？</title>
      <link>https://stats.stackexchange.com/questions/646504/why-does-the-shap-formula-not-state-that-s-f-1</link>
      <description><![CDATA[我最近阅读了论文“解释模型预测的统一方法”作者：斯科特·伦德伯格 (Scott M. Lundberg) 和李秀仁 (Su-In Lee)。在论文中，他们确定特征 $i$ 的 Shapley 值定义为
\begin{方程}
\phi_i=\sum_{S \subseteq F \反斜杠\{i\}} \frac{|S| !(|F|-|S|-1) !}{|F| !}\left[f_{S \cup\{i\}}\left(x_{S \cup\{i\}}\right)-f_S\left(x_S\right)\right]
\标签{数学：沙普利}
\end{方程}
其中 $F$ 是包含所有特征的集合，$S$ 是 $F$，其中删除了功能 $i$（$S \subseteq F \反斜杠 i$）。我找不到任何说明，说明为什么在删除一项功能后，公式中未执行以下简化：
$|S| = |F|-1 \Longrightarrow \frac{|S| !(|F|-|S|-1) !}{|F| !} = \frac{|F-1| !0 !}{|F| !} = \frac{1}{|F|}$
这意味着我们可以直接写
\begin{方程}
\phi_i=\frac{1}{|F|}\sum_{S \subseteq F \backslash\{i\}} \left[f_{S \cup\{i\}}\left(x_{S \cup \{i\}}\right)-f_S\left(x_S\right)\right]。
\end{方程}
我在任何地方都找不到这种简化，我也不知道为什么，但我怀疑我在某种程度上误解了沙普利的概念。有谁知道我的简化是否错误，如果是，为什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/646504/why-does-the-shap-formula-not-state-that-s-f-1</guid>
      <pubDate>Sat, 04 May 2024 18:52:48 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 GLICKO1 或 GLICKO2 评级计算获胜概率？</title>
      <link>https://stats.stackexchange.com/questions/646502/how-to-calculate-win-probability-using-glicko1-or-glicko2-ratings</link>
      <description><![CDATA[我很难找到使用 GLICKO1 和 ClICKO2 评级计算非平局游戏获胜概率的公式。其实我需要一个功能。有了双方的评级、mu、phi 和 sigma，我需要计算获胜概率。我需要 GLICKO1 和 GLICKO2 评级的公式
我找到了 GlICKO 获胜概率的源代码，尽管它缺乏相关方程的注释（特别是如果不可能平局的话），而且我不知道如何正确采用它。还有一篇论文，它涉及到的 mu、phi 和 sigma 对我来说不太明显。你能帮我获得正确的功能吗？
 defcompute_prob(r1, r2):
        ”“”
        返回评级为 r1 的玩家击败评级为 r2 的玩家的概率。

       有关更多背景信息，请参阅“Glicko Paper”
        `_
       ”“”
       r_diff = (r2[0] - r1[0]) / 400.0
       root_square_std = np.sqrt(r1[1]**2 + r2[1]**2)
       g = glicko2.Player(*r1)._g(r1[1])
       arg = g * root_square_std * r_diff
       概率 = 1.0 / (1 + 10**arg)
       退货问题

什么产生了人工智能
对于格力高 1
&lt;代码&gt;
    def gliko1_win_probability(玩家评级,
                                玩家_mu，
                                玩家_phi，
                                玩家西格玛，
                                对手评级，
                                对手_mu,
                                对手_phi，
                                对手西格玛）：
        定义 g(phi):
            返回 1 / math.sqrt(1 + 3 * math.pow(phi, 2) / math.pow(math.pi, 2))

        def E(mu, opp_mu, opp_phi):
            返回 1 / (1 + math.exp(-g(opp_phi) * (mu - opp_mu)))

        玩家获胜概率 = E(玩家_mu, 对手_mu, 对手_phi)
        返回player_win_probability

对于 GCLICO 2
 def glicko2_win_probability(player_ rating,
                                玩家_mu，
                                玩家_phi，
                                玩家西格玛，
                                对手评级，
                                对手_mu,
                                对手_phi，
                                对手西格玛）：
            定义 g(phi):
                返回 1 / math.sqrt(1 + 3 * math.pow(phi, 2) / math.pow(math.pi, 2))

            def E(mu, opp_mu, opp_phi):
                返回 1 / (1 + math.exp(-g(opp_phi) * (mu - opp_mu)))

            mu = (玩家评分 - 1500) / 173.7178
            opp_mu =（对手评级 - 1500）/ 173.7178

            玩家获胜概率 = E(玩家_mu, opp_mu, 对手_phi)
            返回player_win_probability
]]></description>
      <guid>https://stats.stackexchange.com/questions/646502/how-to-calculate-win-probability-using-glicko1-or-glicko2-ratings</guid>
      <pubDate>Sat, 04 May 2024 17:57:34 GMT</pubDate>
    </item>
    <item>
      <title>如何证明稳定的离散随机过程收敛于平稳过程？</title>
      <link>https://stats.stackexchange.com/questions/646501/how-to-show-that-a-stable-discrete-stochastic-process-converges-to-a-stationary</link>
      <description><![CDATA[所以我有一个离散随机过程定义为
$x_{k+1}=Ax_k+Bw_k$
其中 $w_k$ 是具有协方差 $R_w$ 的零均值高斯白噪声，并且其中 &lt; span class=&quot;math-container&quot;&gt;$A$ 的特征值位于单位圆盘中。
我可以获得 $x$ 的均值和协方差更新
$E[x_{k+1}]=AE[x_k]=A^{k+1}E[x_0]$
$E[x_{k+1}x_{k+1}^T]=AE[x_{k}x_{k}^T]A^T+BR_w B^T$
并且 $A$ 在单位圆盘中具有其特征值，这意味着 $A^n$ 变为到 $0$ 作为 $n$ 转到 $\infty $，我可以看到 $x$ 的平均值如何收敛到 $0$。 
但是，显然 $x$ 的协方差也应该收敛，使得 $x$ 收敛到平稳过程，但我在展示这一点时遇到困难，主要是因为积分协方差似乎具有无限数量的项 $A^nBR_wB^T[A^T]^n$ 的求和 与不同的 $n$。
如何证明 $x$ 的协方差也会随着 $k$ 的变化而收敛到 $\infty$？]]></description>
      <guid>https://stats.stackexchange.com/questions/646501/how-to-show-that-a-stable-discrete-stochastic-process-converges-to-a-stationary</guid>
      <pubDate>Sat, 04 May 2024 17:36:08 GMT</pubDate>
    </item>
    <item>
      <title>当 $A$ 和 $u$ 是 $x$ 的非线性函数时，$u^\top(u+Ax)$ 的期望</title>
      <link>https://stats.stackexchange.com/questions/646500/expectation-of-u-topuax-when-a-and-u-are-nonlinear-functions-of-x</link>
      <description><![CDATA[令 $x\in\mathbb R^d$ 和 $s=\operatorname{softmax}(x ）$。令 $y$ 为固定的 one-hot 向量使得
$$u = s-y \\
v =(\operatorname{diag}(s) - ss^\top)x$$
我对不等式$u^\top (u + v)\geq 0$感兴趣。具体来说，$x$ 上满足（或违反）不等式的条件。
可以将不等式重新排列为
$$u^\top Axe \geq -\Vert u\Vert^2$$
其中 $A=\operatorname{diag}(s) - ss^\top$。请注意， $A$ 是 $s$ 的协方差矩阵，因此它将是对称正半定矩阵。但是， $x$ 是唯一的自变量，并且 $A$ 和 $u$ 通过 softmax 函数 非线性地依赖于它.
我运行了一个模拟，改变了 $x$ 以及 $\Vert x\Vert$&lt; 的维度/跨度&gt;。下面显示的是 $\operatorname{E}\left[u^\top (u + Ax)\right]$ 的图。对于每个 $d$，我从单位超球面均匀采样 $1000$ 向量，并在y 轴。

可以看出，对于给定的 $d$，$k$ 存在阈值，这样不平等就平均而言成立。
那么我的问题如下：鉴于 $x$ 呈正态分布，那么 $\operatorname{E}\left[u^\top (u + Ax)\right]$? $d$ 如何融入表达式中？
如果$x$均匀分布在$k$超球面上会怎样？]]></description>
      <guid>https://stats.stackexchange.com/questions/646500/expectation-of-u-topuax-when-a-and-u-are-nonlinear-functions-of-x</guid>
      <pubDate>Sat, 04 May 2024 17:19:43 GMT</pubDate>
    </item>
    <item>
      <title>使用从高斯分布中获取的相对较小的样本来稳健估计标准差</title>
      <link>https://stats.stackexchange.com/questions/646499/robust-estimation-of-standard-deviation-using-relatively-small-sample-taken-from</link>
      <description><![CDATA[我确定以前有人问过这个问题，但我似乎找不到令人信服的答案。
如果存在一个相对较小的集合（例如 3

使用样本 SD 的标准公式吗？
根据第一和第二四分位数估算 SD？

第二种方法似乎不太依赖极端观测，但它不是低估了总体SD吗？
我发现了一篇关于第二种方法的很好的论文，但其背后的想法是在只有 5 个数字的摘要可用并且样本中的各个观察结果未知时估计 SD。我也可以访问所有个人观察结果。
https://bmcmedresmethodol.biomedcentral.com/articles/10.1186 /1471-2288-14-135
附：我想补充一点，这个问题的实际应用是估计收缩压测量值的变异性，假设多次测量期间没有漂移，并且假设测量值受到正态分布的随机噪声的影响具有恒定的 SD。无法知道用于估计 SD 的样本中的测量值是否受到某些异常值的污染。根据 IQR 估计的 SD 几乎总是略小于由常规 (n-1) 公式估计的 SD。我不知道这表明什么。谢谢。
附注我刚刚发现这篇论文，我认为它可以解答我的问题： https://www.duo.uio.no/bitstream/handle/10852/48279/1978-1.pdf?sequence=1 本文中T5是基于我想使用的 IQR。]]></description>
      <guid>https://stats.stackexchange.com/questions/646499/robust-estimation-of-standard-deviation-using-relatively-small-sample-taken-from</guid>
      <pubDate>Sat, 04 May 2024 17:16:34 GMT</pubDate>
    </item>
    <item>
      <title>具有测量误差的工具变量</title>
      <link>https://stats.stackexchange.com/questions/646496/instrumental-variable-with-measurement-error</link>
      <description><![CDATA[我有一个与测量误差偏差和工具变量的使用相关的问题。假设我有一个观察到没有误差的连续结果变量 Y 和一个有测量误差的内生（连续）变量 X。令 Z 为 X 的（连续）工具，满足相关性和外生性条件，但 Z 也可观测到测量误差。我的数据是面板数据，我使用固定效果。
我可以在 2sls IV 型号上使用 Z 作为仪器吗？在什么条件下？
谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/646496/instrumental-variable-with-measurement-error</guid>
      <pubDate>Sat, 04 May 2024 16:48:09 GMT</pubDate>
    </item>
    <item>
      <title>如何检测短时间序列末尾的平稳状态？</title>
      <link>https://stats.stackexchange.com/questions/646494/how-to-detect-a-plateau-at-the-end-of-a-short-time-series</link>
      <description><![CDATA[在运动测试（螺旋测功法）中，参与者在进行逐渐加强的体育锻炼时，会连续测量他们的摄氧量。测量是定期进行的，例如每 10 秒一次。了解摄氧量在测量结束时是否达到稳定水平非常有用。我们正在谈论测试的最后一分钟左右。基本上，这取决于最终摄氧量是否仍在增加或是否趋于平缓。下图显示了三名参与者的测量结果。在左图中，看不到平台。中间的面板显示出清晰的平台，而右侧的面板则有些模糊。

存在多种关于如何检测平稳状态的启发式方法。所有这些在某种程度上都是任意的。不幸的是，没有可用的基本事实或黄金标准，因此无法使用监督方法。我想知道是否有一种原则性的方法来检测时间序列中的平稳状态。
我自己的想法如下：

使用 LOESS 平滑测量结果（上图中的黑色曲线）。如图所示，测量结果有些噪音。
如果预测平滑数据的最后一个 $x$（例如 6 个）测量值的标准差低于特定阈值，则检测到稳定状态。

我的想法是，小的标准偏差意味着测量值变化很小/大致恒定。这仍然引出了一个问题，即如何选择最后平滑测量的标准差阈值，低于该阈值则声明稳定。
我的问题：上面的算法有意义吗？如何改进？可以使用哪些其他算法/启发式方法来检测测量结束时的平稳状态？]]></description>
      <guid>https://stats.stackexchange.com/questions/646494/how-to-detect-a-plateau-at-the-end-of-a-short-time-series</guid>
      <pubDate>Sat, 04 May 2024 15:34:14 GMT</pubDate>
    </item>
    <item>
      <title>与病理分布的卷积</title>
      <link>https://stats.stackexchange.com/questions/646483/convolution-with-a-pathological-distribution</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/646483/convolution-with-a-pathological-distribution</guid>
      <pubDate>Sat, 04 May 2024 11:39:39 GMT</pubDate>
    </item>
    <item>
      <title>关于均匀分布的阶次统计的练习</title>
      <link>https://stats.stackexchange.com/questions/646475/exercise-about-order-statistics-from-uniform-distribution</link>
      <description><![CDATA[我正在尝试解决有关订单统计的练习。
练习如下：
&lt;块引用&gt;
设 $U_{(1)}&lt; \ldots  是均匀分布 U(0,1) 的阶次统计量。
显示 $(-\log[U_{(r)}/U_{(r+1)}]^r) \overset{\underset{\mathrm{d }}{}}{=}Z_{n-r+1}$ 其中 $Z_1, Z_2, \ldots ,Z_n$ 是来自 &lt; span class=&quot;math-container&quot;&gt;$\rm Exp(1).$

解决方案首先显示 $(-\log U_{(r)}) \overset{\underset{\mathrm{d}}{}}{=}\ frac{1}{n}Z_1+\cdots+\frac{1}{r}Z_{n-r+1}$ 其中 $Z_1,\ldots,Z_n$  是来自 $\rm Exp(1) $ 的 iid，到目前为止我也明白。
然后解决方案说 $(-\log[U_{(r)}/U_{(r+1)}]) \overset{\underset{\mathrm {d}}{}}{=}(\frac{1}{n}Z_1+\cdots+\frac{1}{r}Z_{n-r+1})-(\frac{1}{n}Z_1+ \cdots+\frac{1}{r+1}Z_{n-r})=\frac{1}{r}Z_{n-r+1}$。因此 $(-\log[U_{(r)}/U_{(r+1)}]^r) \overset{\underset{\mathrm{d}}{} }{=}Z_{n-r+1}$。
但是我们能做这么简单的减法吗？
无论如何，我知道从一个著名的（？）结果得出的结论是正确的

（这是霍格的名著《数理统计导论》中的练习之一。）
由此可知 $(-\log U_{(r)}) \overset{\underset{\mathrm{d}}{}}{=} X_{(n-r+1)}$ 其中 $X_1,\dots,X_n$ 是来自 Exp(1) 的 iid。和 $(-\log[U_{(r)}/U_{(r+1)}]^r) \overset{\underset{\mathrm{d}}{} }{=}r(X_{(n-r+1)}-X_{(n-r)})\overset{\underset{\mathrm{d}}{}}{=}\mathrm{Exp}(1) 。 $
但是我无法理解解决方案中的减法声明。]]></description>
      <guid>https://stats.stackexchange.com/questions/646475/exercise-about-order-statistics-from-uniform-distribution</guid>
      <pubDate>Sat, 04 May 2024 06:05:34 GMT</pubDate>
    </item>
    <item>
      <title>softmax 与 3D 图形中的向量归一化相同吗？</title>
      <link>https://stats.stackexchange.com/questions/646480/is-softmax-the-same-as-vector-normalization-in-3d-graphics</link>
      <description><![CDATA[我刚刚发现了机器学习中的softmax 函数。它从数字向量中创建均匀的概率分布，这意味着所有数字最多为 1。
这听起来很像向量标准化 给出 3D 图形中长度为 1 的向量（线性代数）。
谁能解释一下这两者之间的区别吗？我希望这不是一个愚蠢的问题，我能得到答案。]]></description>
      <guid>https://stats.stackexchange.com/questions/646480/is-softmax-the-same-as-vector-normalization-in-3d-graphics</guid>
      <pubDate>Sat, 04 May 2024 00:42:58 GMT</pubDate>
    </item>
    </channel>
</rss>