<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Tue, 02 Jan 2024 03:14:51 GMT</lastBuildDate>
    <item>
      <title>如果使用多种不同方法确定年龄，您能否创建人口年龄结构？</title>
      <link>https://stats.stackexchange.com/questions/635983/can-you-create-an-age-structure-of-population-if-the-age-was-established-using</link>
      <description><![CDATA[我想分析样本的年龄结构。然而，我并没有给出年龄本身，而是必须使用具有不同确定系数的多种方法来确定它们（并非每种方法都可以用于每个分析样本），其中一些方法运行两次以检查其可重复性。
因此，对于每个人，我通过不同的方法有不同的估计年龄，如下图所示：

由于存在多个值，我不确定如何创建年龄结构，因为一些结果显示一个人的可能年龄范围超过二十岁。我很确定你不能仅仅平均年龄，因为这些是具有不同确定系数的不同方法。
有人可以给我这方面的建议吗？您会尝试从所有方法中创建一个年龄估计，创建重叠的类别还是以完全不同的方式进行？
感谢您的任何评论，老实说我很迷茫。]]></description>
      <guid>https://stats.stackexchange.com/questions/635983/can-you-create-an-age-structure-of-population-if-the-age-was-established-using</guid>
      <pubDate>Tue, 02 Jan 2024 02:26:29 GMT</pubDate>
    </item>
    <item>
      <title>AFT模型下线性秩检验的计数过程相等性</title>
      <link>https://stats.stackexchange.com/questions/635981/counting-process-equality-for-linear-rank-test-under-aft-model</link>
      <description><![CDATA[我目前正在阅读这篇论文：
使用截尾数据的线性秩检验估计回归参数 - A.A. Tsiatis，《统计年鉴》18(1)：354-372，1990。
我正在尝试验证一个看似简单的平等陈述，但我很难理解为什么该陈述是正确的。在底页第358页，作者给出了函数$S_N(\beta)$的一组两个等式语句。我可以验证第二个等式（就在（3.2）之上），并且我可以验证行（3.2）不明白包含（3.3）如何保留原始语句的等式。如果能解释为什么可以包含第 (3.3) 行，我们将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/635981/counting-process-equality-for-linear-rank-test-under-aft-model</guid>
      <pubDate>Tue, 02 Jan 2024 01:52:45 GMT</pubDate>
    </item>
    <item>
      <title>为什么attention中卷积层的最大路径长度$O(n/k)$就足够了？</title>
      <link>https://stats.stackexchange.com/questions/635979/why-is-the-maximum-path-length-for-convolutional-layer-on-k-in-attention-is</link>
      <description><![CDATA[在表 1 第三行中提到了这一点。为什么是$O(n/k)$？以 9 个标记中的 2 个标记的 1d 卷积为例，步长 $1$。它不会是 $n/k$ 或 $9/2=4.5$ 而是大约$n-1$ 或 $8$。
这篇论文没有提到跨步，所以我认为它适用于任何跨步。
来自论文：（链接）
内核宽度 k &lt; 的单个卷积层n 不连接所有输入输出对
职位。 在连续内核的情况下，这样做需要一堆 O(n/k) 卷积层，
或 O(logk(n)) 在扩张卷积的情况下 [18]，]]></description>
      <guid>https://stats.stackexchange.com/questions/635979/why-is-the-maximum-path-length-for-convolutional-layer-on-k-in-attention-is</guid>
      <pubDate>Mon, 01 Jan 2024 23:33:15 GMT</pubDate>
    </item>
    <item>
      <title>如何对收入四分位数进行回归？</title>
      <link>https://stats.stackexchange.com/questions/635977/how-do-i-regress-income-quartiles-against-each-other</link>
      <description><![CDATA[我想了解不同收入四分位数的态度是否有所不同。我的主管提到了虚拟编码和四分位数相互回归，但是，我有点不知道如何做到这一点。
我是否只需将每个受访者编码为四分位数的变量作为多元回归中的预测变量（与其他人口统计控制一起？）或者我是否必须运行单独的回归，将每个虚拟编码四分位数与最低参考四分位数进行比较。&lt; /p&gt;
但是，如果这是错误的方法，我愿意接受建议。]]></description>
      <guid>https://stats.stackexchange.com/questions/635977/how-do-i-regress-income-quartiles-against-each-other</guid>
      <pubDate>Mon, 01 Jan 2024 21:16:23 GMT</pubDate>
    </item>
    <item>
      <title>我如何知道我的数据是否更适合幂曲线或对数曲线？</title>
      <link>https://stats.stackexchange.com/questions/635975/how-can-i-know-if-my-data-better-fits-a-power-or-a-log-curve</link>
      <description><![CDATA[我有两个数组，分别代表某个实验（1000 个样本）中的自变量和因变量。我想知道它们之间的函数关系。具体来说，我想在这两个选项之间做出决定：

对数关系：$y = a * log^b(x) + c$。
幂关系：$y = a * x^b + c$。

我使用 scipy.curve_fit 函数如下。对于对数关系：
fit_func = lambda x,a,b,c: a * (np.log(x))**b + c
popt, pcov = curve_fit(fit_func, x, y)
plt.plot(x, fit_func(x, *popt))

对于幂关系：
fit_func = lambda x,a,b,c: a * x**b + c
popt, pcov = curve_fit(fit_func, x, y)
plt.plot(x, fit_func(x, *popt))

在这两种情况下，绘图与原始数据（y 与 x）的绘图都很好地重叠。这些是我得到的值：

对于对数曲线：[a,b,c] = [0.02520347 3.43184802 1.88396929]
对于功效曲线：[a,b,c] = [ 0.70305951 0.49492494 -0.09505299]

根据这些图，我无法决定哪个模型能更好地描述数据。
有没有更好的方法来判断对数模型和幂模型哪个更好？]]></description>
      <guid>https://stats.stackexchange.com/questions/635975/how-can-i-know-if-my-data-better-fits-a-power-or-a-log-curve</guid>
      <pubDate>Mon, 01 Jan 2024 20:37:33 GMT</pubDate>
    </item>
    <item>
      <title>通过残差平方回归估计方差</title>
      <link>https://stats.stackexchange.com/questions/635974/estimating-variance-by-regressing-squared-residuals</link>
      <description><![CDATA[对于线性回归，估计新观测值的预测范围的一种方法是计算新观测值的预测区间。
如果将残差平方与初始预测变量进行回归会怎样？这是估计新观察方差的另一种方法吗？如果不是，那么该回归实际预测的是什么？
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/635974/estimating-variance-by-regressing-squared-residuals</guid>
      <pubDate>Mon, 01 Jan 2024 19:44:39 GMT</pubDate>
    </item>
    <item>
      <title>什么研究的统计模型（如果有）适合此应用？</title>
      <link>https://stats.stackexchange.com/questions/635973/what-studied-statistical-model-if-any-fits-this-application</link>
      <description><![CDATA[我无法确定哪种统计模型或方法适合我的应用程序。
我的情况如下：
我想创建一个股票交易代理，根据一段时间内收到的报价数据来交易单个股票-现金对。
为了简单起见：

如果代理人只持有现金，他们可以采取的行动是购买 1 单位股票或什么也不做。
如果代理商持有现金和股票或仅持有股票，他们可以采取的行动是不采取任何行动或出售该单位股票。
如果代理商没有持有现金和股票，则代理商唯一可以采取的行动就是不采取任何行动。

我将使用的符号是这样的：

$t_0, t_1 \in \mathbb{R}_{\geq 0}$：分别是第一和第二订单簿更新的时间。 

$\mathbb{B}_0, \mathbb{B}_1 \in ({\mathbb{R}_{\geq 0}})^4$ ：分别在 $t_0$ 和 $t_1$ 接收的报价数据。

$v_0, v_1 \in \mathbb{R}_{\geq 0}$：$t_0$ 和 $t_1$ 分别。

$w_0, w_1 \in \mathbb{R}_{\geq 0}$：$t_0$ 和 $t_1$ 分别。

$L(.,.,.)$表示根据当前报价数据、当前持有现金和当前持有的资产的清算价值库存


单周期设置如下：

代理观察 $o_0 = (t_0,\mathbb{B}_0, v_0, w_0)$
智能体选择一个动作$a_0^* \in \mathcal{A}_0$（这个决定可能是通过对时间的预测来通知的）下一个报价，$\hat{t_0}$，下一个报价的预测，$\hat{\mathbb{B }_{1}}$，以及对 $t_1$ 中因任何 $a_0 \in \mathcal{A}_0$、$\hat{v_1}_{|a_0}$ 和 $\hat{w_1}_{|a_0}$，对于所有 $a_0 \in \mathcal{A}_0$ .
代理观察 $o_1 = (t_1,\mathbb{B}_1, v_1, w_1)$
代理接收 $l_0 = L(\mathbb{B}_1, v_1, w_1) - L(\mathbb{B}_0, v_0, w_0)$ （观察到 $o_0$ 时获取 $a_0$ 所得的利润，然后 $o_1$ 正在被观察）。

我的直觉表明某种马尔可夫决策过程适合于此，但我不确定，因为即使有很大程度上简化的假设（对于小订单来说可能大多如此）$a_0$ 不会影响 $\mathbb{B}_1$，我们仍然需要考虑 $a_0$ 将影响 $v_1$ 和 $w_1$ （例如，如果我们决定以 $t_0$ 购买一单位股票，这很可能会影响 $v_1$ 和 $w_1$) 即使我们做一些简单的事情，例如假设它仅确定性地基于当前报价， $\mathbb{B} _0$ （$t_0$ 和 $t_1$ 之间“没有发生任何事情”尊重报价数据），我们仍然需要为每个潜在的操作进行建模。
整个过程的目标是找到 $o_1$ 的函数，该函数在 $\mathcal 中输出操作{A}_0$ 最小化 $l_0$。
是否有一个我可以研究的此类问题的通用版本的名称，或者是否有一种简化其部分内容的方法，以便我可以将其放入更深入研究的框架中？]]></description>
      <guid>https://stats.stackexchange.com/questions/635973/what-studied-statistical-model-if-any-fits-this-application</guid>
      <pubDate>Mon, 01 Jan 2024 19:27:19 GMT</pubDate>
    </item>
    <item>
      <title>评分数据和 IRT 模型</title>
      <link>https://stats.stackexchange.com/questions/635972/score-data-and-irt-models</link>
      <description><![CDATA[我计划使用 IRT 模型（二进制数据）对我的考试数据进行建模。考试包含有四个可选答案（一个正确）的问题，但考试系统仅提供二进制数据（正确/错误，IT 部门不会/无法向我提供原始数据）。因此，猜测正确答案的概率不是 0.5，而是 0.25。当最初有四种替代方案时，我如何/必须使用二进制 IRT 模型更改我的模型？我正在使用 R 包“ltm”。
珍妮]]></description>
      <guid>https://stats.stackexchange.com/questions/635972/score-data-and-irt-models</guid>
      <pubDate>Mon, 01 Jan 2024 18:19:44 GMT</pubDate>
    </item>
    <item>
      <title>将常数乘以特征对回归系数的影响[重复]</title>
      <link>https://stats.stackexchange.com/questions/635968/effect-on-regression-coefficients-by-multiplying-a-constant-to-a-feature</link>
      <description><![CDATA[我在 Coursera 上解决一个测验问题，发现了一个有趣的问题。
&lt;块引用&gt;
如果将给定特征的值加倍（即特定列）
特征矩阵），最小二乘估计会发生什么
其他每个特征的系数？ （假设你没有其他
依赖于加倍特征的特征，即没有交互
条款）。

我的问题是：

我认为，其他系数将保持不变。如果是这样，有人可以告诉我其背后的逻辑解释吗？
缩放后的特征的系数怎么样？假设我们将功能加倍且现有权重为 $m$，它是否等于 $m/2$ ？
如果还包含交互术语怎么办？那里会发生什么？

因此，总的来说，我可以说回归系数与原点的变化无关，但与规模无关。这是正确的吗？如果我们移动，系数保持不变。然而，当我们缩放系数时，系数会改变吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/635968/effect-on-regression-coefficients-by-multiplying-a-constant-to-a-feature</guid>
      <pubDate>Mon, 01 Jan 2024 16:43:10 GMT</pubDate>
    </item>
    <item>
      <title>如何处理缺失的纵向结果和纵向协变量？</title>
      <link>https://stats.stackexchange.com/questions/635967/how-to-deal-with-missing-longitudinal-outcome-and-longitudinal-covariate</link>
      <description><![CDATA[我有具有连续纵向结果的数据，其中一个协变量是分类纵向变量。两者皆有失踪，同时被收集。因此，这意味着如果结果缺失，协变量也会缺失。
我的问题如下：

如果协变量存在缺失，直接似然是否仍然无偏？
如果我使用链式方程（SAS 中的 fcs 或 R 中的 mouse）进行多重插补，我是否应该在纵向结果之前首先插补缺失的纵向协变量？这样做可以吗？还是一次性将它们归结到一起更好？
]]></description>
      <guid>https://stats.stackexchange.com/questions/635967/how-to-deal-with-missing-longitudinal-outcome-and-longitudinal-covariate</guid>
      <pubDate>Mon, 01 Jan 2024 16:31:36 GMT</pubDate>
    </item>
    <item>
      <title>梯度下降的反向传播是否使用损失相对于权重的梯度来更新权重和偏差？</title>
      <link>https://stats.stackexchange.com/questions/635966/does-back-propagation-with-gradient-descent-update-the-weights-and-biases-using</link>
      <description><![CDATA[我绝对是这个领域的初学者。目前正在Andrew Ng的指导下学习Course时代的监督机器学习。我已经进入该续集第二门课程的第二周了。
我实际上对反向传播感到困惑。我了解反向传播的理论知识，它基本上是微分的链式法则，并存储中间导数以查找先验导数，与传统过程相比，这节省了很多迭代和时间。但我无法完全理解反向传播如何集成到梯度下降中。
让我详细阐述一下我的困惑，然后我希望你能明白我所陷入的困境。
假设网络中有 1 个隐藏层。所以总共有 3 层：初始层、隐藏层和最终层。我知道这里我们分配随机权重和偏差。但是我们如何评估梯度下降呢？我的意思是，在线性回归的情况下，我们已经看到权重和偏差随着学习率和成本函数导数相对于权重/偏差的关联而变化。$$w_1 = w_1- \alpha*\frac{d}{dw_1}J$$ 其中 J 是成本函数。神经网络也会发生同样的事情吗？
我的意思是 $$w^3 = w^3 - \alpha*\frac{d}{dw^3}J$$$$w^2_n = w^2_ n - \alpha*\frac{d}{dw^2_n}J$$ 其中 $w^ 3=&gt;$第三层的权重和$w^2_n=&gt;$第二层第n个单元的权重]]></description>
      <guid>https://stats.stackexchange.com/questions/635966/does-back-propagation-with-gradient-descent-update-the-weights-and-biases-using</guid>
      <pubDate>Mon, 01 Jan 2024 15:58:27 GMT</pubDate>
    </item>
    <item>
      <title>了解蒙特卡罗积分中的重要性采样</title>
      <link>https://stats.stackexchange.com/questions/635943/understanding-importance-sampling-in-monte-carlo-integration</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/635943/understanding-importance-sampling-in-monte-carlo-integration</guid>
      <pubDate>Mon, 01 Jan 2024 05:16:12 GMT</pubDate>
    </item>
    <item>
      <title>与协方差矩阵相关的术语“球形”的起源？</title>
      <link>https://stats.stackexchange.com/questions/635834/origin-of-the-term-spherical-in-relation-to-covariance-matrices</link>
      <description><![CDATA[据我了解，所有对角线元素相等且所有非对角线元素也相等（但与对角线元素不同）的协方差矩阵称为“球形”。我很好奇这个词的由来。据推测它有几何解释。是不是就意味着对于一个球体来说，从中心到表面上任意点的距离都相等那么简单？这是否也意味着表面上的点分布是均匀的？]]></description>
      <guid>https://stats.stackexchange.com/questions/635834/origin-of-the-term-spherical-in-relation-to-covariance-matrices</guid>
      <pubDate>Fri, 29 Dec 2023 17:42:30 GMT</pubDate>
    </item>
    <item>
      <title>如何仅使用因变量的滞后值来实施动态回归预测</title>
      <link>https://stats.stackexchange.com/questions/635236/how-to-implement-dynamic-regression-forecasting-using-only-lagged-values-of-the</link>
      <description><![CDATA[据我了解，Arima 误差回归（也称为动态回归）通常使用外生变量来实现，是否可以仅使用内生变量来实现动态回归？这将如何实施？
以下是使用外生变量（自变量）的回归方程
\begin{align}y_t = \beta_0 + \beta_1 x_{1,t} + \dots + \beta_k x_{k,t} + \varepsilon_t \hspace{1.5厘米}(1.1)\结束{对齐}
下面是动态回归方程，其中 $\eta_t$ 是 ARIMA(1,1,1) 过程。
\begin{align*}
  y_t &amp;= \beta_0 + \beta_1 x_{1,t} + \dots + \beta_k x_{k,t} + \eta_t,\hspace{1.25cm} (2.1) \\
      &amp; (1-\phi_1B)(1-B)\eta_t = (1+\theta_1B)\varepsilon_t,
\hspace{1cm} (2.2)
\end{对齐*}
$\eta_t$ 是如何计算的？因为如果我将后移符号转换为方程 2.2 中的形式，我应该得到以下结果：
\begin{align}\eta_t = \varepsilon_t + \theta_1\varepsilon_{t-1} + \eta_{t-1} + \phi_1(\eta_{t- 1} - \eta_{t-2}) \hspace{0.36cm} (2.3)\end{align}
是否可以将方程 2.1 转换为使用内生变量（因变量），如下所示：
\begin{align}y_t = \beta_0 + \beta_1 y_{t-1} + \dots + \beta_k y_{t-k} + \eta_t \hspace{1.2cm} (3.1)\end{对齐}
问题：

除了将所有外生变量替换为内生变量之外，3.1 的实施方式与 1.1 有何不同？
公式 2.3 中所示的 ARIMA(1,1,1) 多项式表示法正确吗？
]]></description>
      <guid>https://stats.stackexchange.com/questions/635236/how-to-implement-dynamic-regression-forecasting-using-only-lagged-values-of-the</guid>
      <pubDate>Tue, 19 Dec 2023 08:10:46 GMT</pubDate>
    </item>
    <item>
      <title>多类正确评分规则分解：跨类别的（加权）平均值？</title>
      <link>https://stats.stackexchange.com/questions/632644/multiclass-proper-scoring-rule-decomposition-weighted-average-across-the-cate</link>
      <description><![CDATA[我找到了一个Python函数，可以计算各种适当的评分规则的分解，例如Br​​ier得分和对数损失。然而，它似乎不接受数组作为参数，所以如果我想使用这个函数，我似乎仅限于二进制结果......
...但我想了解两个以上的类别！
但是，通过循环遍历各种分类结果和预测概率，我可以针对函数中的这一缺陷编写一个可能的破解方案。
将 pandas 导入为 pd
将 numpy 导入为 np
从 model_diagnostics.scoring 导入分解，SquaredError
np.随机.种子(2023)

# 真值矩阵：列表示三个类别
# 五个观察值，每个观察值可以属于三个类别之一
#
y_true = np.array([
    [0, 1, 0],
    [0, 1, 0],
    [1,0,0],
    [0,0,1],
    [0,0,1]
]）

# 预测矩阵
#
y_pred = np.array([
    [0.2,0.5,0.3],
    [0.1,0.8,0.1],
    [0.7,0.1,0.2],
    [0.6,0.1,0.3],
    [0.2,0.3,0.5]
]）

&#39;&#39;&#39;
# 尝试用数组来做，但失败了
#
分解（
    y_true，
    y_预测，
    评分函数 = SquaredError()
）
&#39;&#39;&#39;

# 循环遍历类别以获得“分解”结果每个类别的信息
#
dfs = []
对于范围 (3) 内的 i：
    
    d = 分解(
        y_true[:, i],
        y_pred[:, i],
        评分函数 = SquaredError()
    ）
    
    # 创建一个数据框，每个类别占一行
    #
    df_now = pd.DataFrame()
    df_now[“N”] = [np.sum(y_true[:, i])]
    df_now[“校准错误”] = d[“校准错误”]
    df_now[“歧视”] = d[“歧视”]
    df_now[“不确定性”] = d[“不确定性”]
    df_now[“分数”] = d[“分数”]
    
    # 将该数据框保存到列表中
    #
    dfs.append(df_now)

# 连接所有单行数据框
#
df = pd.concat(dfs).reset_index(drop = True)

# 四列的平均值，按每个类别的实例加权
#
错误校准 = np.sum(df[“错误校准”] * df[“N”])/np.sum(df[“N”])
歧视 = np.sum(df[“歧视”] * df[“N”])/np.sum(df[“N”])
不确定性 = np.sum(df[“不确定性”] * df[“N”])/np.sum(df[“N”])
分数 = np.sum(df[“分数”] * df[“N”])/np.sum(df[“N”])

当我尝试并根据每个类别的实例数加权计算每个组件（错误校准、歧视、不确定性和总分）的平均值时，我是否会得到每个组件的正确结果，就好像我计算了“正确”使用以数组作为参数的函数的方式？如果没有，是否有其他方法可以仅使用逐个类别的结果来找到整个数据集的分解？
（奖励：对于其他评分规则或可以观察到多个类别的多标签问题，故事是否会发生变化？）]]></description>
      <guid>https://stats.stackexchange.com/questions/632644/multiclass-proper-scoring-rule-decomposition-weighted-average-across-the-cate</guid>
      <pubDate>Wed, 29 Nov 2023 19:05:34 GMT</pubDate>
    </item>
    </channel>
</rss>