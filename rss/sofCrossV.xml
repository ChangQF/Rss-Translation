<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Fri, 22 Nov 2024 12:33:58 GMT</lastBuildDate>
    <item>
      <title>YouTube 缩略图 A/B/C 测试中的留存模式分析</title>
      <link>https://stats.stackexchange.com/questions/657681/accounting-for-retention-patterns-in-youtube-thumbnail-a-b-c-testing</link>
      <description><![CDATA[我正在使用 YouTube 缩略图 A/B/C 测试功能，但遇到了令人难以置信的结果 - 我正在尝试找出原因。一种理论是 YouTube 在计算时没有考虑留存率，观看时间的巨大差异可能会影响计算结果。
上下文：
视频长达数小时（2-3 小时）。
大多数观众（约 50%）在第一分钟内就离开了
一小部分人观看了整个视频（7-10%）。
测试平台将展示次数（观看缩略图的人）平均分配给缩略图。
成功指标为：（缩略图变体的观看时间）/（所有变体的总观看时间）
示例场景：
如果 10 个人被分配到 2 个缩略图（每个 5 个），并且其中一个组恰好包含观看整个视频的单个观众，这可能会严重扭曲结果。我的直觉是，这种高方差需要更多样本才能获得可靠的结果。
问题：

根据观看时间百分比计算最佳缩略图时，是否需要考虑留存模式？或者这些信息是否不需要直接处理，因为它将反映在观看时间份额百分比中。

如果是这样，需要多少样本才能获得具有统计意义的结果？我需要用什么公式来计算这个？

]]></description>
      <guid>https://stats.stackexchange.com/questions/657681/accounting-for-retention-patterns-in-youtube-thumbnail-a-b-c-testing</guid>
      <pubDate>Fri, 22 Nov 2024 12:07:33 GMT</pubDate>
    </item>
    <item>
      <title>两组样本数不同但增长至相同值的相关性</title>
      <link>https://stats.stackexchange.com/questions/657680/correlation-of-two-sets-growing-to-the-same-value-but-different-number-of-sample</link>
      <description><![CDATA[如何获取两个不同长度的集合之间的相关性？我知道皮尔逊相关性不起作用。但是如果它们增长到相同的值，我可以做些什么吗？这就是我的意思。
假设我有两个集合：
[1, 2, 3, 4] 和 [1, 1, 2, 2, 1, 3]
我们可以看到它们的长度不同，但总和相同。
[1, 3, 6, 10] 和 [1, 2, 4, 6, 7, 10]
我们可以看到它们都累积到 10。
我在想，如果我将它们绘制成 x 轴上的累积和以及 y 轴上的原始点。我可以像“连接点”一样。之后，我在想也许我可以对它们进行卷积或者类似的事情，或者像它们的内积？不太确定我在说什么。
这能行得通吗？你能建议一些可以帮助解决这个问题的方法吗？
非常感谢！
编辑：
在回答这些数据代表什么的问题时，这个问题是一个信号处理问题。
系统的工作方式如下。我在一段时间内收到随机数量的尖峰。就我上面的示例而言，假设为 10 秒。
每 10 秒，我都会读取一些尖峰，但尖峰到达的时间与前一个尖峰的时间不同。这就是这个集合所代表的内容：
[1, 2, 3, 4] 和 [1, 1, 2, 2, 1, 3]
现在的问题是，这两者有多大关系？]]></description>
      <guid>https://stats.stackexchange.com/questions/657680/correlation-of-two-sets-growing-to-the-same-value-but-different-number-of-sample</guid>
      <pubDate>Fri, 22 Nov 2024 12:03:51 GMT</pubDate>
    </item>
    <item>
      <title>如何从 N-2 边际生成 N 维多元正态样本</title>
      <link>https://stats.stackexchange.com/questions/657678/how-to-generate-n-dimensional-multivariate-normal-sample-from-n-2-marginals</link>
      <description><![CDATA[我的“计算器”遇到了一个问题，它使用通过 N 维多元正态分布生成的样本。我在下面附上了一个代码片段来说明这个问题。
我的计算器从 sample_1 中提取：

M：对 sample_1 中的每个数字都敏感的数字
M_n：一个由 N 个数字组成的向量，每个数字都对 sample_1 中的一列且仅一列敏感

现在，我需要分析我的计算器对相关矩阵中一个特定元素的敏感度。我通过将 correlation_matrix_1 中的 (0, 1) 元素从 0.0 更改为 0.02 来实现。简而言之，问题在于 sample_2 中的第 3 列与 sample_1 中的第 3 列不同。这会导致 M_2 发生更改，这是不理想的结果。两个示例的屏幕截图都位于本消息的末尾，
现在的问题是：我如何从以下位置生成 sample_2 的第 0 列和第 1 列：

sample_1 的第 2 列 -&gt;修复 M_2
correlation_matrix_2

请注意，我必须能够对更大的矩阵执行此操作，尽管仍然需要每次更改一个矩阵元素。
import numpy as np

def main(correlation_matrix: np.ndarray, mc_seed: int = 1234,
n_trials: int = 10):
generator = np.random.default_rng(seed=mc_seed)
segment_factor_sample = generator.multivariate_normal(
mean=[0] * correlation_matrix.shape[0],
cov=correlation_matrix,
size=n_trials,
check_valid=&#39;raise&#39;)
returnsegment_factor_sample

if __name__ == &#39;__main__&#39;:
correlation_matrix_1 = np.array([[1.0, 0.0, 0.0],
[0.0, 1.0, 0.0],
[0.0, 0.0, 1.0]])
sample_1 = main(correlation_matrix_1)

correlation_matrix_2 = np.array([[1.0, 0.02, 0.0],
[0.02, 1.0, 0.0],
[0.0, 0.0, 1.0]])
sample_2 = main(correlation_matrix_2)


sample_1


sample_2]]></description>
      <guid>https://stats.stackexchange.com/questions/657678/how-to-generate-n-dimensional-multivariate-normal-sample-from-n-2-marginals</guid>
      <pubDate>Fri, 22 Nov 2024 11:33:44 GMT</pubDate>
    </item>
    <item>
      <title>GAMM 中的 AIC 值问题</title>
      <link>https://stats.stackexchange.com/questions/657675/problems-with-aic-values-in-gamms</link>
      <description><![CDATA[为了检验一个假设，我在 R 中使用广义加性混合模型，并使用 mgcv 包构建了以下模型：
 gam(Resp ~ s(Pred1, bs=&quot;cr&quot;) + s(Pred2, bs=&quot;cr&quot;) + s(Pred3, bs=&quot;cr&quot;) + s(Pred4, bs=&quot;cr&quot;) + ti(Pred3, Pred4) + s(Factor, bs=&quot;re&quot;), data=Data, family=binomial)

然后，我使用 dredge 函数（MuMIn 包）获取按 AIC 值递增排序的所有潜在模型的列表。在此列表中，前四个模型具有相同的 AIC 值，因此具有相同的 DeltaAIC 和 AIC 权重（见下图）。并且这种情况一直发生在以下模型中。
为什么会发生这种情况？这是估算 Pred1 以及 Pred3 和 Pred4 之间相互作用的问题吗？任何帮助都将不胜感激！
]]></description>
      <guid>https://stats.stackexchange.com/questions/657675/problems-with-aic-values-in-gamms</guid>
      <pubDate>Fri, 22 Nov 2024 11:07:37 GMT</pubDate>
    </item>
    <item>
      <title>使用看似不相关的回归检验两个不同回归的系数相等性</title>
      <link>https://stats.stackexchange.com/questions/657674/testing-equality-of-coefficients-from-two-different-regressions-with-seemingly-u</link>
      <description><![CDATA[我正在运行两个回归，一个嵌套在另一个中。
$$ y = \beta_1 X + \epsilon_1$$
$$ y = \beta_2 X + \beta_3 Z + \nu_2$$
我想评估两个方程式中的 X 系数是否相同 $$\hat\beta_{1} \neq \hat\beta_{2} ?$$
基本上，我想知道添加协变量 Z 是否会显著改变 y 和 X 之间的关联。
我尝试使用 R 执行此操作，如下所示：
#install.packages(&quot;systemfit&quot;)
library(systemfit)

# 指定两个方程式
eq2 &lt;- y ~ x + z
eq1 &lt;- y ~ x

# 将模型组合成一个系统
system &lt;- list(eq1 = eq1, eq2 = eq2)

# 拟合 SUR 模型
fit &lt;- systemfit(system, method = &quot;SUR&quot;, data=data_full2)

# 测试模型中 X 系数的相等性
linearHypothesis(fit, &quot;eq1_x = eq2_x&quot;)

但是，当我查看 eq2 的 fit 结果时，我发现与我分别计算每个回归时的情况非常不同。（使用 lm(y~x+z, data=data_full2)）。我理解两种情况下的结果可能会有所不同，但这是一个非常大的差异，因为在单独计算时，受限模型中的系数为 0.1，完整模型中的系数为 0.05，而在 SUR 计算中，两者均变为 0.1 左右。因此，当然，我的 linearHypothesis(fit, &quot;eq1_x = eq2_x&quot;) 命令的结果告诉我差异并不显著。
与两个独立的 lm() 相比，使用 systemfit() 命令运行系数时，系数变化如此之大，这正常吗？我是否仍应相信分析结果，即两个方程中的系数实际上并没有显著差异？]]></description>
      <guid>https://stats.stackexchange.com/questions/657674/testing-equality-of-coefficients-from-two-different-regressions-with-seemingly-u</guid>
      <pubDate>Fri, 22 Nov 2024 10:43:59 GMT</pubDate>
    </item>
    <item>
      <title>如何解释跨队列生存分析中低于 0.5 的一致性指数</title>
      <link>https://stats.stackexchange.com/questions/657670/how-to-interpret-concordance-index-below-0-5-in-cross-cohort-survival-analysis</link>
      <description><![CDATA[我正在进行生存分析，其中我使用跨队列验证进行性能评估（CV 策略无法更改，这是外部要求）。我选择的指标是一致性指数 (C 指数)。
我正在处理的队列非常多样化，我的模型不包含有关给定样本属于哪个队列的任何信息。这是故意的，主要是由于跨队列验证方法。
我遇到了一个问题，对于某些队列，C 指数始终低于 0.5。由于 0.5 代表随机预测，低于此阈值的值表明模型的表现比随机更差 - 但同时，这可能意味着恢复预测将产生比随机更好的性能。
我的问题是：

在这种情况下，C 指数怎么会低于 0.5？这可能是由于队列之间的异质性、训练数据过度拟合还是其他原因造成的？

这个结果是否有效或可以以有意义的方式解释？例如，它是否表明该模型系统地误解了这些特定队列中的生存关系？


就上下文而言，我使用的模型包括：

RandomSurvivalForest
GradientSurvivalBoosting
（均通过 Python 中的 sksurv 包实现）。

对于跨队列生存分析中 C 指数低于 0.5 的解释，或我的方法的潜在问题，任何见解都将不胜感激！]]></description>
      <guid>https://stats.stackexchange.com/questions/657670/how-to-interpret-concordance-index-below-0-5-in-cross-cohort-survival-analysis</guid>
      <pubDate>Fri, 22 Nov 2024 09:55:48 GMT</pubDate>
    </item>
    <item>
      <title>将函数应用于随机变量观测的影响[重复]</title>
      <link>https://stats.stackexchange.com/questions/657669/impact-of-applying-a-function-to-observations-from-random-variables</link>
      <description><![CDATA[我有一系列随机变量的观测值，这些观测值可以是：

IID（独立且相同分布）或
非IID（独立但不相同分布）。

如果我将相同的函数应用于序列中的所有观测值，我想了解它如何影响以下统计属性：

独立性和依赖性：独立性或依赖性结构是否保留？

相同分布（IID）：如果原始序列是IID，应用相同的函数是否会保留此属性？非 IID 序列可以变成 IID 吗？

LLN 和 CLT：如果原始序列满足弱大数定律或强大数定律 (LLN) 或中心极限定理 (CLT)，那么在应用相同函数后，这些函数是否仍然成立？


此外，如果我对观察结果应用不同的函数而不是相同的函数，答案会如何变化？
如果可能，请提供有关此主题的进一步阅读的参考资料或资源。]]></description>
      <guid>https://stats.stackexchange.com/questions/657669/impact-of-applying-a-function-to-observations-from-random-variables</guid>
      <pubDate>Fri, 22 Nov 2024 09:44:33 GMT</pubDate>
    </item>
    <item>
      <title>在随机森林中绘制预测值与实际值时出现的离散垂直线</title>
      <link>https://stats.stackexchange.com/questions/657667/discrete-vertical-lines-when-plotting-predicted-values-against-actual-values-in</link>
      <description><![CDATA[我对我的数据集使用随机森林，其中我的响应是连续的，所有特征都是因子。当我绘制预测值与实际值的关系图时，该图显示离散的垂直线，如下图所示。有人知道我该如何解决这个问题吗？
]]></description>
      <guid>https://stats.stackexchange.com/questions/657667/discrete-vertical-lines-when-plotting-predicted-values-against-actual-values-in</guid>
      <pubDate>Fri, 22 Nov 2024 09:37:34 GMT</pubDate>
    </item>
    <item>
      <title>为什么具有二项式家族（link="log"）的 glm 有时需要起始值？</title>
      <link>https://stats.stackexchange.com/questions/657665/why-does-glm-with-family-binomiallink-log-sometimes-require-start-values</link>
      <description><![CDATA[在模拟一些研究并使用 glm(…, family=binomial) 和二元和连续协变量进行分析时，该函数有时会抱怨：

未找到有效的系数集：请提供起始值

这只发生在 link=&quot;log&quot; 上，而不会发生在 link=&quot;logit&quot; 上。在这个特定的例子中，我可以使用模型 ae ~ TRT + AGE，但不能使用 ae ~ TRT * AGE：
&gt; dput(d)
结构(列表(TRT = 结构(c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、 
2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、2L、 
2L，2L，2L，2L，2L，2L，2L，2L，2L，2L，2L，2L，2L)，水平＝c(“安慰剂”， 
“verum”），类别=“因子”），AGE = c（39.7487662482072， 50.1799716204745, 
33.3045815905937、38.0315677387993、48.5841412266105、47.2349106894153、 
38.1600311512517、27.738632829439、43.6232076313004、37.3394328366416、 
37.590035880194、36.0186173490767、54.2502475692696、45.5122737460622、 
30.6935441725765、44.2362429427211、30.229949563021、41.554016200862、 
48.3781816616456、42.7388087687717、41.3662137160875、44.044378841722、 
34.1693526744936、40.3652575218051、32.6305917972471、59.6961875303972、 
14.972782257658, 51.1042166486761、32.6220522256254、34.1277732393448、 
32.5147509852927、43.5272141962345、22.4337643342435、46.7163458805283、 
58.7961685435884、39.4696740660955、45.2631826365689、28.6236265146614、 
39.1053872190327、38.4418306901041、 38.9154609346267、49.3065159458693、 
49.8854291946365、42.743416440472、36.593435912556、50.3094002474162、 
25.2467062247769、25.9631953495408、50.183216552195、43.1630235325955、 
39.484028020715、30.760758073483、44.1099004897372、 53.0787176407533, 
28.8868124792957、23.8002913513491、36.8486854897447、35.7992086333115、 
36.8217592746943、46.4797492054728、39.3439003225626、38.9853144287762、 
48.6407924104783、48.4570777980696、24.1018033132868、47.9806140420494、 
32.831890637965、37.3030109318783、32.347169370539、34.3527037438039、 
31.1037953243259、25.167342712201、45.6195833859188、24.9319176156433、 
57.7858917718018、48.3952531818224、57.6041557474735、37.5874128252175、 
40.2161861439315, 46.5485174118935、41.4776267604738、36.1551131739081、 
50.2126132793173、43.1623681906198、24.7898982814906、36.0263371058247、 
37.5345572690356、39.435597693454、22.9833444605649、27.2064057871258、 
30.2699080938295、53.6779893571545、 19.5873248933428, 28.2510703807555, 
31.1065131489478, 19.1338294814643, 53.2483634625907, 46.2987786295095, 
31.8461326828004, 44.8690561376469), ae = c(0L, 1L, 0L, 1L, 0L, 
0L, 1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L, 0L, 1L, 0L, 
0L, 1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 0L, 
0L, 1L, 0L, 1L, 0L, 0L, 0L, 1L, 0L, 0L, 0L, 1L, 0L, 0L, 1L, 1L, 
1L, 1L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 1L, 
1L, 0L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 0L, 0L, 
1L, 0L, 1L, 0L, 0L, 1L, 0L, 0L, 1L, 1L, 0L, 1L, 1L, 0L, 1L, 1L, 1L, 
0L, 1L, 0L, 0L, 1L, 0L, 1L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), class = &quot;data.frame&quot;, row.names = c(NA, 
-100L))
&gt; glm(ae~TRT+AGE,data=d, family=binomial(link=&quot;log&quot;))

调用：glm(formula = ae ~ TRT + AGE, family = binomial(link = &quot;log&quot;), 
data = d)

系数：
(截距) TRTverum AGE 
-1.176887 0.176749 0.008414 

自由度：总计 99（即零）； 97 残差
零偏差：138.3 
残差偏差：137.3 AIC：143.3
&gt; glm(ae~TRT*AGE,data=d, family=binomial(link=&quot;log&quot;))
错误：未找到有效的系数集：请提供起始值

我怎么知道要提供什么起始值？如果有一种算法可以为特定数据集找到它们，为什么函数 glm 本身不使用它？我很确定，当使用 SAS 时，我能够使用其中一个“不起作用”的数据集获得结果。遗憾的是，我再也无法使用 SAS 了。
有趣的是，有了这个数据集
&gt; set.seed(310);
&gt; d=data.frame(TRT=gl(2,50,labels=c(&quot;placebo&quot;,&quot;verum&quot;)),AGE=rnorm(100,40,10),ae=rbinom(100,1,0.5))
&gt; glm(ae~TRT*AGE,data=d, family=binomial(link=&quot;log&quot;))

调用：glm(formula = ae ~ TRT * AGE, family = binomial(link = &quot;log&quot;), 
data = d)

系数：
(截距) TRTverum AGE TRTverum:AGE 
0.24568 -0.62229 -0.02189 0.01588 

自由度：总计 99（即零）； 96 残差
零偏差：137.6 
残差偏差：134.3 AIC：142.3


我得到了一个没有提供起始值的结果。]]></description>
      <guid>https://stats.stackexchange.com/questions/657665/why-does-glm-with-family-binomiallink-log-sometimes-require-start-values</guid>
      <pubDate>Fri, 22 Nov 2024 09:25:45 GMT</pubDate>
    </item>
    <item>
      <title>测试马尔可夫特性和模拟/验证的代码</title>
      <link>https://stats.stackexchange.com/questions/657664/code-for-testing-markov-property-simulation-validation</link>
      <description><![CDATA[我知道这个问题之前已经有人问过了（例如1、2、3），但这些答案都没有提供代码。
根据以上链接提供的信息（尤其是这篇论文），我已经实现了 R 代码来：

生成随机马尔可夫样本
运行 Pearson &amp;似然比$\chi^2$检验

代码
注意：我们不允许零概率转换；这会使测试统计数据的定义更加复杂。
library(&#39;ggplot2&#39;)
rbind.lappy = function(...){ # 便利
do.call(rbind,parallel::mclapply(...,mc.cores=7))
}
px.random = function(d=2){ # 生成随机转换矩阵
px = matrix(runif(d^2,.1,.9),d,d) # 随机数
px = sweep(px,1,rowSums(px),&#39;/&#39;) # 标准化
}
markov.limit = function(px){ # 获取极限分布
e1 = eigen(t(px))$vectors[,1]
p0 = e1 / sum(e1)
}
markov.sim = function(p0,px,nt,ni){ # 模拟样本
ns = length(p0)
state = list(sample(1:ns,ni,p=p0,rep=TRUE)) # 初始时间
for (i in 2:nt){ # 后续每个时间
state[[i]] = sapply(state[[i-1]],function(si){ sample(1:ns,1,p=px[si,]) })
}
names(state) = paste0(&#39;s&#39;,1:nt)
ms = data.frame(i=1:ni,state)
}
markov.test = function(ms){
ns = length(unique(ms[,2])) # 状态数
nt = ncol(ms)-1 # 时间点数
n_hij = array(1,c(ns,ns,ns)) # 二阶计数*
n_ij = array(1,c(ns,ns)) # 一阶计数*
# *初始化为 1 以避免除以零
for (m in seq(nt-2)){ n_hij = n_hij + 表(ms[paste0(&#39;s&#39;,m+0:2)]) }
  for (m in seq(nt-1)){ n_ij = n_ij + table(ms[paste0(&#39;s&#39;,m+0:1)]) }
  n_hi = rowSums(n_hij,dim=2)
  n_i = rowSums(n_ij, 暗淡=1)
  p_hij = 扫描(n_hij,1:2,n_hi,&#39;/&#39;)
  p_ij = 扫描(n_ij, 1, n_i, &#39;/&#39;)
  Q.p = sum(扫描(扫描(扫描(p_hij,2:3,p_ij,&#39;-&#39;)^2,2:3,p_ij,&#39;/&#39;),1:2,n_hi,&#39;*&#39;))
Q.lr = 2*sum(n_hij*log(sweep(p_hij,2:3,p_ij,&#39;/&#39;)))
Q = c(pearson=Q.p, likel.ratio=Q.lr)
p = pchisq(Q,df=ns*(ns-1)*(nt-1),lower=FALSE)
}
markov.test.pvs = function(nt,ni,ns=2,nk=100,lim=1){
pvs = rbind.lappy(1:nk,function(k){
set.seed(k)
px = px.random(ns)
if (lim){ p0 = markov.limit(px) }
else { p0 = rep(1,ns) / ns }
ms = markov.sim(p0,px,nt=nt,ni=ni)
pv = c(nt=nt,ni=ni,ns=ns,nk=nk,lim=lim,markov.test(ms))
})
}
# main
G = expand.grid( # 要扫描的参数
ni=c(30,100,300,1000), # 个体数（链）
nt=3:7, # 时间点数
ns=2, # 状态数
nk=1000, # 重复次数
lim=0:1) # 在稳定状态下初始化
pvs = rbind.lappy(split(G,1:nrow(G)),do.call,what=markov.test.pvs)
# 重塑 &amp;图
pvs.m = reshape2::melt(as.data.frame(pvs),id=colnames(pvs)[1:5])
pvs.m$init = factor(pvs.m$lim,0:1,c(&#39;uniform&#39;,&#39;limit&#39;))
pos = position_dodge(width=1)
g = ggplot(pvs.m,aes(y=value,x=&#39;&#39;,color=variable,lty=init)) +
facet_grid(&#39;ni~nt&#39;,labeller=label_both) +
geom_violin(scale=&#39;width&#39;,position=pos,fill=NA) +
geom_hline(yintercept=.05,lty=&#39;11&#39;) +
stat_summary(geom=&#39;text&#39;,position=pos,show.legend=FALSE,
fun.data=function(x){ data.frame(y=-.1,label=mean(x &lt; .05),size=2) }) +
labs(y=&#39;p value&#39;,x=&#39;&#39;,color=&#39;statistic&#39;) + ylim(-.1,1)
ggsave(&#39;Rplots.pdf&#39;,w=8,h=6)

结果

问题

我的代码是否正确模拟了马尔可夫样本？
我的代码是否正确实现了两个测试？
如果 1 &amp; 2、为什么 I 类（假阳性）错误率存在差异：


观察到的时间点数量（nt：水平面板）
观察到的链数量（ni：垂直面板）

这些趋势是预期的吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/657664/code-for-testing-markov-property-simulation-validation</guid>
      <pubDate>Fri, 22 Nov 2024 09:04:40 GMT</pubDate>
    </item>
    <item>
      <title>检查两组比例是否_无差异_的检验</title>
      <link>https://stats.stackexchange.com/questions/657663/a-test-to-check-whether-two-sets-of-proportions-are-not-different</link>
      <description><![CDATA[是否有检验方法可以检查两组小比例是否显著无差异？
例如，考虑两组比例
(0.2,0.3,0.25,0.35,0.19)
(0.31, 0.25, 0.21,0.17, 0.22) 
我想证明两组显著无差异。这意味着零假设必须是它们不同。
如果对数据来源​​感兴趣，那就是各种样本的细胞类型比例。我想表明，经过治疗后，各种细胞类型比例的分布没有改变。
之所以选择零假设和备择假设，是因为我感兴趣的实质性主张是两种情况之间没有发生任何变化。无法拒绝无变化的零假设并不等同于接受无变化的假设，后者才是我感兴趣的。]]></description>
      <guid>https://stats.stackexchange.com/questions/657663/a-test-to-check-whether-two-sets-of-proportions-are-not-different</guid>
      <pubDate>Fri, 22 Nov 2024 08:15:29 GMT</pubDate>
    </item>
    <item>
      <title>血液碱度与癌症：癌症相关因素、转移效应和血液 pH 相关性：我们可用的工具</title>
      <link>https://stats.stackexchange.com/questions/657661/blood-alkalinity-and-cancer-cancer-implicants-metastasis-effect-and-blood-ph</link>
      <description><![CDATA[假设我有

一个可以量化的原因变量

一个可以量化的结果变量

原因数量如何影响结果数量的图表

一些相关因素（这些不是暗示结果的原因，但可以共存）。


我们想确定改变相关因素是否会改变蕴涵项和确定结果的图表。
我可以使用哪些统计工具？
例如，我们可以有：

存在致癌印迹（蕴涵项）

血液系统中存在转移（效应）

相关因素（血液 pH 值，以及系统中物质的存在（可能与 pH 有关，影响 pH 值）


我们想知道改变血液的 pH 值是否会影响转移产生的含义
也就是说，我们想知道带电的 pH 值是否是含义的影响（副作用），... 或者改变血液 pH 值是否可以改变含义图
假设，血液 pH 值可以通过营养改变（例如，假设饮食或营养素可以使血液碱化）。
我可以使用哪些统计工具？
谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/657661/blood-alkalinity-and-cancer-cancer-implicants-metastasis-effect-and-blood-ph</guid>
      <pubDate>Fri, 22 Nov 2024 07:57:56 GMT</pubDate>
    </item>
    <item>
      <title>DF 和 ADF 检验结果相矛盾</title>
      <link>https://stats.stackexchange.com/questions/657656/conflicting-results-in-df-and-adf-tests</link>
      <description><![CDATA[我正在对 globtemp 数据集进行单位根检验，该数据集显然是具有趋势和季节性（非平稳）的序列。但是，当应用简单的 Dickey-Fuller 检验时，我获得的 p 值很小，导致拒绝零假设并表明该序列是平稳的。
同时，使用增强版本 (ADF) 执行测试，使用 R 的默认滞后数 (k)，p 值不会拒绝零假设，表明时间序列是非平稳的。话虽如此，我很困惑，不明白这种差异。为什么在简单的 DF 测试（k=0）的情况下，测试无法产生真实的结果？此外，如果测试对“k”的选择如此敏感，那么最好的方法是什么？我们应该始终依赖默认值吗？
此外，我读到残差中存在自相关违反了测试中残差不相关的假设，可能会导致错误的结果。因此，我还评估了第一次测试（DF）残差中是否存在自相关，它们的行为与白噪声的行为一致（我也使用 Box-Ljung 对此进行了测试）。这让我对上面提到的不一致的结果更加困惑。
可以检查下面我所做的代码：
library(tseries)

globtemp &lt;- stats::ts(
c(-0.32, -0.32, -0.4, -0.39, -0.65, -0.43, -0.4, -0.52, -0.3, -0.12,
-0.4, -0.42, -0.39, -0.45, -0.35, -0.36, -0.19, -0.14, -0.37, -0.22,
0, -0.08, -0.24, -0.36, -0.49, -0.27, -0.19, -0.43, -0.29, -0.3,
    -0.29、-0.29、-0.28、-0.23、-0.04、-0.02、-0.24、-0.42、-0.35、-0.16、
    -0.17、-0.09、-0.13、-0.16、-0.14、-0.14、0.1、-0.03、0.03、-0.18、
    -0.06、0.04、0.02、-0.13、0.03、-0.06、0.02、0.13、0.13、-0.03、
    0.15、0.12、0.1、0.04、0.11、-0.04、0.01、  0.13、-0.01、-0.06、
    -0.14、-0.02、0.04、0.14、-0.07、-0.06、-0.17、0.1、0.1、0.05、
    -0.01、0.08、0.02、0.02、-0.26、-0.16、-0.09、-0.02、-0.12、0.03、
    0.04、-0.11、-0.07、0.19、-0.07、-0.05、-0.22、0.16、0.09、0.14、
    0.28、0.39、0.07、0.29、0.11、0.11、0.16、 0.32, 0.35, 0.25,
0.47, 0.41, 0.13),
start=1880, end = 1992)

plot(globtemp)

adf.test(globtemp, k=0) #DF 检验
#Dickey-Fuller = -3.4235, 滞后阶数 = 4, p 值 = 0.05414

dx &lt;- diff(globtemp) 
x_lag &lt;- globtemp[-length(globtemp)] 
df_model &lt;- lm(dx ~ x_lag) 
summary(df_model)

residuals_df &lt;- resid(df_model)
acf(residuals_df, 50, main = &quot;&quot;) #否自相关
Box.test(residuals_df, lag = 15, type = &quot;Ljung-Box&quot;)

adf.test(globtemp) #ADF 默认为 &quot;k&quot;
#Dickey-Fuller = -3.4235, 滞后阶数 = 4, p 值 = 0.05414
]]></description>
      <guid>https://stats.stackexchange.com/questions/657656/conflicting-results-in-df-and-adf-tests</guid>
      <pubDate>Fri, 22 Nov 2024 04:44:14 GMT</pubDate>
    </item>
    <item>
      <title>将连续变量转换为逻辑回归的更大序数类别？</title>
      <link>https://stats.stackexchange.com/questions/657655/converting-a-continuous-variable-into-a-larger-ordinal-categories-for-logistic-r</link>
      <description><![CDATA[与结核病类似，非结核分枝杆菌肺病患者需要咳出痰液才能确诊。但是，没有关于需要多少痰液才能达到足够灵敏度的数据。
我目前正在研究痰液量 (x) 是否与培养阳性 (y) 相关的问题。
在逻辑回归模型中，分析因变量 Y（培养阳性）与自变量 X（最初是痰液量的连续变量）之间的关联，如果您发现关系不是线性的并且可能存在阈值效应，您能否将变量 X 从连续变量转换为权重不等的较大离散序数值并将其分析为数值（而不是纯粹的分类值）？]]></description>
      <guid>https://stats.stackexchange.com/questions/657655/converting-a-continuous-variable-into-a-larger-ordinal-categories-for-logistic-r</guid>
      <pubDate>Fri, 22 Nov 2024 03:59:53 GMT</pubDate>
    </item>
    <item>
      <title>rugarch 包中条件方差的初始值是如何计算的？[关闭]</title>
      <link>https://stats.stackexchange.com/questions/657651/how-are-the-initial-value-of-conditional-variance-calculated-in-rugarch-package</link>
      <description><![CDATA[我正在尝试使用 rugarch 库验证我的零均值 GARCH(1,1) 模型的计算。起初，我认为条件方差的初始第一个值与无条件方差（python 中的 arch 包使用）的值相同，因为没有过去的回报，也没有过去的方差来计算它。
但是当我使用 garch_fit@fit$var 重新检查条件方差的第一个初始值时，它与无条件方差不同。
我尝试使用计算器手动计算无条件方差，它给出的输出与 uncvariance(garch_fit) 相同，这不是模型中条件方差的初始第一个值。那么，如果 GARCH 过程不是由无条件方差初始化的，那么第一个值是如何计算的呢？
以下是我的规范代码：
garch_spec &lt;- ugarchspec(
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), # 无 ARMA 项，零均值
variance.model = list(model = &quot;sGARCH&quot;, garchOrder = c(1, 1)), # GARCH(1, 1)
distribution.model = &quot;norm&quot; # 正态分布
)
garch_fit &lt;- ugarchfit(
spec = garch_spec,
data = data$log_return_pct,
solver = &quot;hybrid&quot;,
out.sample = 83
)

以及两者之间的区别第一个初始方差
&gt; uncvariance(garch_fit)
[1] 0.5865156
&gt; garch_fit@fit$var[1]
[1] 0.5869211
]]></description>
      <guid>https://stats.stackexchange.com/questions/657651/how-are-the-initial-value-of-conditional-variance-calculated-in-rugarch-package</guid>
      <pubDate>Fri, 22 Nov 2024 00:48:50 GMT</pubDate>
    </item>
    </channel>
</rss>