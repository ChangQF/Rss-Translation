<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Sun, 12 May 2024 18:19:27 GMT</lastBuildDate>
    <item>
      <title>测试集 MSE 和 r^2 与所有 PC 的 OLS 和 PC 回归相同吗？</title>
      <link>https://stats.stackexchange.com/questions/647092/would-test-set-mse-and-r2-be-the-same-with-ols-and-pc-regression-with-all-pcs</link>
      <description><![CDATA[对于这个问题，我定义：
PC 回归 = 标准化变量，拟合 PCA，然后将 OLS 应用于所有 PC。
OLS = 标准化变量，然后对所有变量应用 OLS。
这个问题让我思考答案是“是”。因为所有 PC 的 PCA 只是原始数据的一组线性组合。因此，即使在测试集上，也不会丢失信息，并且 OLS 应该能够具有相同的样本外 R2/MSE，因为它也是线性的。
但是，我做了一些玩具示例，但没有看到完全相同的测试集 r2...也许某些数据被删除，或者存在一些数字或浮点问题。
现在我想起来了...我认为标准化可能会引入一些噪音。当我不对数据进行标准化并运行 OLS 和 PC 回归时，我会得到更接近的结果。
pcr = Pipeline([(&quot;ss&quot;, StandardScaler()), (&quot;pc&quot;, PCA()), (&quot;model&quot;, LinearRegression ())])
pcr.fit(X_train, y_train)
pcr.score(X_test, y_test)
0.5708763714065296

pcr = Pipeline([(“ss”, StandardScaler()), (“模型”, LinearRegression())])
pcr.fit(X_train, y_train)
pcr.score(X_test, y_test)
0.5708405442855263

pcr = 管道([(“模型”, LinearRegression())])
pcr.fit(X_train, y_train)
pcr.score(X_test, y_test)
0.570828508037032

pcr = Pipeline([ (“pc”, PCA()), (“模型”, LinearRegression())])
pcr.fit(X_train, y_train)
pcr.score(X_test, y_test)
0.5708285080369971



]]></description>
      <guid>https://stats.stackexchange.com/questions/647092/would-test-set-mse-and-r2-be-the-same-with-ols-and-pc-regression-with-all-pcs</guid>
      <pubDate>Sun, 12 May 2024 16:37:53 GMT</pubDate>
    </item>
    <item>
      <title>从回归建模策略中的近似模型构建列线图</title>
      <link>https://stats.stackexchange.com/questions/647091/constructing-nomogram-from-approximate-model-in-regression-modelling-strategies</link>
      <description><![CDATA[在 Frank Harrell 的《回归建模策略》第 19.5 节中，我们使用 ols 的线性回归创建了一个近似模型。由于这是一个 ols 对象，我们必须手动计算生存量以制作列线图。
在本书第 472 页（pdf 版本为 491 页）中，值 0.802352037606488 在此计算中出现了两次。这个值从哪里来？书中其他地方没有提到这一点。附上具体代码，其中f为完整模型。
expected.surv &lt;- Mean(f)
quantile.surv &lt;- Quantile(f)
Expected.surv &lt;- 函数(lp = NULL, parms = 0.802352037606488) {
  名称（参数）&lt;- NULL
  exp(lp + exp(2 * 参数)/2)
}

quantile.surv &lt;- 函数(q = 0.5, lp = NULL,
  参数 = 0.802352037606488) {
  名称（参数）&lt;- NULL
  f &lt;- 函数(lp, q, parms) lp + exp(parms) * qnorm(q)
  名称(q) &lt;- 格式(q)
  drop(exp(outer (lp, q, FUN = f, parms = parms )))
}
median.surv &lt;- function(x) quantile.surv(lp=x)


我在文档中找到的唯一有点相关的示例来自函数 transace，其中包含以下示例
## 未运行：
# 另一个例子，关于假设数据
f &lt;- areg.boot(响应 ~ I(年龄) + 单调(血压) + 种族)
# 使用 I(response) 不变换响应变量
情节（f，conf.int=.9）
# 检查残差的分布
绘图（拟合（f），残差（f））
qqnorm(残差(f))
# 使用 ols 重新拟合该模型，以便我们可以绘制它的列线图。
# 列线图将显示线性预测变量、中位数、平均值。
# 最后两个是涂抹估计器。
Function(f, type=&#39;individual&#39;) # 创建转换函数
f.ols &lt;- ols(.response(response) ~ 年龄 +
             .blood.Pressure(血液.Pressure) + .race(race))
# 注意：这个模型与 f 几乎完全相同，但是有
# 由于插值，差异非常小
# 转换
meanr &lt;- Mean(f) # 创建 lp 计算平均响应的函数
medr &lt;- Quantile(f) # 默认分位数为 0.5
列线图(f.ols, fun=list(Mean=meanr,Median=medr))

但在这里他们不做任何转换。
我也不明白为什么我们要对 Expected.surv 和 quantile.surv 进行这种特定的转换。]]></description>
      <guid>https://stats.stackexchange.com/questions/647091/constructing-nomogram-from-approximate-model-in-regression-modelling-strategies</guid>
      <pubDate>Sun, 12 May 2024 16:23:52 GMT</pubDate>
    </item>
    <item>
      <title>渐近独立随机变量之和 - 收敛</title>
      <link>https://stats.stackexchange.com/questions/647088/sum-of-asymptotically-independent-random-variables-convergence</link>
      <description><![CDATA[设 $\theta=\frac{1}{N}\sum_{i=1}^N \pi_i\cdot g_i$ 其中 $0&lt;\pi_i&lt;1$ 和 $g_i&gt;0$。
如果 $X_i\sim Ber(\pi_i)$，我可以轻松显示估计器的均方收敛：
$$
\hat{\theta}^*=\frac{1}{N}\sum_{i=1}^N X_i\cdot g_i,
$$
这意味着 $\hat{\theta}^*\overset{ip}{\rightarrow}\theta$ 为 $N \rightarrow\infty$。如果 $g_i$ 未知，事情会变得更加复杂。
设 $\mathcal{S}=\left\lbrace i=1,\dots,N\,:\, X_i=1\right\rbrace$大小为 $|\mathcal{S}|=n$，即满足 $X_i=1$ 的单位集合。
假设我可以从 $\mathcal{S}$ 中的单位获得 $g_i$ 的一致估计量，这样 $\hat{g}_i(\mathcal{S})\overset{ip}{\rightarrow} g_i$ 对于 $n\rightarrow\infty$。
我可以获得插件估算：
$$
\hat{\theta}=\frac{1}{N}\sum_{i=1}^N X_i\cdot \hat{g}_i(\mathcal{S})。
$$
关于 $\hat{\theta}$ 的收敛性我能得出什么结论吗？
考虑到 $\frac{n}{N}\rightarrow\frac{\sum_{i=1}^N\pi_i}{N}$ 我们应该有 $n\overset{N\rightarrow\infty}{\rightarrow}\infty$。
我的预感是 $\hat{\theta}\overset{ip}{\rightarrow}\theta$ （甚至 a.s.） 的收敛性应该通过一条定律成立大数论点，但我不完全确定，因为 $X_i\cdot \hat{g}_i(\mathcal{S})$ 只是 渐近独立。
如有必要，可以假设对 $\hat{g}_i(\mathcal{S})$ 进行进一步限制（例如 $\hat{g}_i(\mathcal{S})&lt;\nu$ 使得有界收敛定理成立）？
我的猜测
我的想法如下，但我对此并不完全有信心。

斯拉茨基定理。 $X_i\cdot \hat{g}_i(\mathcal{S})\overset{id}{\rightarrow}X_i\cdot g_i$ 为 $n\rightarrow\infty$
有界收敛定理。设 $0&lt;\hat{g}_i(\mathcal{S})&lt;\nu$，因此 $0&lt; ;X_i\cdot \hat{g}_i(\mathcal{S})&lt;\nu$，这样限制和求和/期望运算符可以互换
连续映射定理。假设 $X_i\cdot \hat{g}_i(\mathcal{S})\overset{id}{\rightarrow}X_i\cdot g_i$ 则 $$\frac{1}{N}\sum_{i=1}^N X_i\cdot \hat{g}_i(\mathcal{S})\overset{id}{\ rightarrow}\frac{1}{N}\sum_{i=1}^N X_i\cdot g_i$$
最后一项与 $\theta$ 的收敛是微不足道的，只要 2. 成立

第 3 段让我感到不安，因为分布的收敛位于 $n$ 上，其增长速度与 $N$...]]></description>
      <guid>https://stats.stackexchange.com/questions/647088/sum-of-asymptotically-independent-random-variables-convergence</guid>
      <pubDate>Sun, 12 May 2024 14:19:47 GMT</pubDate>
    </item>
    <item>
      <title>何时在零通胀模型组件中包含随机效应？</title>
      <link>https://stats.stackexchange.com/questions/647087/when-to-include-random-effects-in-zero-inflation-model-component</link>
      <description><![CDATA[在模型的零通胀 (ZI) 组件中指定随机效应 (RE) 是否合适？我的直觉是，任何适合主要组件的 RE 都应该适合 ZI 组件（因为两者都建模到相同的数据集）。然而，这篇文章中的答案让我产生疑问我的直觉是否正确。有人可以提供一个实际的例子来说明在模型的主要组件和 ZI 组件中指定相同的 RE 可能是不合适的吗？我正在使用 glmmTMB 为我的数据建模。]]></description>
      <guid>https://stats.stackexchange.com/questions/647087/when-to-include-random-effects-in-zero-inflation-model-component</guid>
      <pubDate>Sun, 12 May 2024 14:18:56 GMT</pubDate>
    </item>
    <item>
      <title>GLM参考和自我研究简介[重复]</title>
      <link>https://stats.stackexchange.com/questions/647085/glm-reference-and-introudction-to-study-my-self</link>
      <description><![CDATA[我是一名三年级统计学学生。我有一门广义线性模型课程。不幸的是，该课程是用法语授课的，法语不是我的主要语言，即使在阅读讲义（也是法语）时，我在理解材料方面也面临一些困难。
是否有任何好的参考资料可以通过一些示例和推导来对 GLM 进行可靠的介绍？]]></description>
      <guid>https://stats.stackexchange.com/questions/647085/glm-reference-and-introudction-to-study-my-self</guid>
      <pubDate>Sun, 12 May 2024 12:34:59 GMT</pubDate>
    </item>
    <item>
      <title>公司固定效应模型会放弃部门假人吗？潜在的解决方案？</title>
      <link>https://stats.stackexchange.com/questions/647084/firm-fixed-effects-model-dropping-sector-dummies-potential-solution</link>
      <description><![CDATA[在我的论文中，我使用包含股票收益和其他公司数据的面板数据。我首先使用事件研究来计算异常收益（事件窗口为 7 天，因此对 500 家公司进行 7 个观察），我想在之后的分析中将其用作因变量。
具体来说，我想了解某个事件对公司估值的影响，但要区分不同行业（看看哪些行业比其他行业表现更好）。我的第一个方法是建立一个具有集群标准误差的固定效应模型，如下所示：
abnormalreturns_it = Constant_it + SectorDummy1_i + SectorDummy2_i + error_it
问题：由于固定效应的共线性（因为它们不随时间变化），我的扇区虚拟对象被丢弃。这意味着我无法获得每个扇区的系数。我还考虑了随机效应。然而，豪斯曼检验表明，固定效应是两者之间唯一可能的选择。
我确实尝试了一项建议，即可以包含一个事件虚拟变量（事件之前为 0，之后为 1）并与扇区虚拟变量进行交互。所以现在，虽然我的行业虚拟模型仍然被删除，但交互术语仍然存在。但是，我不确定其中的系数和 t 统计数据是否仍然有效？这是当前模型：
xtreg AR MV TTF ENSCORE i.TR2##i.WAR，fe vce（集群 c_id）
其中AR是异常收益，i.TR2##i.WAR是行业分类和事件虚拟变量之间的交互
我听说过的其他选项：

横截面回归是可能的，只是我必须删除随时间变化的变量。
混合效果模型，但我还没有研究过。

我很感激任何帮助。预先感谢您。]]></description>
      <guid>https://stats.stackexchange.com/questions/647084/firm-fixed-effects-model-dropping-sector-dummies-potential-solution</guid>
      <pubDate>Sun, 12 May 2024 12:31:33 GMT</pubDate>
    </item>
    <item>
      <title>当训练/测试方法给出的结果比交叉验证方法好得多时，如何解释分类器的结果？</title>
      <link>https://stats.stackexchange.com/questions/647081/how-to-interpret-the-results-of-a-classifier-when-train-test-method-gives-much-b</link>
      <description><![CDATA[我需要您的帮助来理解使用训练集和测试集产生完美结果（在准确性、精确性和召回率方面）的情况，但是当使用交叉验证时，几倍的准确性很差。
以下是 KNN 分类器在 20% 测试数据和 80% 训练数据上使用时的结果：
 精确召回率 f1-score 支持

       0 1.00 1.00 1.00 13
       1 1.00 1.00 1.00 7
       2 1.00 1.00 1.00 10

准确度 1.00 30
宏观平均 1.00 1.00 1.00 30
加权平均值 1.00 1.00 1.00 30

但是当我使用交叉验证时，使用 cross_val_score 与相同的分类器和准确度分数作为评分指标，我得到以下结果：
cv: 3 --- 每次折叠得分：[0.68 1. 0.68]
cv: 4 --- 每次折叠的得分: [0.65789474 1. 1. 0.67567568]
cv: 5 --- 每次折叠得分: [0.66666667 1. 1. 1. 0.7]

我需要您就以下方面的差异提供建议和指导：

这些不同的分数代表什么，特别是交叉验证的低分？
如何解读这种情况？
如何在交叉验证中获得更好的分数？

谢谢。
P.S：使用带有 shuffle = True 的分层交叉验证给我带来了 [1. 1. 1. 1. 1.] 结果，反映了我从训练/测试（训练/验证）拆分中获得的结果。]]></description>
      <guid>https://stats.stackexchange.com/questions/647081/how-to-interpret-the-results-of-a-classifier-when-train-test-method-gives-much-b</guid>
      <pubDate>Sun, 12 May 2024 11:30:16 GMT</pubDate>
    </item>
    <item>
      <title>具有不同变量的两种不同模型的比较</title>
      <link>https://stats.stackexchange.com/questions/647079/comparison-of-two-different-models-with-different-variables</link>
      <description><![CDATA[如何在两个层面上比较两个模型？例如，我想在两个层面（街道和人口普查区）对犯罪事件进行建模。这些模型是街道的逻辑回归（犯罪发生率）和人口普查区的泊松回归（犯罪频率）。有什么办法可以比较这两者吗？我想研究一下哪种方法更好。]]></description>
      <guid>https://stats.stackexchange.com/questions/647079/comparison-of-two-different-models-with-different-variables</guid>
      <pubDate>Sun, 12 May 2024 10:03:35 GMT</pubDate>
    </item>
    <item>
      <title>使用指数尾界几乎肯定收敛</title>
      <link>https://stats.stackexchange.com/questions/647077/almost-sure-convergence-using-exponential-tail-bound</link>
      <description><![CDATA[我对下面一组讲义“经验过程理论的简要介绍”中的定理有疑问 (http://www.stat.columbia.edu/~bodhi/Talks/Emp-Proc-Lecture-Notes.pdf）。我对定理 3.26 特别感兴趣。这个定理告诉我们以下内容：
假设 $X_1,\ldots, X_n$ 是独立同分布的。 $\mathbb{R}$ 上的随机变量，分布为 $P$ 和 c.d.f。 $F$。令 $\mathbb{F}_n$ 为经验 d.f。的数据。然后，
\begin{对齐}\mathbb{P}\left[\|\mathbb{F}_n-F\|_\infty\geq8\sqrt{\frac{\log(n +1)}n}+t\right]\leq e^{-nt^2/2},\quad&amp;\quad\text{forall } t&gt;0.\quad&amp;\end{对齐} 
因此，$\|\mathbb{F}_n-F\|_\infty\overset{a.s.}{\operatorname*{\to}}0$.
请注意 $\|\mathbb{F}_n-F\|_\infty = \sup_{x \in \mathbb{R}} |\mathbb{F} _n(x)-F(x)|$表示ecdf和cdf之差的超范数。第一个主张（尾部概率的上限）在注释本身中得到了证明。他们留下这样的暗示：这个尾部界限意味着几乎肯定会收敛，作为读者的练习。我无法弄清楚，这就是我的问题。
我看到的一件事是，证明还通过表明 $\mathbb{E}[\|\mathbb{F}_n-F\|_ 建立了均值收敛性\infty] \to 0$ 并且这个 r.v.s 序列是非负的，但这并不意味着 a.s.收敛如下所示（如果极限为零且序列非负，均值收敛是否几乎肯定意味着收敛？）。
还有人有其他见解吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/647077/almost-sure-convergence-using-exponential-tail-bound</guid>
      <pubDate>Sun, 12 May 2024 09:40:07 GMT</pubDate>
    </item>
    <item>
      <title>如何将多元 DKW 不等式排列到 n 的上限？</title>
      <link>https://stats.stackexchange.com/questions/647066/how-to-arrange-multivariate-dkw-inequality-to-an-upper-bound-on-n</link>
      <description><![CDATA[多元 DKW 不等式 给出
$$\Pr \left[ \sup_{t \in \mathbb{R}^k} \left| F_n(t) - F(t) \right| &gt; \epsilon \right] \leq (n+1)k e^{-2n\epsilon^2},$$
其中 $F_n(t)$ 是 eCDF，$F(t)$ 是总体 CDF、$\epsilon \in \mathbb{R}_{&gt;0}$ 和 $n,k \in \mathbb{N}$。
我想要找到的是给定其他输入的 $n$ 的上限。我尝试使用 Lambert $W$ 函数&lt; /a&gt; 但我未能成功地将事物安排成正确的形式来应用它。]]></description>
      <guid>https://stats.stackexchange.com/questions/647066/how-to-arrange-multivariate-dkw-inequality-to-an-upper-bound-on-n</guid>
      <pubDate>Sun, 12 May 2024 05:30:17 GMT</pubDate>
    </item>
    <item>
      <title>如何处理极小的训练数据？</title>
      <link>https://stats.stackexchange.com/questions/647061/how-to-deal-with-extremely-small-training-data</link>
      <description><![CDATA[我有大约 100 行带有标签的数据
国家/地区 |类别 |标签
-----------+----------------+--------------------
[美国、英国、日本] |电子| 1
[美国] |体育 | 1
[台湾、英国] |杂货| 2
[日本] |预订 | 3

大约 900 行没有标签的数据
国家/地区 |类别
-----------+--------------
[美国、英国] |运动的
[台湾] |运动的
[美国] |杂货店
[日本] |电子的

使用这么小的数据集做分类模型可以吗？如果是这样，我该如何编码Country？或者是否有任何其他聚类/数学方法可以用来处理这种情况？]]></description>
      <guid>https://stats.stackexchange.com/questions/647061/how-to-deal-with-extremely-small-training-data</guid>
      <pubDate>Sun, 12 May 2024 01:44:33 GMT</pubDate>
    </item>
    <item>
      <title>样本量和变异系数</title>
      <link>https://stats.stackexchange.com/questions/647058/sample-size-and-coefficient-of-variation</link>
      <description><![CDATA[我想知道样本量和变异系数 (CV) 之间的关系。 CV 定义为标准差与平均值的比率。我们是否可以说“样本量越小，CV 越大，因此关系呈负相关”？
库(dplyr)
库（r样本）

cv &lt;- 函数(x){返回(sd(x)/mean(x))}
sim &lt;- data.frame(id=1:100000,
                变量=rpois(100000, 5),
                group10=样本(1:10,100000,替换=TRUE),
                group100=样本(1:100,100000,替换=TRUE),
                group1000=样本(1:1000,100000,替换=TRUE),
                group10000=样本(1:10000,100000,替换=TRUE)
                ）
AA &lt;- NULL
G &lt;- c(10,100,1000,10000)
for(k in 1:4){
  for(j in 1:G[k]){

  如果（k==1）{
    A &lt;- dplyr::filter(sim, group10==j)
  }否则如果(k==2){
    A &lt;- dplyr::filter(sim, group100==j)
  }否则如果(k==3){
    A &lt;- dplyr::filter(sim, group1000==j)
  }否则如果(k==4){
    A &lt;- dplyr::filter(sim, group10000==j)
  }
  
  AA &lt;- rbind(AA, c(G[k],
                    j,
                    n行(A),
                    平均值（A  $变量），
                var(A$变量),
                    sd(A$变量),
                简历（A$变量）
                    ）
              ）
  }
}
AA &lt;- as.data.frame(AA)
colnames(AA)＜-c(“组”、“组N”、“N”、“平均值”、“Var”、“SD”、“CV”)
头(AA)
尾部(AA)

AA10 &lt;- AA %&gt;% 过滤器(组==10)
AA100 &lt;- AA %&gt;% 过滤器(组==100)
AA1000 &lt;- AA %&gt;% 过滤器(组==1000)
AA10000 &lt;- AA %&gt;% 过滤器(组==10000)

(简历(sim$变量))

par(mfrow = c(1, 4))
图(AA10$N,AA10$CV, ylim=c(0,1.2), ylab=“CV”,xlab=“样本大小”,
     主=“10组”）
abline(h=cv(sim$variable),col=&quot;red&quot;)
绘图(AA100$N,AA100$CV, ylim=c(0,1.2), ylab=&quot;CV&quot;,xlab=&quot;样本大小&quot;,
 主要=“100组”）
abline(h=cv(sim$变量),col=“红色”)
绘图(AA1000$N,AA1000$CV, ylim=c(0,1.2), ylab=“CV”,xlab=“样本大小”,
     main=“1,000 组”）
abline(h=cv(sim$variable),col=&quot;red&quot;)
绘图(AA10000$N,AA10000$CV, ylim=c(0,1.2), ylab=&quot;CV&quot;,xlab=&quot;样本大小&quot;,
 主要=“10,000组”）
abline(h=cv(sim$变量),col=“红色”)
dev.off()

]]></description>
      <guid>https://stats.stackexchange.com/questions/647058/sample-size-and-coefficient-of-variation</guid>
      <pubDate>Sun, 12 May 2024 00:00:18 GMT</pubDate>
    </item>
    <item>
      <title>手动最大似然估计实现的 GARCH 表现不佳</title>
      <link>https://stats.stackexchange.com/questions/646990/manual-maximum-likelihood-estimation-of-realized-garch-behaving-poorly</link>
      <description><![CDATA[我正在尝试估计已实现的 GARCH 模型的最大可能性。下面是我想要估计的方程和参数


我使用下面的函数来最大化可能性，但它非常不一致。而且，它对初始参数高度敏感，它总是吐出非常非常接近初始参数的值。我尝试过使用真实数据和模拟数据，这样我就可以检查真实参数。我在代码中做错了什么吗？我知道 GARCH 模型通常具有平坦的可能性，但我仍然认为我会得到一些与初始值不同的值
 garch11_realized &lt;- 函数（返回、参数、RM）{
  #启动我们的参数
  欧米茄 &lt;- 参数[1]
  beta &lt;- 参数[2]
  gamma &lt;- 参数[3]
  xi &lt;- 参数[4]
  phi &lt;- 参数[5]
  tau1 &lt;- 参数[6]
  tau2 &lt;- 参数[7]
  T &lt;- 长度（返回）
  
  log_sigma2 &lt;- 数字(T)
  sigma2 &lt;- 数字(T)
  log_x &lt;- log(RM)
  ut &lt;- 数字(T)
  z &lt;- 数字(T)
  tau_z &lt;- 数字(T)
  
  log_sigma2[1] &lt;- log((omega + gamma * xi) / (1 - (beta + gamma*phi)))
  sigma2[1] &lt;- exp(log_sigma2[1])
  z[1] &lt;- 返回[1] / sqrt(exp(log_sigma2[1]))
  
  对于 (t in 2:T){
    #我们在这里使用日志，因为这就是大多数论文中指定模型的方式
    log_sigma2[t] &lt;- omega + beta * log_sigma2[t-1] + gamma * log_x[t-1]
    sigma2[t] &lt;- exp(log_sigma2[t])
    z[t] &lt;- 返回[t] / sqrt(exp(log_sigma2[t]))
    
    tau_z[t] &lt;- tau1 *z[t] + tau2 * (z[t] ^ 2 - 1) #我们的杠杆函数
    ut[t]&lt;- log_x[t] - xi - phi * log_sigma2[t] - tau_z[t] # 重新排列测量方程以计算残差
    
  }
  返回（列表（sigma2 = sigma2，ut = ut，z = z））
}

neg_loglik_realized &lt;- 函数（返回，参数，RM）{
  欧米茄 &lt;- 参数[1]
  beta &lt;- 参数[2]
  gamma &lt;- 参数[3]
  xi &lt;- 参数[4]
  phi &lt;- 参数[5]
  tau1 &lt;- 参数[6]
  tau2 &lt;- 参数[7]
  sigma_ut &lt;- params[8] #测量方程中 ut 的方差
  
  T &lt;- 长度（返回）
  
  model_results &lt;- garch11_realized（返回，参数，RM）
  sigma2 &lt;- model_results$sigma2
  ut &lt;- model_results$ut
  
  #实现 garch 所需的条件 - https://core.ac.uk/download/pdf/41239655.pdf - 本文第 6 页
  # 0 &lt; β+φγ＜ 1 且 ω + γ ψ ＞ 0
  if (all(is.finite(params)) &amp;&amp; omega &gt; 0 &amp;&amp; beta &gt; 0 &amp;&amp; gamma &gt; 0 &amp;&amp; 0 &lt; (beta + phi * gamma) &amp; ;&amp; (β + phi * gamma) &lt; 1 &amp; (omega + gamma * xi) &gt; 0) {
    #拟对数似然
    log_lik_1 &lt;- - T/2* log(2*pi) - 1/2 * sum(log(sigma2)) - 1/2 * sum(returns^2 / sigma2) #这是第一部分 l(r)
    log_lik_2 &lt;- - T/2 * log(2 * pi) - 1/2 * sum(log(sigma_ut)) -1/2 * sum((ut ^ 2 / sigma_ut ^ 2)) #这是第二部分l(x|r)
    neg_lik &lt;- - (log_lik_1 + log_lik_2)
  } 别的 {
    neg_lik &lt;- Inf
  }
  返回（neg_lik）
}

干杯]]></description>
      <guid>https://stats.stackexchange.com/questions/646990/manual-maximum-likelihood-estimation-of-realized-garch-behaving-poorly</guid>
      <pubDate>Fri, 10 May 2024 16:14:57 GMT</pubDate>
    </item>
    <item>
      <title>如果引导程序分布有偏差，则将什么显示为误差线？</title>
      <link>https://stats.stackexchange.com/questions/646916/what-to-show-as-error-bar-if-the-bootstrap-distribution-is-biased</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/646916/what-to-show-as-error-bar-if-the-bootstrap-distribution-is-biased</guid>
      <pubDate>Thu, 09 May 2024 14:18:55 GMT</pubDate>
    </item>
    <item>
      <title>零膨胀模型和零改变模型之间的区别</title>
      <link>https://stats.stackexchange.com/questions/646761/difference-between-zero-inflated-model-and-zero-altered-model</link>
      <description><![CDATA[有人可以解释一下，当我在 glmmTMB 中指定 family = nbinom2() 与 family = truncated_nbinom2() 时，我所做的假设（可能是隐式的）强&gt;。在我的模型中，我使用参数 formula 指定条件公式，并使用参数 ziformula 指定零通货膨胀公式。根据此处的帖子，family = nbinom2()  指定零膨胀模型，而 family = truncated_nbinom2() 指定零更改模型。
两个模型系列对模型结果（特别是零通胀模型）的解释有何变化？]]></description>
      <guid>https://stats.stackexchange.com/questions/646761/difference-between-zero-inflated-model-and-zero-altered-model</guid>
      <pubDate>Tue, 07 May 2024 21:13:01 GMT</pubDate>
    </item>
    </channel>
</rss>