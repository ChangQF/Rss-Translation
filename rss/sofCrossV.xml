<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Wed, 14 Aug 2024 09:16:33 GMT</lastBuildDate>
    <item>
      <title>拟合GAM模型时如何区分分组效应和随机效应？</title>
      <link>https://stats.stackexchange.com/questions/652769/how-to-differentiate-the-grouping-effect-and-the-random-effect-when-fitting-gam</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/652769/how-to-differentiate-the-grouping-effect-and-the-random-effect-when-fitting-gam</guid>
      <pubDate>Wed, 14 Aug 2024 08:32:16 GMT</pubDate>
    </item>
    <item>
      <title>在一个层内使用不同的激活函数？</title>
      <link>https://stats.stackexchange.com/questions/652768/using-a-different-activation-functions-within-a-layer</link>
      <description><![CDATA[作为一项实验，可以尝试在一个层中拥有 n 个不同的激活/神经元/单元。
一种是采用深度学习框架中的自动反向传播算法，因为它们在一个层中使用相同的激活。
一种简单（但效率低下）的方法是使用不同的激活函数将输入层连接到 n 个 1 个单元的层。
类似于此图：

将它们相加可以通过将激活作为单个激活相加来替代，而不需要两个层，但如果将结果连接起来，那将有所区别。
例如，可以有 -x 和 x。
这已经完成并测试过了吗？它对你来说看起来有潜在用处吗？还是一个合理的探索基础？（只是为了避免自己做的麻烦。）
其他地方的相关文章

https://community.deeplearning.ai/t/why-i-need-the-same-activation-function-in-a-layer-with-multiple-neurons/226930

https://stackoverflow.com/questions/51175117/how-to-implement-different-activation-functions-in-a-layer-of-a-neural-network-i

]]></description>
      <guid>https://stats.stackexchange.com/questions/652768/using-a-different-activation-functions-within-a-layer</guid>
      <pubDate>Wed, 14 Aug 2024 08:23:12 GMT</pubDate>
    </item>
    <item>
      <title>敏感度::tell - 与设计相比，响应包含更多行</title>
      <link>https://stats.stackexchange.com/questions/652766/sensitivitytell-the-response-has-more-rows-compared-to-the-design</link>
      <description><![CDATA[我想使用 sensitivity::tell(x, y)，但所需的 y 比 x 长
我制作了一个 Sobol 设计 X，然后（在 R 之外）我执行了实验来获取 y。现在我有了设计和数据。查看此响应，似乎我应该使用sensitivity::tell，但y的长度没有意义。
示例代码如下
n &lt;- 1000
X1 &lt;- data.frame(matrix(runif(8 * n), nrow = n))
X2 &lt;- data.frame(matrix(runif(8 * n), nrow = n))

#Sensitivity 分析
x &lt;- sobol(model = NULL, X1, X2, nboot = 100)
y &lt;- ishigami.fun(x$X)
tell(x,y)
print(x)
plot(x)

它可以工作，但是 ishigami.fun(x$X) 给出的向量比输入设计长得多。如果设计长度为 2,000（X1 和 X2），响应怎么会是 9,000 个观测值？
如果我的设计有 2000 个实验行，响应应该同样长。
如何使用这些函数获得模型的敏感度？
]]></description>
      <guid>https://stats.stackexchange.com/questions/652766/sensitivitytell-the-response-has-more-rows-compared-to-the-design</guid>
      <pubDate>Wed, 14 Aug 2024 07:49:15 GMT</pubDate>
    </item>
    <item>
      <title>McNemar 检验 1 个受试者与 3 个受试者需要多次测试校正吗？</title>
      <link>https://stats.stackexchange.com/questions/652765/mcnemar-test-1-subject-versus-3-subjects-need-multiple-testing-correction</link>
      <description><![CDATA[我向不同的人询问特定跑步者马拉松的持续时间。我想将 1 个人（人 A）的估计与另外 3 个人（人 B、C 和 D）的估计进行比较，如下所示：
我会问

人 A 跑步者是否需要：&lt;= 2 小时，&gt; 2 &lt;= 3 小时，&gt; 3 &lt;= 4 小时或 &gt; 4 小时

人 B 是否需要 &gt; 2 小时

人 C 是否需要 &gt; 3 小时

人 D 是否需要 &gt; 4 小时


由于涉及相同的跑步者，我想进行 McNemar 检验并比较 A 与 B、A 与 C 和 A 与 D。从 A 的 1 个估计中，我可以推断出 3 个估计。例如，如果 A 的估计是跑步将花费 &gt;3 &lt;= 4 小时。我可以说 A 对 &gt;2 小时说的是假的，对超过 3 小时说的是真的，对 &gt;4 小时说的是假的。这样，我可以针对 B、C 和 D 的估计值制作 3 个列联表。
我担心的是，如果我的研究问题是 A 的表现优于 B、C 和 D，
这些测试将需要进行多重检验校正，因为我对来自 A 的 1 个估计值进行了 3 次测试。
如果我的研究问题是 A 的表现是否优于 B、C 或 D，那么 McNemar 检验可能不需要进行多重检验校正。
我很想听听你对此的看法。]]></description>
      <guid>https://stats.stackexchange.com/questions/652765/mcnemar-test-1-subject-versus-3-subjects-need-multiple-testing-correction</guid>
      <pubDate>Wed, 14 Aug 2024 07:26:44 GMT</pubDate>
    </item>
    <item>
      <title>nlme 交叉随机效应和自回归协方差结构</title>
      <link>https://stats.stackexchange.com/questions/652764/nlme-crossed-random-effects-und-autoregressive-covariance-structure</link>
      <description><![CDATA[我想问您两个具体问题，关于一个模型，其中要考虑交叉随机效应和自回归协方差结构（AR1 --&gt;
因此使用包 nlme 而不是 lme4）。这是基于 16 周的饲养试验（2x2 因子设计），其中有 32 头奶牛，每头奶牛有 16 个测量点（每周测量间隔）。

如何在 nlme 中实现两个非嵌套随机效应（在 lme4 中：+ (1|animal) + (1|test_week)）？
o 因为 random = list(one1 = pdMat (~ animal - 1), one2 = pdMat (~experimental_week - 1))，其中 one1 和 one2 是“辅助”变量，为 1（对于每个观察值）？来源：r - 在 lmer 和 nlme:lme 中建模随机结构 - 交叉验证 (stackexchange.com)
o 否则：random = list(animal = pdMat (~1),experimental_week = pdMat (~1)) ?
o 否则？
o 由此必须选择正确的 pdMat 对象 (pdDiag、pdIdent 等)。

如何正确解释自回归协方差结构？
o Correlation = corAR1(0.99, form = ~ 1)
o 或 correlation = corAR1(form = ~experimental_week |animal)


目前我有这样的情况：
-&gt;首先建立对比：
contr2 &lt;- rbind( &quot;HeuvsSIL P1&quot; = c(-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
new_model_1 &lt;- lme(
fixed = ECM ~ Index,
random = list(Animal = pdDiag(~1), ExpWeek = pdDiag(~1)),
data = data1,
correlation = corAR1(form = ~ ExpWeek |Animal), na.action = na.omit)
summary(glht(new_model_1, linfct = mcp(Index = contr2), test = adapted(&quot;BH&quot;)))]]></description>
      <guid>https://stats.stackexchange.com/questions/652764/nlme-crossed-random-effects-und-autoregressive-covariance-structure</guid>
      <pubDate>Wed, 14 Aug 2024 06:23:18 GMT</pubDate>
    </item>
    <item>
      <title>添加控制变量后，豪斯曼检验 p 值跳转到 1？</title>
      <link>https://stats.stackexchange.com/questions/652763/hausman-test-p-value-jumps-to-1-after-adding-control-variable</link>
      <description><![CDATA[我想测试固定或随机效应模型是否更适合我的数据。我包括了所有不使 p 值跳跃的变量，估计两个模型，而豪斯曼检验给出了以下输出：
豪斯曼检验

数据：DV ~ IV + CV1 + CV2 + CV3 + CV4 + CV5 + ...
chisq = 62.595，df = 9，p 值 = 4.227e-10
备选假设：一个模型不一致

所以，非常重要，这意味着我应该使用固定效应模型
现在，如果我再添加一个（或多个）我已经确定为使 p 值跳跃到 1 的变量，则输出如下：
豪斯曼检验

数据：DV ~ IV + CV1 + CV2 + CV3 + CV4 + CV5 + ...
chisq = 0.23564，df = 10， p 值 = 1
备选假设：一个模型不一致

这些导致 p 值大幅跳变的变量中，有些在回归模型中非常重要，因此我无法直接排除它们。但我不知为何感觉我的模型有问题。p 值为 1 似乎很奇怪。或者它就是这样，并且包含这些变量后应该使用随机效应模型？
我期待您的回答！
为了估计模型，我使用以下代码，其中 CV10 是使 p 值跳转到 1 的变量：
fe_model&lt;-plm(DV ~ IV + CV1 + CV2 + CV3 + CV4 + CV5 + CV6 + CV7 + CV8
+ CV9 + factor(Industry) + CV10, data=sample, index = c(&quot;Company&quot;, &quot;Year&quot;), model=&quot;within&quot;, effect=&quot;twoways&quot;) 

re_model&lt;-plm(DV ~ IV + CV1 + CV2 + CV3 + CV4 + CV5 + CV6 + CV7 + CV8 
+ CV9 + 因子（行业）+ CV10，数据=样本，索引 = c（“公司”，“年份”），模型=“随机”，效果=“双向”，随机方法 =“walhus”）
]]></description>
      <guid>https://stats.stackexchange.com/questions/652763/hausman-test-p-value-jumps-to-1-after-adding-control-variable</guid>
      <pubDate>Wed, 14 Aug 2024 06:05:09 GMT</pubDate>
    </item>
    <item>
      <title>在 R 中绘制非线性函数及其值[关闭]</title>
      <link>https://stats.stackexchange.com/questions/652757/plotting-a-nonlinear-function-and-its-values-in-r</link>
      <description><![CDATA[我目前正在努力绘制 R 中的下一个函数。
$$
\frac{F1}{F2^m} * (R1 - F1)^{(1 - s)/s} - m * \frac{((R1 - F1))^{(1 / s)} + ((R2 - F2))^{(1 / s)})} { (F1^m + F2^m))} = 0
$$
我想绘制 $F2$ 作为 $F1$ 的函数。 $R_1,R_2$ 的值是固定常数，而 $s,m$ 的值也是固定的。
由于该函数是非线性的，我被建议使用数值近似值在先前定义的 $F1$ 域中查找 $F2$ 的值。
我开发了下一个代码，首先定义常数，然后定义函数，然后定义根查找函数：
rm(list=ls())

library(ggplot2)

R1_values &lt;- c(100) # R1 的示例值
R2_values &lt;- c(100) # R2 的示例值
s_values &lt;- c(1) # R1 的示例值s
m_values &lt;- c(1) # m 的示例值

# 定义原始函数以求解 F2
F2_function &lt;- function(F1, F2, R1, R2, s, m) {
(F1 / F2^m * (R1 - F1)^((1 - s) / s)) - (m * (((R1 - F1))^(1 / s) + ((R2 - F2))^(1 / s)) / (F1^m + F2^m))
}

F1_values &lt;- seq(0.01, 100, by = 0.1)
# 求解 F2
F2_values &lt;- sapply(F1_values, function(F1) {
tryCatch({
# 
uniroot(F2_function, c(0.01, 100), F1 = F1, R1 = R1, R2 = R2, s = s, m = m, tol = 1e-8)$root
}, error = function(e) NA)
})

data &lt;- data.frame(F1 = F1_values, F2 = F2_values)

ggplot(data, aes(x = F1, y = F2)) +
geom_line() +
labs(title = &quot;F2 as a Function of F1&quot;,
x = &quot;F1&quot;,
y = &quot;F2&quot;) +
theme_minimal()

然而，一切都会返回 NA 或极大的值（随机知道何时或如何）。即使该函数在其他软件（Geogebra）中定义明确，图片附后。

因此，我想请教如何绘制图表（并恢复 F1 域的每个部分的 F2 值）。
PD：我认为 F2 对于每个 F1 都有两个结果，但我也无法解决这个问题。]]></description>
      <guid>https://stats.stackexchange.com/questions/652757/plotting-a-nonlinear-function-and-its-values-in-r</guid>
      <pubDate>Wed, 14 Aug 2024 01:53:03 GMT</pubDate>
    </item>
    <item>
      <title>引导 Anderson-Darling 检验的渐近显著性水平</title>
      <link>https://stats.stackexchange.com/questions/652752/asymptotic-significance-level-of-the-bootstrap-anderson-darling-test</link>
      <description><![CDATA[假设我们希望测试给定分布 $F$ 是否属于某个参数族 $\mathfrak{F} = \{F_\theta \mid \theta \in \Theta\}$。在需要估计未知参数 $\theta$ 的情况下，常见测试统计量的分布（例如 Cramer-von Mise (CvM)、Kolmogorov-Smirnov (KS) 或 Anderson-Darling (AD)）将不是无分布的。因此，必须估计相关统计数据的临界值，例如使用参数引导法。
给定一个样本$X_1,\cdots, X_n \sim F$，可接受的做法是：

根据$X_1,\cdots , X_n$生成估计值$\hat{\theta}_n$。

使用估计值$\hat{\theta}$计算检验统计量。例如，在 Anderson-Darling 的情况下：
$$\hat{A}_n = n\int_{-\infty}^\infty\frac{(F_n(x)-F(x|\hat{\theta}_n))^2}{F(x|\hat{\theta}_n)(1-F(x|\hat{\theta}_n))}\ dF(x|\hat{\theta}_n).$$

使用 Bootstrap 估计 $\hat{A}_n$ 的分布。重复采样$X^*_{1},\cdots, X^*_{n} \sim F(\cdot|\hat{\theta}_n)$以生成一系列估计值$\hat{\theta}^*_{n}$和一批引导统计数据
$$A^*_{n} = n\int_{-\infty}^\infty\frac{(F_{n}^*(x)-F(x|\hat{\theta}^*_{n}))^2}{F(x|\hat{\theta}^*_{n})(1-F(x|\hat{\theta}^*_{n}))}\ dF(x|\hat{\theta}^*_{n}).$$

根据 $A^*_n$ 的分布，估计您感兴趣的任何重要性水平 $\alpha$ 的临界值 $c^*_\alpha$。然后可以使用它来评估 $\hat{A}_n$ 的重要性。


例如，可以在 此处 中显示（另请参阅 此处 适用于 $F$ 为离散的情况），当检验统计量为 Cramer-von Mise 或 Kolmogorov-Smirnov 时，自举检验将表现良好，即，
$$A^*_{n} - \hat{A}_n \rightarrow 0\ \text{ a.s.},\quad\text{and}\quad \Pr(\hat{A}_n \ge c^*_\alpha) \rightarrow \alpha \tag{*}$$
在 $n$ 的极限下，在某些规律下条件。
我的问题是，对于 Anderson-Darling 统计的情况，这个结果 $(*)$ 是否仍然成立？我查看了一些相关参考资料，证明总是在 CvM 或 KS 统计的背景下给出。特别是，它严重依赖于诸如均匀收敛之类的东西以及连续映射定理之类的结果，而这些结果似乎不适用于 Anderson-Darling 统计（或者至少我不确定如何修改/证明该论点）。在我看来，分母项导致了复杂性。是否有适用于 Anderson-Darling 的现有证明的简单修改？
注意：我知道，在实践中，人们确实将 Anderson-Darling 统计与 bootstrap 结合使用，并且从经验上看 $(*)$ 似乎确实成立。我对严格的证明很感兴趣。]]></description>
      <guid>https://stats.stackexchange.com/questions/652752/asymptotic-significance-level-of-the-bootstrap-anderson-darling-test</guid>
      <pubDate>Tue, 13 Aug 2024 23:47:44 GMT</pubDate>
    </item>
    <item>
      <title>Johnson、Kotz 和 Balakrishnan 中的符号：$\beta_1$ 和 $\beta_2$</title>
      <link>https://stats.stackexchange.com/questions/652745/notation-in-johnson-kotz-and-balakrishnan-beta-1-and-beta-2</link>
      <description><![CDATA[我面前有一本由 Johnson、Kotz 和 Balakrishnan 编写的《连续单变量分布》第 1 卷第二版。第 19 页上写着：

Pearson 和 Hartley (1972) 中的表格给出了 $\sqrt{\beta_1}=0.0(0.1)2.0$ 和 $\beta_2$ 的 Pearson 系统分布的标准化分位数（百分位数），精确到小数点后四位，间隔为 $0.2.$

在那之前，我在这本书中找不到任何地方提到 $\beta_1$ 和 $\beta_2$ 是什么，但这本书在续集中严重依赖这种符号。
什么是我错过了吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/652745/notation-in-johnson-kotz-and-balakrishnan-beta-1-and-beta-2</guid>
      <pubDate>Tue, 13 Aug 2024 21:01:35 GMT</pubDate>
    </item>
    <item>
      <title>GARCH 模型（使用 rugarch R）的条件方差只是一条倾斜的线</title>
      <link>https://stats.stackexchange.com/questions/652739/conditional-variance-from-the-garch-model-using-rugarch-r-is-just-a-sloping-li</link>
      <description><![CDATA[我试图使用 R 中的 GARCH 模型估计 1970 年至 2022 年实际汇率 USD/MGA 的波动性。
我一直在使用此代码，但不确定哪部分是错误的，或者我错过了什么错误：
library(fpp2)
library(fpp3)
library(tidyverse)
library(ggplot2)
library(urca)
library(rugarch)
library(openxlsx)
library(tseries)

d = read.xlsx(&quot;GARCH.xlsx&quot;)

donnes = ts(d$Taux.de.change.réel, start = 1970, frequency = 1)
donnees = log(donnes)
plot(donnees)

adf.test(donnees)
ggtsdisplay(donnees)

vrai = diff(donnes)
adf.test(vrai)
ggtsdisplay(vrai)

ARIMA = auto.arima(donnees, d=1, stepwise = FALSE, approximation = FALSE, trace = TRUE)

garch_spec = ugarchspec(variance.model = list(model = &quot;sGARCH&quot;, garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = &quot;norm&quot;)
fit &lt;- ugarchfit(spec = garch_spec, data = vrai)
fit
Volatilité = ts(fit@fit$sigma^2, frequency = 1, start = 1970)
图（波动性）

我得到了这个输出：
增强型 Dickey-Fuller 检验

数据：donnees
Dickey-Fuller = -1.4992，滞后阶数 = 3，p 值 = 0.776
备选假设：平稳

增强型 Dickey-Fuller 检验

数据：vrai
Dickey-Fuller = -3.9759，滞后阶数 = 3，p 值 = 0.01738
备选假设：平稳

系列：donnees 
ARIMA(0,1,0) 

sigma^2 = 0.01336：对数似然 = 38.42
AIC=-74.84 AICc=-74.76 BIC=-72.89

*---------------------------------*
* GARCH 模型拟合度 *
*---------------------------------*

条件方差动态
-----------------------------------
GARCH 模型：sGARCH(1,1)
均值模型：ARFIMA(0,0,0)
分布：范数

最优参数
------------------------------------
估计标准差。误差 t 值 Pr(&gt;|t|)
mu 16.828 3.3798e+01 0.497912 0.61855
omega 75.742 1.8822e+03 0.040242 0.96790
alpha1 0.000 7.7490e-03 0.000002 1.00000
beta1 0.999 2.5192e-02 39.655890 0.00000

稳健标准误差：
估计标准差。误差 t 值 Pr(&gt;|t|)
mu 16.828 2.7135e+01 0.620176 0.53514
omega 75.742 2.1577e+03 0.035103 0.97200
alpha1 0.000 9.6160e-03 0.000001 1.00000
beta1 0.999 4.3444e-02 22.994979 0.00000

对数似然：-359.5829 

信息标准
------------------------------------

Akaike 13.984
Bayes 14.134
Shibata 13.973
Hannan-Quinn 14.042

标准化残差的加权 Ljung-Box 检验
------------------------------------
统计 p 值
Lag[1] 0.9055 0.3413
Lag[2*(p+q)+(p+q)-1][2] 1.1155 0.4623
Lag[4*(p+q)+(p+q)-1][5] 1.2851 0.7925
d.o.f=0
H0：无序列相关

标准化平方残差的加权 Ljung-Box 检验
------------------------------------
统计 p 值
Lag[1] 0.003144 0.9553
Lag[2*(p+q)+(p+q)-1][5] 3.196283 0.3724
Lag[4*(p+q)+(p+q)-1][9] 5.055452 0.4213
d.o.f=2

加权 ARCH LM 检验
------------------------------------
统计形状尺度 P 值
ARCH Lag[3] 4.708 0.500 2.000 0.03002
ARCH Lag[5] 4.765 1.440 1.667 0.11641
ARCH Lag[7] 5.616 2.315 1.543 0.16921

Nyblom 稳定性检验
------------------------------------
联合统计：0.7215
个体统计：
mu 0.0724
omega 0.2989
alpha1 0.2336
beta1 0.2986

渐近临界值（10% 5% 1%）

联合统计量：1.07 1.24 1.6

个体统计量：0.35 0.47 0.75

符号偏差检验
------------------------------------
t 值 prob sig
符号偏差 1.2085 0.2329 
负符号偏差 0.5125 0.6107 
正符号偏差 0.1342 0.8938 
联合效应 5.0905 0.1653 

调整后的 Pearson 拟合优度检验：
------------------------------------
组统计量 p 值（g-1）
1 20 11.08 0.9212
2 30 25.31 0.6622
3 40 34.15 0.6904
4 50 40.31 0.8072

我得到了这个图表：

提前感谢您的帮助。
Tldr：我尝试了 rugarch，但条件方差根本没有反映数据的波动性，我不确定我做错了什么。]]></description>
      <guid>https://stats.stackexchange.com/questions/652739/conditional-variance-from-the-garch-model-using-rugarch-r-is-just-a-sloping-li</guid>
      <pubDate>Tue, 13 Aug 2024 19:13:36 GMT</pubDate>
    </item>
    <item>
      <title>具有非连续间隔的生存分析中的计数过程方法？</title>
      <link>https://stats.stackexchange.com/questions/652728/counting-process-approach-in-survival-analysis-with-non-contiguous-intervals</link>
      <description><![CDATA[我正在 R 中设置 Cox 比例风险模型来分析复发事件发生前的生存时间。每个案例都可能经历多次复发事件，因此我决定采用计数过程方法，记录每次“生存”的 time_start 和 time_stop间隔。
在对复发事件进行生存分析的计数过程方法中，我可以找到的所有示例都记录了给定主题中第一次事件的时间，然后数据集直接在此时间点（在我的示例中为 3 个月）继续，直到第二次事件的时间段。



id
tstart（以月为单位）
tstop（以月为单位）




1
0
3


1
3
7



但是，在我的数据中，复发事件本身就涵盖了某个时间段，因此第二个间隔的开始时间与第一个间隔的停止时间不再相同。



id
tstart（以月为单位）
tstop（以月为单位）




1
0
3


1
6
10



我的问题是，计数过程方法中的 Cox 模型能否处理这两个间隔之间的时间间隔，其中受试者实际上有经历事件的风险？我必须采取任何措施来解决这个问题吗？
我一直在考虑的替代方法是“标准”Cox 模型，就像单个事件数据一样，但对受试者和先前事件是/否的层次具有稳健的标准误差（因为我对事件顺序没有具体的假设）。
任何指导都非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/652728/counting-process-approach-in-survival-analysis-with-non-contiguous-intervals</guid>
      <pubDate>Tue, 13 Aug 2024 16:55:40 GMT</pubDate>
    </item>
    <item>
      <title>确定最适合具有较大 NA % 的 MAR 多变量数据的插补方法以及相应的实施策略</title>
      <link>https://stats.stackexchange.com/questions/652759/determining-most-appropriate-imputation-method-for-mar-multivariate-data-with-la</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/652759/determining-most-appropriate-imputation-method-for-mar-multivariate-data-with-la</guid>
      <pubDate>Tue, 13 Aug 2024 11:41:01 GMT</pubDate>
    </item>
    <item>
      <title>同一 GAM 模型的不同结果取决于“discrete = TRUE”</title>
      <link>https://stats.stackexchange.com/questions/652707/different-results-of-the-same-gam-model-depends-on-discrete-true</link>
      <description><![CDATA[我正在使用 bam 函数拟合 GAM。
该模型的代码是：
 mod_1 &lt;- bam(n ~ s(age, by = period, k = 15) + 
s(hh_size, by = period, k = 9) +
period +
s(token, bs = &quot;re&quot;) + s(Bundesland, bs = &quot;re&quot;) + s(period, bs = &quot;re&quot;),
data = halle_data_household,
method = &quot;fREML&quot;, discrete = TRUE,
family = nb(),
nthreads = c(4,1))
mod_2 &lt;- bam(n ~ s(age, by = period, k = 15) + 
s(hh_size, by = period, k = 9) +
period +
s(token, bs = &quot;re&quot;) + s(Bundesland, bs = &quot;re&quot;) + s(period, bs = &quot;re&quot;),
data = halle_data_household,
method = &quot;fREML&quot;, 
family = nb(),
nthreads = c(4,1))

两个模型的区别在于&quot;discrete = TRUE&quot;，以加快计算时间。但我得到了两个不同的结果。
mod_1 的结果
 家庭：负二项式 (13.366) 
链接函数：log 

公式：
n ~ s(age, by = period, k = 15) + s(hh_size, by = period, k = 9) + 
period + s(token, bs = &quot;re&quot;) + s(Bundesland, bs = &quot;re&quot;) + 
s(period, bs = &quot;re&quot;)

参数系数：
估计标准差。误差 t 值 Pr(&gt;|t|) 
(截距) 0.5409 0.1354 3.996 6.74e-05 ***
period2 -0.1253 0.1674 -0.749 0.454 
period3 -0.1319 0.1600 -0.825 0.410 
---
显著性。代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

平滑项的近似显著性：
edf Ref.df F p 值 
s(age):period1 1.000e+00 1.000 0.641 0.423337 
s(age):period2 4.683e+00 5.656 3.799 0.001034 ** 
s(age):period3 4.569e+00 5.444 4.928 0.000116 ***
s(hh_size):period1 1.960e+00 2.412 1.186 0.303077 
s(hh_size):period2 1.000e+00 1.000 1.798 0.180227 
s(hh_size):period3 1.000e+00 1.000 5.930 0.014997 * 
s(token) 4.406e+02 859.000 1.242 &lt; 2e-16 ***
s(Bundesland) 5.429e-05 15.000 0.000 0.801883 
s(period) 1.082e-14 3.000 0.000 0.999933 
---
意义。代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

R-sq.(adj) = 0.323 偏差解释 = 42.4%
fREML = 3657.9 尺度估计 = 1 n = 2115

mod_2 的结果
 系列：负二项式 (13.32) 
链接函数：log 

公式：
n ~ s(age, by = period, k = 15) + s(hh_size, by = period, k = 9) + 
period + s(token, bs = &quot;re&quot;) + s(Bundesland, bs = &quot;re&quot;) + 
s(period, bs = &quot;re&quot;)

参数系数：
估计标准误差 t 值 Pr(&gt;|t|) 
(截距) 0.32541 0.05293 6.148 9.83e-10 ***
period2 -0.12288 0.07204 -1.706 0.08824 . 
period3 -0.20909 0.06826 -3.063 0.00222 ** 
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

平滑项的近似显著性：
edf Ref.df F p 值 
s(age):period1 1.000e+00 1.000 0.641 0.423576 
s(age):period2 4.685e+00 5.661 3.801 0.001061 ** 
s(age):period3 4.568e+00 5.442 4.963 0.000117 ***
s(hh_size):period1 1.961e+00 2.417 1.036 0.311454 
s(hh_size):period2 1.000e+00 1.000 1.811 0.178523 
s(hh_size):period3 1.000e+00 1.000 5.930 0.014986 * 
s(token) 4.405e+02 857.000 1.226 &lt; 2e-16 ***
s(Bundesland) 6.066e-05 15.000 0.000 0.802106 
s(period) -9.299e-16 3.000 0.000 0.031014 * 
---
意义代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

R-sq.（调整） = 0.322 偏差解释 = 42.4%
fREML = 3406.3 尺度估计 = 1 n = 2115
]]></description>
      <guid>https://stats.stackexchange.com/questions/652707/different-results-of-the-same-gam-model-depends-on-discrete-true</guid>
      <pubDate>Tue, 13 Aug 2024 09:47:41 GMT</pubDate>
    </item>
    <item>
      <title>与 ci 的风险差异</title>
      <link>https://stats.stackexchange.com/questions/652760/risk-difference-with-ci</link>
      <description><![CDATA[我有以下数据：
library(cobalt)
library(tidycmprsk)
library(ggsurvfit)
library(gtsummary)

set.seed(123)
lalonde &lt;- cbind(lalonde,
event = sample(c(0, 1), size = 614, replace = TRUE, prob = c(0.84, 0.16)),
time = runif(614, min = 10, max = 365))
n &lt;- ceiling(0.05 * nrow(lalonde)) 
selected_indices &lt;- sample(1:nrow(lalonde), size = n)
lalonde[selected_indices, &quot;event&quot;] &lt;- 2

lalonde$event &lt;- factor(lalonde$event, levels = c(0, 1, 2),
labels = c(&quot;Censored&quot;, &quot;Event1&quot;, &quot;Event2&quot;))

我可以从累积发生率函数中得出绝对风险：
p &lt;- cuminc(Surv(time, event) ~ treat, lalonde) %&gt;% 
tbl_cuminc(
times = c(180, 230),
label_header = &quot;**{time}-day cuminc**&quot;) 

得出：
特征 180 天 cuminc 230 天 cuminc
treat 

0 8.1% (5.6%, 11%) 14% (11%, 19%)
1 9.1% (5.3%, 14%) 13% (8.2%, 20%)

如何计算指定时间点的风险差异和置信区间？]]></description>
      <guid>https://stats.stackexchange.com/questions/652760/risk-difference-with-ci</guid>
      <pubDate>Tue, 13 Aug 2024 08:25:01 GMT</pubDate>
    </item>
    <item>
      <title>由指数和确定的概率数值稳定对数概率</title>
      <link>https://stats.stackexchange.com/questions/652651/probability-determined-from-sum-of-exponentials-numerically-stable-log-probabili</link>
      <description><![CDATA[在这个问题中，我问：
如果我们有：$\tau_i \overset{\text{independent}}{\sim}
\exp(\lambda_i)$，对于$i=1,2,3,...,n$，其中$\lambda_i\neq \lambda_j, \forall i\neq j$，那么我想找到概率的一般形式：
$$
\text{Pr}(\sum_{i=1}^{n-1} \tau_i \leq t, \sum_{i=1}^{n} \tau_i &gt; t)
$$
我收到了 Ben 的回答：
$$
\sum_{i=1}^{n-1} m_{n,i} \cdot [ \exp (- \lambda_i t) - \exp (- \lambda_n t) ],
$$
其中术语 $m_{n,j}$ 定义为如：
$$
m_{n,i} = \frac{\lambda_i}{\lambda_n} \prod_{j=1 \\ j \neq i}^{n} \frac{\lambda_j}{\lambda_j-\lambda_i}。
$$
我发现，当 $n$ 相当大（甚至高于 10）时，上述规则计算出的概率在计算上可能会变为负数。即由于 $m_{n,i}$ 既可以为正数也可以为负数，因此计算的精度对于确保概率为正数非常重要。
我想知道是否有一种计算稳定的方法来计算 对数概率？
注意：我意识到 $m_{n,i}$ 的一部分就是所谓的 拉格朗日多项式：
$$
l_j(0) := \prod_{j=1 \\ j \neq i}^{n} \frac{\lambda_j}{\lambda_j-\lambda_i},
$$
其确实有一个稳定的形式定义在这里。不过，我试过了，对于中等大小的 n，我仍然会得到负概率。这也是我希望找到对数概率更稳定表达式的部分原因；使用对数概率也更方便，因为我正在做使用这个的 MCMC。
注意：使用这里设计的一些用于稳定和对数的巧妙解决方案并不简单，因为$m_{n,i}$ 可能是负数。]]></description>
      <guid>https://stats.stackexchange.com/questions/652651/probability-determined-from-sum-of-exponentials-numerically-stable-log-probabili</guid>
      <pubDate>Mon, 12 Aug 2024 13:33:50 GMT</pubDate>
    </item>
    </channel>
</rss>