<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Thu, 07 Nov 2024 12:31:47 GMT</lastBuildDate>
    <item>
      <title>一个简单的隐马尔可夫模型</title>
      <link>https://stats.stackexchange.com/questions/656887/a-simple-hidden-markov-model</link>
      <description><![CDATA[我正在阐明简单隐马尔可夫模型的 EM 算法的精确公式。这个问题来自 Keener 的教科书《理论统计学》第 9 章第 25 个问题，其中介绍了几个用于计算 MLE 的 EM 算法的实际示例。
这个问题假设以下简单马尔可夫过程。令 $X_1, X_2, \cdots$ 为伯努利变量，$EX_1=1/2$，联合质量函数由递归确定
$$ P(X_{k+1}\ne x_k \vert X_1 =x_1, \cdots, X_k=x_k)=\theta, \quad n=, 1, 2, \cdots $$
且 $X_n, n\ge 1$ 在 $\left\{0, 1\right\}$ 上形成马尔可夫链。现在假设我们能够观察到误差，因此通过$Y_1, Y_2, \cdots$，它们是给定$X_i$条件独立的伯努利变量，满足
$$ P(Y_i \ne X_i\vert X_1, X_2, \cdots) = \gamma$$
其中$\gamma$是已知常数，我们希望通过 EM 算法估计$\theta\in(0, 1)$。
一旦我得到$X$和$Y$ 建立 E-step，即
$$
\begin{cases}
P_{\theta}(X, Y) &amp;= P_{\theta}(Y\vert X)P_{\theta}(X)\\
&amp;= \prod_{i=1}^{n} P_{\theta}(Y_i\vert X_i)P_{\theta}(X_i\vert X_{i-1}), 
\end{cases}
$$
目前还没有办法将这个质量函数总结成一个单一的闭式形式。此外，最终应该计算期望值$E_{\theta}[X\vert Y]$，引入一些新变量使公式更简单的巧妙方法似乎是必要的。
任何建议都将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/656887/a-simple-hidden-markov-model</guid>
      <pubDate>Thu, 07 Nov 2024 11:36:54 GMT</pubDate>
    </item>
    <item>
      <title>使用哪种类型的模型/分析来预测时间序列数据中的事件</title>
      <link>https://stats.stackexchange.com/questions/656886/what-type-of-model-analysis-to-use-to-predict-events-in-time-series-data</link>
      <description><![CDATA[我有一堆包含已知真实世界事件的时间序列（每个 t/s 一个事件）。事件不一定是 t/s 中可见的变化，但已知它已在现实世界中发生。
我想知道我是否可以训练一个模型来了解事件之前是否存在任何特征模式，以用于预测其他 t/s 或未来相同 t/s 中的类似事件。
这不是干预分析，因为我们不关心事件发生后发生了什么。这也不是变点分析，因为我们确切地知道事件发生的时间。这也不是异常检测，因为事件不一定会对数据产生影响。
RNN 是否是这项任务的正确或最佳工具？这种分析有通用名称吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/656886/what-type-of-model-analysis-to-use-to-predict-events-in-time-series-data</guid>
      <pubDate>Thu, 07 Nov 2024 11:21:14 GMT</pubDate>
    </item>
    <item>
      <title>逻辑回归何时优于随机森林？</title>
      <link>https://stats.stackexchange.com/questions/656884/when-does-logistic-regression-outperform-random-forests</link>
      <description><![CDATA[假设我们有一个二元分类问题，那么两种可能的统计方法是逻辑和随机森林。
从理论的角度来看，我很清楚，如果对数概率$log(\frac{q}{1-q})$和特征$X_1, ... X_p$之间有足够的线性关系，那么逻辑在构造上就是更强的候选者。
但是，我们如何以图形方式测试我们是否真的有这种线性关系？例如，在线性回归的情况下，这相当容易做到：我们可以绘制目标与协变量的关系，并且我们对目标和协变量之间的关系的线性程度有合理的理解。但是逻辑的情况呢？]]></description>
      <guid>https://stats.stackexchange.com/questions/656884/when-does-logistic-regression-outperform-random-forests</guid>
      <pubDate>Thu, 07 Nov 2024 11:12:01 GMT</pubDate>
    </item>
    <item>
      <title>𝑛 相关随机变量的加权平均值的方差</title>
      <link>https://stats.stackexchange.com/questions/656883/variance-of-weighted-average-of-correlated-random-variables</link>
      <description><![CDATA[此答案解释了如何计算 n 个相关随机变量的平均值的方差。如何计算 n 个相关随机变量的加权平均值？我的随机变量是联合多元高斯分布的。
此答案解释了如何计算单个随机变量的不同实现的加权平均值，其中权重也是随机变量的实现。我的权重不是随机变量，而是固定数字，所以问题不同。
我知道这很可能是纸笔数学的问题，但我担心这个问题超出了我的能力。]]></description>
      <guid>https://stats.stackexchange.com/questions/656883/variance-of-weighted-average-of-correlated-random-variables</guid>
      <pubDate>Thu, 07 Nov 2024 11:06:46 GMT</pubDate>
    </item>
    <item>
      <title>当增加对数正态分布的标准差时，它是否会趋向于指数分布？</title>
      <link>https://stats.stackexchange.com/questions/656881/does-a-log-normal-distribution-tend-to-an-exponential-distribution-when-increas</link>
      <description><![CDATA[对数正态分布 exp(mu, sigma) 会随着其标准差 sigma 的增加而变得越来越偏斜。
同样，指数分布 lognorm(lambda) 会随着其速率 lambda 的增加而变得越来越偏斜。
这两个函数及其参数之间有什么关系吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/656881/does-a-log-normal-distribution-tend-to-an-exponential-distribution-when-increas</guid>
      <pubDate>Thu, 07 Nov 2024 10:59:27 GMT</pubDate>
    </item>
    <item>
      <title>在 mgcv 中选择 GAM 的惩罚，bs =“ts”或 select = TRUE 之间的区别？</title>
      <link>https://stats.stackexchange.com/questions/656878/choosing-penalty-for-gam-in-mgcv-difference-between-bs-ts-or-select-true</link>
      <description><![CDATA[我正在研究一些环境数据，使用 GAM 模型来了解土壤中 DOC 的控制因素。我在选择合适的 GAM 模型和惩罚方面遇到了一些问题。在 mgcv::gam 中，有两种方法可以向协变量引入额外的惩罚：
*) bs = &quot;ts 用于薄板样条函数； bs = &quot;cs&quot; 表示三次样条函数，用于惩罚零空间。
*) select = TRUE 表示对模型中的所有样条函数进行双重惩罚，同时惩罚零空间和范围空间。
更多信息请参见 此处 和 此处。
我有这四个模型
mod1 &lt;- mgcv::gam(y ~ s(x1) + s(x2) + s(x3), select = TRUE)
mod2 &lt;- mgcv::gam(y ~ s(x1, bs = &quot;ts&quot;) + s(x2, bs = &quot;cs&quot;) + s(x3, bs = &quot;ts&quot;))
mod3 &lt;- mgcv::gam(y ~ s(x1) + s(x2, bs = &quot;cr&quot;) + s(x3), select = TRUE)
mod4 &lt;- mgcv::gam(y ~ s(x1, bs = &quot;ts&quot;) + s(x2, bs = &quot;cs&quot;) + s(x3), select = TRUE)
s(x1) 和s(x3) 是具有一定意义的预测因子，而 s(x2) 是时间。
我在这里尝试做的事情：我想通过额外的惩罚来选择一个模型，同时还为一些变量选择样条基函数的类型，我对收缩方法与双重惩罚方法的用法感到困惑。
对我来说，模型 mod4 没有意义，因为它会对基样条的范围和零空间造成 select = TRUE 的双重惩罚，而样条的零空间已经受到 &quot;ts&quot; 和 &quot;cs&quot; 收缩版本的惩罚。
同时，mod3 在我看来是在您有一个时间变量需要通过 bs = 进行平滑的情况下的最佳选择&quot;cr&quot; 加上一个协变量，并且您希望在零空间和范围空间中惩罚平滑项以进行模型选择。
根据我对此的基本理解，最佳选择是 mod2 或 mod3，因为 mod1 只会假设所有平滑的薄板基函数，而情况并非如此，因为 s(x2) 是时间。
最后，如果 mod4 规范完全错误，mgcv::gam 不应该弹出警告或错误吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/656878/choosing-penalty-for-gam-in-mgcv-difference-between-bs-ts-or-select-true</guid>
      <pubDate>Thu, 07 Nov 2024 09:03:35 GMT</pubDate>
    </item>
    <item>
      <title>线性混合模型的平行中介分析</title>
      <link>https://stats.stackexchange.com/questions/656876/parallel-mediation-analysis-with-linear-mixed-model</link>
      <description><![CDATA[我想用线性混合模型进行并行中介分析，因为我的数据是非正态的。
HAMA_psy 和 RRS_brood 是中介，Sadness 是 IV，Melankoli 是 DV。
我已经创建了一个模型，并使用引导函数计算了间接效应，但是当我不使用 lavaan 时，我没有考虑路径间依赖关系。这就是我认为它错误的原因。
如果您能帮助我使用 LME 进行并行调解，我将非常高兴。
我的模型是：

sadness_to_hama_psy &lt;- lmer(HAMA_psy ~ Sadness + (1 | PartID), data = df)
sadness_to_rrs_brood &lt;- lmer(RRS_brood ~ Sadness + (1 | PartID), data = df)
hama_psy_to_melankoli &lt;- lmer(Melankoli ~ HAMA_psy + Sadness + (1 | PartID), data = df)
rrs​​_brood_to_melankoli &lt;- lmer(Melankoli ~ RRS_brood + Sadness + (1 | PartID), data = df)
indirect_effect_hama_psy &lt;- fixef(sadness_to_hama_psy)[&quot;悲伤&quot;] * fixef(hama_psy_to_melankoli)[&quot;HAMA_psy&quot;]
indirect_effect_rrs_brood &lt;- fixef(sadness_to_rrs_brood)[&quot;悲伤&quot;] *fixef(rrs_brood_to_melankoli)[&quot;RRS_brood&quot;]

total_indirect_effect &lt;- indirect_effect_hama_psy + indirect_effect_rrs_brood

direct_effect &lt;- fixef(hama_psy_to_melankoli)[&quot;悲伤&quot;] + fixef(rrs_brood_to_melankoli)[&quot;悲伤&quot;]

total_effect &lt;- total_indirect_effect + direct_effect
boot_results &lt;- boot(data = df, 
statistic = function(data, indices) {
d &lt;- data[indices, ] # 重新采样数据

# 将模型重新拟合到引导样本
model_sadness_to_hama_psy &lt;- lmer(HAMA_psy ~ Sadness + Stage + (1 | PartID), data = d)
model_sadness_hama_psy_to_melankoli &lt;- lmer(Melankoli ~ Sadness + HAMA_psy + Stage + (1 | PartID), data = d)
model_sadness_rrs_brood_to_melankoli &lt;- lmer(Melankoli ~ Sadness + RRS_brood + Stage + (1 | PartID), data = d)

# 从每个模型中提取系数（固定效应）
coefs_sadness_to_hama_psy &lt;- fixef(model_sadness_to_hama_psy)
coefs_sadness_hama_psy_to_melankoli &lt;- fixef(model_sadness_hama_psy_to_melankoli)
coefs_sadness_rrs_brood_to_melankoli &lt;- fixef(model_sadness_rrs_brood_to_melankoli)

# 计算直接和间接影响
direct_effect &lt;- coefs_sadness_hama_psy_to_melankoli[&quot;Sadness&quot;]

indirect_hama_psy &lt;- coefs_sadness_to_hama_psy[&quot;Sadness&quot;] * coefs_sadness_hama_psy_to_melankoli[&quot;HAMA_psy&quot;]

indirect_rrs_brood &lt;- coefs_sadness_rrs_brood_to_melankoli[&quot;Sadness&quot;] * coefs_sadness_rrs_brood_to_melankoli[&quot;RRS_brood&quot;]

total_indirect_effect &lt;- indirect_hama_psy + indirect_rrs_brood

},
R = 1000)

boot.ci(boot.out = boot_results, type = &quot;perc&quot;)

]]></description>
      <guid>https://stats.stackexchange.com/questions/656876/parallel-mediation-analysis-with-linear-mixed-model</guid>
      <pubDate>Thu, 07 Nov 2024 08:18:53 GMT</pubDate>
    </item>
    <item>
      <title>Seber 和 Lee 的“线性回归分析”中的证明</title>
      <link>https://stats.stackexchange.com/questions/656871/proof-in-linear-regression-analysis-by-seber-and-lee</link>
      <description><![CDATA[在附录结果 A.2.2 中，作者想要证明：
如果 $A$ 是任意矩阵，并且 $P$ 和 $Q$ 是任意一致的非奇异矩阵，则 $rank(PAQ) = rank(A)$
他们通过给出以下不等式序列开始证明：
$rank(A) \leq rank (AQ) \leq rank(AQQ^{-1}) = rank(A)\quad\quad [1]$
此前，在 A.2.1 中，他们已经证明如果 $A$ 和 $B$ 是一致矩阵，那么，$rank(AB) \leq \min({rank(A),rank(B)})$
虽然这个结果可以用来建立 $[1]$ 后面的不等式，但我不清楚第一个不等式 $rank(A)\leq rank(AQ)$ 是如何建立的。如果 $Q$ 是非奇异的，那么 $rank(A)\leq rank(AQ)$ 是否在其他地方已知？任何足够简单的证明该结果或展示该结果的地方都将不胜感激。
这里是他们书中对该结果的陈述和证明的 imgur 链接，在下面内联复制：
]]></description>
      <guid>https://stats.stackexchange.com/questions/656871/proof-in-linear-regression-analysis-by-seber-and-lee</guid>
      <pubDate>Thu, 07 Nov 2024 05:18:35 GMT</pubDate>
    </item>
    <item>
      <title>在回归模型中仅使用滞后预测变量而不使用非滞后预测变量？</title>
      <link>https://stats.stackexchange.com/questions/656870/only-using-a-lagged-predictor-in-a-regression-model-and-not-the-unlagged</link>
      <description><![CDATA[在统计回归模型中，仅使用预测变量的滞后值是否很常见？例如

选项 1

$$
s_{t} = f(i_{t}, i_{t-1}, u_{t}, u_{t-1})
$$

选项 2

$$
s_{t} = f(i_{t}, u_{t})
$$
其中 $s_{t}$ 是时间 $t$ 的销售额，而 $i_{t}$ 和 $u_{t}$ 是通货膨胀以及 $t$ 时刻的失业率。
我的逻辑是，也许前一个时间段的信息比当前时间段的信息更能描述销售额？选项 2 是统计分析建模中的常见做法吗？还是非滞后变量也是强制性的（选项 1）？]]></description>
      <guid>https://stats.stackexchange.com/questions/656870/only-using-a-lagged-predictor-in-a-regression-model-and-not-the-unlagged</guid>
      <pubDate>Thu, 07 Nov 2024 05:02:57 GMT</pubDate>
    </item>
    <item>
      <title>RCT 中的随机重复观察</title>
      <link>https://stats.stackexchange.com/questions/656869/random-repeated-observations-in-rct</link>
      <description><![CDATA[我的问题是关于 RCT，其中我们每个单元收到许多重复的观察结果，但我们不一定想将它们汇总在一起。下面是一个具体的例子。假设我正在为学生学习工具的两个版本运行 RCT。假设我们不知道学生的家庭作业。每个学生都会报告他们的家庭作业成绩，但作业数量是随机的。例如：



治疗
学生 ID
观察




1
1
90/100（科目 1）、8/10（科目 3）、7/10（科目 5）


1
2
80/100（科目 2）


1
3
40/50（科目 4）， 15/20（科目 2）


0
4
70/100（科目 2）


0
5
7/10（科目 1），40/50（科目 3）


0
6
7/10（科目 5）



直观地说，我想说每个学生都有一定的概率 $p$ 正确回答问题。在分配治疗时，我有学生协变量（例如，GPA、在校年份等），我计划在回归中使用它。
几个具体问题：

一种方法是通过对分子和分母求和来汇总所有数据。现在每个学生都有一个观察值（对于学生 1，它将是 105/120），但这似乎不会遗漏我拥有的全部信息。有没有办法设计一个回归设置，可以帮助我在不进行汇总的情况下分析这些数据？除了学生协变量之外，我还应该使用学生随机效应吗？
假设学生还报告了家庭作业的科目。由于这些是在分配治疗后观察到的，因此不应将它们用作回归模型中的协变量。有没有办法使用这些信息？由于观察对象可能不同，因此观察结果会存在一些差异，我不确定该如何处理。
]]></description>
      <guid>https://stats.stackexchange.com/questions/656869/random-repeated-observations-in-rct</guid>
      <pubDate>Thu, 07 Nov 2024 04:53:14 GMT</pubDate>
    </item>
    <item>
      <title>如何将 2 个方差与观察到的方差分开？</title>
      <link>https://stats.stackexchange.com/questions/656846/how-to-separate-2-variances-from-observed-variance</link>
      <description><![CDATA[我将其分解为以下内容：
var(predicted_conc) = actual_conc*var1 + var2
请注意，随机变量生成器是独立的，因此添加的是方差而不是标准差。
我首先运行模拟来重新生成该信息。
actual_conc &lt;- c(0,3, 5, 10, 20, 30,50,80,90, 100, 150, 180)

predicted_conc &lt;- c()
for(i in actual_conc){
predicted_conc &lt;- c(predicted_conc, i + rnorm(1000, mean =0, sd = (0.05*i)) + rnorm(1000, mean = 0, sd = 0.1))
}

如您所见，我必须将随机变量生成与按浓度缩放或只是常数分开。
但是，这种关系不是线性的。然后我计算方差，非线性关系变得非常明显，如果我拟合线性或二次回归，我会得到负截距，其中实际常数方差为 0.01。
尽管我在这个模拟中接近真实值，如果我使用 sd 而不是 var，并且将 sd~conc 建模为常数方差很小，但我认为这应该是更正确的建模方法。
欢迎提出想法。
谢谢！
编辑
我猜这与方差有关，因为零会导致零结果！我当然有坚定的假设，即浓度在任何时候都不会为负。]]></description>
      <guid>https://stats.stackexchange.com/questions/656846/how-to-separate-2-variances-from-observed-variance</guid>
      <pubDate>Wed, 06 Nov 2024 16:42:32 GMT</pubDate>
    </item>
    <item>
      <title>难道预期 Sarsa 是离策略的，而 SARSA 只是预期 SARSA 的 MC 估计，为什么它是在策略的呢？</title>
      <link>https://stats.stackexchange.com/questions/656843/is-expected-sarsa-is-off-policy-and-sarsa-is-just-an-mc-estimate-of-expected-sa</link>
      <description><![CDATA[因此，预期 SARSA 将更新定义为：
$$
Q(s,a) = Q(s,a) +\alpha (R+ \mathbb{E}_{a\sim\pi(s&#39;)}[Q(s&#39;, a)] - Q(s,a))
$$
其中 SARSA 将更新定义为 $a&#39;\sim\pi(s&#39;)$：
$$
Q(s,a) = Q(s,a) +\alpha (R+ Q(s&#39;, a&#39;) - Q(s,a))
$$
那么 SARSA 怎么会不仅仅是 ExpSARSA 的 MC 估计呢？既然 MC 是无偏的，那么为什么 SARSA 不应该是一种离策略算法呢？

编辑：由于我指的 MC 估计值似乎很清楚，出于某种原因，我的问题是：

这两个更新仅在预期值和 $Q(s&#39;, a&#39;\sim\pi(s&#39;)) \approx \mathbb{E}_{a\sim\pi(s&#39;)}[Q(s&#39;, a)]$ 上有所不同，因为它是一个样本蒙特卡罗估计，是一个无偏估计，所以没有理由一个应该是在策略上而另一个应该是在策略外，因为在预期中它们会导致相同的更新
]]></description>
      <guid>https://stats.stackexchange.com/questions/656843/is-expected-sarsa-is-off-policy-and-sarsa-is-just-an-mc-estimate-of-expected-sa</guid>
      <pubDate>Wed, 06 Nov 2024 15:53:03 GMT</pubDate>
    </item>
    <item>
      <title>R 中多个组之间的计数/比例的统计比较？</title>
      <link>https://stats.stackexchange.com/questions/656837/statistical-comparison-of-counts-proportions-between-multiple-groups-in-r</link>
      <description><![CDATA[我正在努力为一个数据集选择适当的统计分析，该数据集中有多个组（groupA-groupE），每个组在两个类别（健康或患病）中都有一定数量的计数，也可以表示为比例（患病/[患病+健康]）：
df &lt;- data.frame(group = c(&quot;groupA&quot;,&quot;groupB&quot;,&quot;groupC&quot;,&quot;groupD&quot;,&quot;groupE&quot;),
n_sick = c(12, 32, 99, 37, 48),
n_healthy = c(36, 250, 120, 68, 93))
df %&lt;&gt;% mutate(tot = n_sick + n_healthy, prop = n_sick / tot)

我想找出哪些组在统计上的比例不同，类似于在重复情况下在方差分析/Kruskal-Wallis+事后检验中所做的操作。但是，在这种情况下唯一可用的数据是每个组中患病和健康个体的数量。我知道我可以使用卡方检验来发现比例和组之间是否存在关系，但据我所知，没有标准化的事后检验来测试组间差异（如果我错了请纠正我！）。
我发现stats包包含一个名为pairwise_prop_test的函数，它看起来就像是我想要它做的事情：
t &lt;- as.table(rbind(
c(12, 32, 99, 37, 48),
c(36, 250, 120, 68, 93)))
dimnames(t) &lt;- list(
condition = c(&quot;n_sick&quot;, &quot;n_healthy&quot;),
group = c(&quot;groupA&quot;,&quot;groupB&quot;,&quot;groupC&quot;,&quot;groupD&quot;,&quot;groupE&quot;))

pairwise_prop_test(t, p.adjust.method = &quot;bonferroni&quot;)

... 它会针对组间每次比较得出一个 p.adj 值（例如，groupB 与 groupC 不同）。这是正确的方法吗，还是我忽略了什么？感谢您抽出时间来提供帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/656837/statistical-comparison-of-counts-proportions-between-multiple-groups-in-r</guid>
      <pubDate>Wed, 06 Nov 2024 14:33:01 GMT</pubDate>
    </item>
    <item>
      <title>Pymc-BART 索引错误</title>
      <link>https://stats.stackexchange.com/questions/656835/pymc-bart-index-error</link>
      <description><![CDATA[我尝试按照此处的示例笔记本进行操作，但在执行代码时遇到了一些 IndexError。
这是一个最小的工作示例：
import numpy as np
import pandas as pd
import pymc as pm
import pymc_bart as pmb
import pytensor.tensor as pt
from scipy.special import logit

# 读取样本数据
data_df = pd.read_csv(
&quot;https://raw.githubusercontent.com/juanitorduz/website_projects/master/data/retention_data.csv&quot;,
parse_dates=[&quot;cohort&quot;, &quot;period&quot;],
)

# 处理数据
eps = np.finfo(float).eps
train_data_red_df = data_df.query(&quot;cohort_age &gt; 0&quot;).reset_index(drop=True)
train_obs_idx = train_data_red_df.index.to_numpy()
train_n_users = train_data_red_df[&quot;n_users&quot;].to_numpy()
train_n_active_users = train_data_red_df[&quot;n_active_users&quot;].to_numpy()
train_retention = train_data_red_df[&quot;retention&quot;].to_numpy()
train_retention_logit = logit(train_retention + eps)
train_data_red_df[&quot;month&quot;] = train_data_red_df[&quot;period&quot;].dt.strftime(&quot;%m&quot;).astype(int)
features: list[str] = [&quot;age&quot;, &quot;cohort_age&quot;, &quot;month&quot;]
x_train = train_data_red_df[features]

# 模型
with pm.Model(coords={&quot;feature&quot;: features}) as model:
# --- 数据 ---
model.add_coord(name=&quot;obs&quot;, values=train_obs_idx, mutable=True)
x = pm.MutableData(name=&quot;x&quot;, value=x_train, dims=(&quot;obs&quot;, &quot;feature&quot;))
n_users = pm.MutableData(name=&quot;n_users&quot;, value=train_n_users, dims=&quot;obs&quot;)
n_active_users = pm.MutableData(name=&quot;n_active_users&quot;, value=train_n_active_users, dims=&quot;obs&quot;)

# --- 参数化 ---
# BART 组件在
# logit 变换下对保留率的图像进行建模，因此范围不限制在 [0, 1]。
mu = pmb.BART(
name=&quot;mu&quot;,
X=x,
Y=train_retention_logit,
dims=&quot;obs&quot;,
)
# 我们使用逆 logit 变换将保留率恢复到 [0, 1]。
p = pm.Deterministic(name=&quot;p&quot;, var=pm.math.invlogit(mu), dims=&quot;obs&quot;)
# 我们添加一个小的 epsilon 以避免数值问题。
p = pt.switch(pt.eq(p, 0), eps, p)
p = pt.switch(pt.eq(p, 1), 1 - eps, p)

# --- 可能性 ---
n_active_users_estimated = pm.Binomial(
name=&quot;n_active_users_estimated&quot;,
n=n_users,
p=p,
perceived=n_active_users,
dims=&quot;obs&quot;,
)

pm.model_to_graphviz(model=model)

# 拟合模型
使用模型：
idata = pm.sample(draws=100, chains=1)
posterior_predictive = pm.sample_posterior_predictive(trace=idata)

我已检查 x_train 和 train_retention_logit 的形状传递给 BART 方法，它们似乎具有正确的形状，分别为 (1128,3) 和 (1128,)。
然而，后验采样返回了一个我无法追溯到其来源的错误：
IndexError：元组索引超出范围
导致错误的应用节点：BART_rv{&quot;(i00,i01),(i10),(),(),(),(i50)-&gt;(o00)&quot;}(RNG(&lt;Generator(PCG64) at 0x1721017E0&gt;), [], x, [-1.609437 ... .51268651], 100, 0.95, 2.0, [])
Toposort 索引：0
输入类型：[RandomGeneratorType, TensorType(int64, shape=(0,)), TensorType(float64, shape=(None, None)), TensorType(float64, shape=(1128,)), TensorType(int8, shape=()), TensorType(float64, shape=()), TensorType(float32, shape=()), TensorType(float64, shape=(0,))]
输入形状：[&#39;无形状&#39;, (0,), (1128, 3), (1128,), (), (), (), (0,)]
输入步幅：[&#39;无步幅&#39;, (0,), (8, 9024), (8,), (), (), (), (0,)]
输入值：[Generator(PCG64) at 0x1721017E0, array([], dtype=int64), &#39;未显示&#39;, &#39;未显示&#39;, array(100, dtype=int8), array(0.95), array(2., dtype=float32), array([], dtype=float64)]
输出客户端：[[output[1](BART_rv{&quot;(i00,i01),(i10),(),(),(),(i50)-&gt;(o00)&quot;}.0)], [Second(mu, [-3.09309984])]]

相关库的版本为：
python 3.10.15
pymc 5.16.2
pymc-bart 0.7.0

以防它与软件包版本之间的行为差​​异有关。]]></description>
      <guid>https://stats.stackexchange.com/questions/656835/pymc-bart-index-error</guid>
      <pubDate>Wed, 06 Nov 2024 14:10:28 GMT</pubDate>
    </item>
    <item>
      <title>“最好的测试是无偏见的”这一说法的证明</title>
      <link>https://stats.stackexchange.com/questions/656832/proof-of-the-statement-the-best-test-is-unbiased</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/656832/proof-of-the-statement-the-best-test-is-unbiased</guid>
      <pubDate>Wed, 06 Nov 2024 12:41:53 GMT</pubDate>
    </item>
    </channel>
</rss>