<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Wed, 11 Sep 2024 21:15:45 GMT</lastBuildDate>
    <item>
      <title>我应该何时应用 Benjamini-Hochberg 与 Benjamini-Yekutieli FDR 校正？</title>
      <link>https://stats.stackexchange.com/questions/654233/when-should-i-apply-benjamini-hochberg-vs-benjamini-yekutieli-fdr-correction</link>
      <description><![CDATA[我几乎没听说过有人使用 BY 程序进行 FDR 校正，BH 更为常见。但是，据我所知，BY 程序对各种依赖结构更稳健，而 BH 假设独立测试。
在大量应用中，相互依赖性是一个非常合理的假设，但作者使用 BH 进行 FDR 校正。有趣的是，BY 似乎比 BH 更严格（产生更高的调整后的 Padj 值）。
对于哪些类型的依赖结构，BH 测试仍然有效？
希望为生物科学家（即非统计学家）提供建议阅读的指针。]]></description>
      <guid>https://stats.stackexchange.com/questions/654233/when-should-i-apply-benjamini-hochberg-vs-benjamini-yekutieli-fdr-correction</guid>
      <pubDate>Wed, 11 Sep 2024 21:13:56 GMT</pubDate>
    </item>
    <item>
      <title>“我们能相信我们计算出的功效值吗？”或者“当零假设为假时，I 类错误是否会立即消失”？</title>
      <link>https://stats.stackexchange.com/questions/654232/can-we-believe-the-power-values-we-compute-or-do-type-i-errors-disappear-as</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/654232/can-we-believe-the-power-values-we-compute-or-do-type-i-errors-disappear-as</guid>
      <pubDate>Wed, 11 Sep 2024 21:05:35 GMT</pubDate>
    </item>
    <item>
      <title>比较回顾性队列和前瞻性队列</title>
      <link>https://stats.stackexchange.com/questions/654231/comparing-retrospective-and-prospective-cohorts</link>
      <description><![CDATA[我对比较回顾性队列和前瞻性队列有点困惑……
假设我有两个队列，一个是回顾性队列（用作对照），另一个是前瞻性队列（应用了程序/干预）。我可以使用常规统计检验（如卡方、CMH 等）来比较两个队列之间的各种特征（例如死亡人数）吗？不太确定我是否需要“特殊”测试……
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/654231/comparing-retrospective-and-prospective-cohorts</guid>
      <pubDate>Wed, 11 Sep 2024 21:02:50 GMT</pubDate>
    </item>
    <item>
      <title>具有多个独立变量和因变量的 Kruskal</title>
      <link>https://stats.stackexchange.com/questions/654226/kruskal-with-multiple-independent-and-dependent-variables</link>
      <description><![CDATA[我有三个独立变量：

延迟 - 4 级序数
难度 - 2 级序数
专业度 - 2 级序数

还有三个因变量：

时间 - 度量
准确度 - 度量
挫败感 - 5 级序数

我考虑根据独立变量将其分为 16 组，然后使用 Kruskal 检验和事后 Dunn 检验对所有组进行比较。我计划以这种方式测试每个因变量。但是，此链接和 CV 上的其他问题表明此过程不准确。
我使用 Kruskal 检验，因为我的数据违反了 ANOVA 模型假设。具体来说，没有给出正态性，并且存在显着的自相关拉格朗日乘数自相关检验（时间和准确度的 p &lt; 10^40）。


我没有检查 DV 挫折的假设，因为结果对我来说看起来太差了。
请告诉我我是否做了一个大数学禁忌，因为我对此并不是 100% 肯定。
我也不确定这里是否需要多变量方法。此帖子中的评论表明，对每个 IV 进行单独的 Kurskal 测试可能是一种更好的方法。但是，我怀疑 IV 之间存在相互作用，我想找到这些相互作用。
我很高兴能得到任何有关适合这种情况的分析技术的提示。
编辑以指定我想要的内容：我不确定所描述的分析是否适合我面临的情况。我查看了多个书籍章节和博客文章，但我无法推广到这种情况。
第二次编辑：方差分析假设。]]></description>
      <guid>https://stats.stackexchange.com/questions/654226/kruskal-with-multiple-independent-and-dependent-variables</guid>
      <pubDate>Wed, 11 Sep 2024 19:31:24 GMT</pubDate>
    </item>
    <item>
      <title>我需要帮助理解贝叶斯线性回归的重要性</title>
      <link>https://stats.stackexchange.com/questions/654224/i-need-help-understanding-importance-of-bayesian-linear-regression</link>
      <description><![CDATA[因此，我正在尝试贝叶斯线性回归。作为新手，我尝试了以下方法：
生成数据的方程式：

$$Y = \phi(X) \cdot W + \epsilon $$其中 $$W \sim \mathcal{N} ( \overline{w} ,\Sigma_w)$$
$$\epsilon \sim \mathcal{N}(\overline{\epsilon}, \Sigma_\epsilon )$$

P(Y,W) 的联合概率：

$$\begin{pmatrix}W \\ Y\end{pmatrix} \sim\mathcal{N}\left(\begin{pmatrix}\overline{w} \\\phi\overline{w} \end{pmatrix}, \begin{pmatrix} \Sigma_W &amp; \Sigma_W\phi^T \\ \phi\Sigma_W &amp; \phi\Sigma_W\phi^T + \Sigma_\epsilon\end{pmatrix}\right)$$

$\mu_{\text{post}}$ 和 $\Sigma_{\text{post}}$，P(W|Y) 的参数由以下公式给出：

$$\mu_{\text{post}} = \overline{w}+ \Sigma_{\text{W}} \phi^T (\phi \Sigma_{\text{W}} \phi^T + \Sigma_\epsilon)^{-1} (Y - \phi \overline{w})$$
$$\Sigma_{\text{post}} = \Sigma_{\text{W}} - \Sigma_{\text{W}} \phi^T (\phi \Sigma_{\text{W}} \phi^T + \Sigma_\epsilon)^{-1} \phi \Sigma_{\text{W}}$$

我观察到，使用此公式生成的 W（P(W|Y) 的平均值）类似于通过设置正则化参数 $\lambda= precision_{\text{prior}}/ 通过 MAP 获得的正则化闭式解precision_{\text{noise}}$。
这很有道理，但我不禁要问，为什么对于更简单的情况，我们需要贝叶斯线性回归。]]></description>
      <guid>https://stats.stackexchange.com/questions/654224/i-need-help-understanding-importance-of-bayesian-linear-regression</guid>
      <pubDate>Wed, 11 Sep 2024 18:53:32 GMT</pubDate>
    </item>
    <item>
      <title>理解互信息作为关系的衡量标准：为什么完全相关的确定性函数的互信息不同？</title>
      <link>https://stats.stackexchange.com/questions/654223/understanding-mutual-information-as-a-measure-of-relationship-why-is-mutual-inf</link>
      <description><![CDATA[有人能解释一下为什么 a1 和 a2 之间的互信息 (MI) 小于 b1 和 b2 之间的 MI 吗？
import numpy as np
from sklearn.metrics import mutual_info_score

a1 = np.array([10, 10, 10, 10, 8, 6, 5, 9, 8, 7])
a2 = np.array([10, 10, 10, 10, 8, 6, 5, 9, 8, 7])

b1 = np.array([0.09780311, 0.02335877, 0.10676231, 0.01144303, 0.03910861, 0.06950386, 0.06038933, 0.12563807, 0.01360671, 0.01319363])
b2 = np.log(b1)

# 计算 a1 和 a2 之间的 MI

mi_a = mutual_info_score(a1, a2)
print(mi_a) # 打印 1.609

# 计算 b1 和 b2 之间的 MI

mi_b = mutual_info_score(b1, b2)
print(mi_b) # 打印 2.303

在这两种情况下，第二个向量（a2 和 b2）都是第一个向量（a1 和 b1）的确定性函数。但是，即使 a1 和 a2 完全相关，mi_a 也小于 mi_b。由于 a2 和 b2 在给定 a1 和 b1 的情况下都是确定性的，因此我预计互信息值至少相同。为什么会出现这种差异？]]></description>
      <guid>https://stats.stackexchange.com/questions/654223/understanding-mutual-information-as-a-measure-of-relationship-why-is-mutual-inf</guid>
      <pubDate>Wed, 11 Sep 2024 18:47:46 GMT</pubDate>
    </item>
    <item>
      <title>Xgboost 回归中的样本权重</title>
      <link>https://stats.stackexchange.com/questions/654221/sample-weights-in-xgboost-regression</link>
      <description><![CDATA[我正在尝试使用 xgboost 的 XGBRegressor 来拟合回归模型，在训练期间，我会对最近的数据进行加权，而不是过去的数据。我想知道 xgboost 的 sample_weight 是如何工作的。
我知道对于基于树的模型，拟合基本上是将数据拆分成各种节点/桶，然后对桶内的观测值取平均值。在这里，我希望对 xgboost 更了解的人可以解释样本权重是如何发挥作用的。我相信在大多数回归中，样本权重只是在拟合过程中计算损失函数时观测值的乘数。如果 xgboost 就是这种情况，那么虽然 sample_weight 会影响算法如何选择分割，但在取每个桶内的平均值时，它仍然会对所有观测值进行相同的加权。有人知道这是真的吗？有没有办法在 xgboost 中指定我想在节点/桶内取平均值时减少某些观测值的权重？]]></description>
      <guid>https://stats.stackexchange.com/questions/654221/sample-weights-in-xgboost-regression</guid>
      <pubDate>Wed, 11 Sep 2024 17:49:42 GMT</pubDate>
    </item>
    <item>
      <title>冷卡归因能解决类别不平衡问题吗？</title>
      <link>https://stats.stackexchange.com/questions/654220/can-cold-deck-imputation-used-to-address-class-imbalance</link>
      <description><![CDATA[如果您有使用冷牌插补解决数据集中的类别不平衡问题的经验，能否分享更多细节或参考文献？
编辑添加：
建模方法是具有一个隐藏层的神经网络。数据不平衡，带有正标签的人口不到 1%。
为了便于理解，下面是 wiki 上对冷牌插补的描述。
热牌
一种曾经常见的插补方法是热牌插补，其中从随机选择的类似记录中插补缺失值。术语“热牌”可以追溯到穿孔卡片上的数据储存，表示信息捐赠者与接收者来自同一数据集。这叠卡片是“热的”，因为它目前正在被处理。
一种热牌插补形式称为“上次观察结转” （或简称为 LOCF），它涉及根据多个变量对数据集进行排序，从而创建有序数据集。然后，该技术找到第一个缺失值，并使用缺失数据之前的单元格值来估算缺失值。对下一个具有缺失值的单元格重复该过程，直到所有缺失值都已估算完毕。在常见情况下，案例是对个人或其他实体的变量进行重复测量，这代表了这样一种信念：如果缺少测量，最好的猜测是它与上次测量时没有变化。众所周知，这种方法会增加增加偏见和可能得出错误结论的风险。因此，不建议使用 LOCF。
冷牌
相比之下，冷牌插补是从另一个数据集中选择捐赠者。由于计算机能力的进步，更复杂的插补方法通常取代了原始的随机和排序的热牌插补技术。这是一种用过去调查中类似项目的响应值进行替换的方法。它适用于测量时间间隔的调查。]]></description>
      <guid>https://stats.stackexchange.com/questions/654220/can-cold-deck-imputation-used-to-address-class-imbalance</guid>
      <pubDate>Wed, 11 Sep 2024 16:59:33 GMT</pubDate>
    </item>
    <item>
      <title>我如何确定我的生态 GLMM 是否构建准确？</title>
      <link>https://stats.stackexchange.com/questions/654219/how-do-i-determine-if-my-ecological-glmm-is-accurately-constructed</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/654219/how-do-i-determine-if-my-ecological-glmm-is-accurately-constructed</guid>
      <pubDate>Wed, 11 Sep 2024 16:42:13 GMT</pubDate>
    </item>
    <item>
      <title>CATE/ITE 估计值是否应该呈正态分布？</title>
      <link>https://stats.stackexchange.com/questions/654218/are-cate-ite-estimates-supposed-to-be-normally-distributed</link>
      <description><![CDATA[我正在做提升建模，并预测一群人的 ITE。当我绘制这些图表时，我应该期望它们呈正态分布吗？我尝试过的一个模型的预测是双峰甚至三峰的，我不确定这是否不应该发生。]]></description>
      <guid>https://stats.stackexchange.com/questions/654218/are-cate-ite-estimates-supposed-to-be-normally-distributed</guid>
      <pubDate>Wed, 11 Sep 2024 16:41:24 GMT</pubDate>
    </item>
    <item>
      <title>对信号随时间变化的方差进行建模</title>
      <link>https://stats.stackexchange.com/questions/654217/modeling-time-varying-variance-of-a-signal</link>
      <description><![CDATA[我有一个信号，其方差随时间变化
通过观察发现，当其他一些变量（我们称之为输入特征）从一个值急剧转变为另一个值时，方差的这些波动就会出现。我真的不知道如何对这个信号进行建模。我曾考虑将其建模为高斯过程 (GP)，其中均值和方差取决于输入变量，但我真的不知道 Python 中有哪些可用于此类“GP”的工具。我知道有 GPy 包，但我没有找到任何文档，其中方差/平均值实际上是作为其他输入变量的函数建模的。
你有什么想法吗？
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/654217/modeling-time-varying-variance-of-a-signal</guid>
      <pubDate>Wed, 11 Sep 2024 16:27:38 GMT</pubDate>
    </item>
    <item>
      <title>非正态方差分析残差</title>
      <link>https://stats.stackexchange.com/questions/654215/non-normal-anova-residuals</link>
      <description><![CDATA[我正在分析一些数据，但遗憾的是，除了这是一次奶牛泌乳试验之外，我无法对此发表太多评论。残差具有非正态分布，Kolmogorov-Smirnov 检验的 p 值为 &lt; 0.0001。
Q-Q 图和直方图如下。Q-Q 图令人担忧，但在调查数据时，我无法确定是否真的存在任何问题。大多数具有负残差的数据点都处于泌乳早期（试验从第 7 天开始）。我认为这只是表明模型对一些泌乳早期数据进行了高估，因为当我查看奶牛的个体泌乳曲线时，我没有看到任何不正常的数据点。这是为客户准备的，我确实需要与他们一起检查数据是否全部正确，但只要数据正确，我认为保留这些数据是合理的。我不喜欢无缘无故地删除数据，方差分析对偏离正态性具有稳健性。总而言之，这不到数据点的 5%，与正态钟形曲线相比，残差的分布看起来根本不令人担忧。
我只是想在这里发帖，看看这是否是调查的合理结论，至少考虑到我能够提供的信息。谢谢。
]]></description>
      <guid>https://stats.stackexchange.com/questions/654215/non-normal-anova-residuals</guid>
      <pubDate>Wed, 11 Sep 2024 15:59:41 GMT</pubDate>
    </item>
    <item>
      <title>离散时间生存模型（输出）</title>
      <link>https://stats.stackexchange.com/questions/654204/discrete-time-survival-model-output</link>
      <description><![CDATA[这两个函数中哪一个更适合离散时间生存分析？假设数据集中有 8 个时间点。输出需要包含时间的单个估计值和每个时间级别的单独估计值？简而言之：我需要将时间或因素（时间）纳入分析吗？
Gompertz_Model_Baseline &lt;- glm(formula = event ~ Time,
family = binomial(link = &quot;cloglog&quot;),
data = Scania_PersonPeriod_Train)

summary(Gompertz_Model_Baseline)

系数：
估计标准差。误差 z 值 Pr(&gt;|z|) 
(截距) -4.168556 0.072451 -57.54 &lt;2e-16 ***
时间 0.072376 0.004185 17.30 &lt;2e-16 ***
---
显著性代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

第二个模型：
Gompertz_Model_Baseline &lt;- glm(formula = event ~ factor(Time),
family = binomial(link = &quot;cloglog&quot;),
data = Scania_PersonPeriod_Train)

summary(Gompertz_Model_Baseline)

系数：
估计标准误差 z 值 Pr(&gt;|z|) 
(截距) -4.0762 0.1961 -20.784 &lt; 2e-16 ***
因子（时间）2 0.2717 0.2640 1.029 0.303511 
因子（时间）3 -0.1942 0.3018 -0.643 0.519926 
因子（时间）4 0.1789 0.2774 0.645 0.518810 
因子（时间）5 0.3349 0.2701 1.240 0.214988 
因子（时间）6 0.3844 0.2701 1.423 0.154699 
因子（时间）7 0.3722 0.2748 1.355 0.175537 

]]></description>
      <guid>https://stats.stackexchange.com/questions/654204/discrete-time-survival-model-output</guid>
      <pubDate>Wed, 11 Sep 2024 12:00:28 GMT</pubDate>
    </item>
    <item>
      <title>使用候补名单控制设计的干预研究的适当回归分析</title>
      <link>https://stats.stackexchange.com/questions/654200/appropriate-regression-analysis-for-intervention-study-using-waiting-list-contro</link>
      <description><![CDATA[考虑一个具有以下设计的随机试验：在基线测量（$T_0$）后，受试者被随机分为对照组（$G_0$）和干预组（$G_1$）。干预组接受治疗，而对照组则在候补名单上（未接受治疗）。在$T_1$，对两个组进行评估。在第二个时期，候补名单上的对照组现在接受治疗，并在$T_2$再次接受评估。干预组不参与第 2 阶段。下图说明了该设计：

我想回答以下问题（在图中用相应数字标记）：

比较两组在 $T_1$ 时的均值。
比较对照组在 $T_2$ 时的均值与干预组在 $T_1$ 时的均值。
比较对照组在 $T_2$ 时的均值与干预组在 $T_1$ 时的均值。 class=&quot;math-container&quot;&gt;$T_2$ 与 $T_1$（组内）的回归模型。

Q1：您认为哪种回归模型最适合回答这些问题？
由于重复测量的性质，我想到了一种混合模型，形式如下：
$$
y = (\beta_0 + b_0) + \beta_1T_1 + \beta_2T_2G_0+ \beta_3T_1G_1
$$
其中 $T_1$ 和 $T_2$ 是时间点的指标，$G_0$ 和 $G_1$ 是对照组和干预组的指标，$b_0$ 是随机截距。该模型强制在 $T_0$ 处拟合均值对于两个组相同，这在设计上是合理的（随机化发生在第一次测量之后）。
如果我的推理正确，那么我的三个问题可以通过以下系数或对比测试来回答：

$\beta_3 = 0$
$\beta_1 + \beta_3 -\beta_2 = 0$
$\beta_1 - \beta_2 = 0$

我进行了一些模拟，似乎证实了我的想法（如果有兴趣，我可以发布代码），但我想知道是否有更简单的方法来参数化问题。
问题 2：这听起来合理吗？或者有没有更简单的参数化方法？]]></description>
      <guid>https://stats.stackexchange.com/questions/654200/appropriate-regression-analysis-for-intervention-study-using-waiting-list-contro</guid>
      <pubDate>Wed, 11 Sep 2024 11:23:42 GMT</pubDate>
    </item>
    <item>
      <title>参数函数的充分统计量</title>
      <link>https://stats.stackexchange.com/questions/654163/sufficient-statistic-of-a-function-of-the-parameter</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/654163/sufficient-statistic-of-a-function-of-the-parameter</guid>
      <pubDate>Tue, 10 Sep 2024 15:55:46 GMT</pubDate>
    </item>
    </channel>
</rss>