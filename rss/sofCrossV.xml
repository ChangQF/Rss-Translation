<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Wed, 09 Oct 2024 06:25:03 GMT</lastBuildDate>
    <item>
      <title>规范化计数数据的最佳实践</title>
      <link>https://stats.stackexchange.com/questions/655511/best-practice-for-normalizing-count-data</link>
      <description><![CDATA[在规范化数据计数方面，最佳做法是什么？我觉得对数据的解释最能表达数据结构和我想要规范化的内容。
我有一个基本函数，它将生成 10,000 个值
def output_vector()
ran_array = np.rand.random(100)
return ran_array

我所做的是计算有多少个值高于截止值（假设为 0.5）。然后计算这个数字，并重复该过程 x 次。这将产生一个计数数据框，其范围从 0 到返回向量的长度。
0 1 2 3 4 ... n
35 38 32 28 23 ... m 

我使用这些数据的目的是查看生成的计数是否导致正态分布。但是，由于数据最终可能会偏向 0，因此我觉得在执行任何偏度测试之前，我应该先对数据进行标准化。
由于这种数据不是连续的，是否可以对这种类型的数据进行标准化？]]></description>
      <guid>https://stats.stackexchange.com/questions/655511/best-practice-for-normalizing-count-data</guid>
      <pubDate>Wed, 09 Oct 2024 04:47:15 GMT</pubDate>
    </item>
    <item>
      <title>余弦相似度对连续变量的有用性</title>
      <link>https://stats.stackexchange.com/questions/655510/cosine-similarity-usefulness-for-continuous-variables</link>
      <description><![CDATA[有人要求我识别与产品 A 相似的“同类”产品，有人建议我识别一组相关特征并计算每个可能相似的产品与产品 A 之间的余弦相似度。我将使用的特征主要是数字，尽管我也会包含一些离散变量。
这引出了一个关于余弦相似度何时有用的一般问题。例如，如果我有两个向量：
p1 = [10, 20, 40]

p2 = [1000, 2000, 4000]

在这种情况下，cosine_sim(p1, p2) = 1。
但是，如果虽然向量彼此成比例，但每个向量值的幅度差异是有意义的，该怎么办？例如，如果我考虑的特征之一是产品 A 和产品 B 的平均产品增长加速度，那么 10% 和 1000% 的加速度是有显著差异的。对于离散值，我更了解为什么这种度量有意义，但很难理解它对连续变量的用处。
我应该使用不同的相似性度量吗？我的想法正确吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655510/cosine-similarity-usefulness-for-continuous-variables</guid>
      <pubDate>Wed, 09 Oct 2024 03:36:30 GMT</pubDate>
    </item>
    <item>
      <title>我们可以在受限似然函数上使用费舍尔评分吗？</title>
      <link>https://stats.stackexchange.com/questions/655508/can-we-use-fisher-scoring-on-a-restricted-likelihood-function</link>
      <description><![CDATA[我有一个关于如何在混合效应回归模型中优化 RMLE 的问题。
从混合效应模型开始：
$$y = X\beta + Zu + e$$
$$u \sim N(0, G), \quad e \sim N(0, R)$$
其中：

$y$ 是 $n \times 1$ 观测向量
$X$ 是 $n \times p$ 固定效应设计矩阵
$\beta$ 是 $p \times 1$ 固定效应向量
$Z$ 是 $n \times q$ 随机效应设计矩阵
$u$ 是 $q \times 1$ 随机效应向量
$e$ 是 $n \times 1$ 残差向量

$y$ 的边际分布为（其中 $V = ZGZ^T + R$):
$$y \sim N(X\beta, V)$$
如果我们定义 $K = I - X(X^TX)^{-1}X^T$ 和 $y^* = Ky$。 $y^*$ 的分布为：
$$y^* \sim N(0, KVK^T)$$
$y^*$ 的对数似然为（注意：RMLE 中没有固定效应项，只有混合效应项，即方差）：
$$\begin{align*}
L(\theta) &amp;= -\frac{1}{2}\log|KVK^T| - \frac{1}{2}y^{*T}(KVK^T)^{-1}y^* \\
&amp;= -\frac{1}{2}\log|KVK^T| - \frac{1}{2}y^TK^T(KVK^T)^{-1}Ky
\end{align*}$$
再进行一些代数运算，我们得到 RMLE 对数似然的最终形式：
$$L(\theta) = -\frac{1}{2}\log|V| - \frac{1}{2}\log|X^TV^{-1}X| - \frac{1}{2}y^TPy + \text{constant}$$
我们通常如何优化上述 RMLE？我认为可以使用一些拟牛顿技术（例如 BFGS），但我想知道是否仍然可以计算 RMLE 的预期 Fisher 信息并在此使用 Fisher 评分，或者只是使用实际的 hessian 执行类似迭代重加权最小二乘的操作？]]></description>
      <guid>https://stats.stackexchange.com/questions/655508/can-we-use-fisher-scoring-on-a-restricted-likelihood-function</guid>
      <pubDate>Wed, 09 Oct 2024 02:40:14 GMT</pubDate>
    </item>
    <item>
      <title>为什么简单回归中的最小二乘估计量的方差取决于预测变量？</title>
      <link>https://stats.stackexchange.com/questions/655507/why-variance-of-least-square-estimator-in-simple-regression-is-conditional-on-pr</link>
      <description><![CDATA[我是统计学新手，现在正在阅读 Sanford Weisberg 的《应用线性回归》一书。我可能问了一个无意义的问题，但为什么简单回归中的最小二乘估计量$\hat{\beta_0}$和$\hat{\beta_1}$的方差是$Var(\hat{\beta_0} |X)$和$Var(\hat{\beta_1} |X)$，而不是$Var(\hat{\beta_0})$和$Var(\hat{\beta_0})$？
假设我们有随机变量$X$和$Y$；并且我们有实现$x_i$和$y_i$。我使用样本预测器$\mathbf{x} = (x_1,x_2,...x_n)$和响应$\mathbf{y} = (y_1,y_2,...y_n)$估计了这些参数$\beta_0$和$\beta_1$。因此，我认为 $\hat{\beta_0}$ 和 $\hat{\beta_1}$ 的变异性应该来自于从 $X$ 中抽样加上以 $X$ 为条件的 $Y$ 的随机误差。然而，使用$Var(\hat{\beta_0} |X)$和$Var(\hat{\beta_1} |X)$表明变异性仅来自$Y$的随机误差。
同样的问题也出现在估计量$\hat{\beta_0}$和$\hat{\beta_1}$的无偏性的证明上。本书证明了$E(\hat{\beta_0}|X)=\hat{\beta_0}$和$E(\hat{\beta_1}|X)=\hat{\beta_1}$，但我认为目标应该是$E(\hat{\beta_0})$和$E(\hat{\beta_1})$。]]></description>
      <guid>https://stats.stackexchange.com/questions/655507/why-variance-of-least-square-estimator-in-simple-regression-is-conditional-on-pr</guid>
      <pubDate>Wed, 09 Oct 2024 02:24:46 GMT</pubDate>
    </item>
    <item>
      <title>我们如何阻止贝叶斯估计过度自信？</title>
      <link>https://stats.stackexchange.com/questions/655504/how-do-we-stop-bayesian-estimates-from-being-overconfident</link>
      <description><![CDATA[我今天发布了一个关于小样本回归策略的问题。我认为贝叶斯回归可能是一个不错的选择：用于校正小样本的贝叶斯回归
有一件事我很好奇，我读到贝叶斯推理的优势在于它可以防止在我们对数据没有信心或样本量较小的情况下估计值出现非常大的方差。在这种情况下，与数据相比，估计值可以向先验收缩，从而与非贝叶斯方法相比，降低了参数估计值的方差。
我只是想知道，我们如何防止/我们如何知道贝叶斯方差的减少不是明显低估方差？在我看来，唯一要做的就是选择一个非常大的先验（例如非信息先验）来反映我们的不确定性，然而这样做似乎会将方差拉回到非贝叶斯方向。除此之外，听起来没有免费的午餐，而且贝叶斯推理只有在你真正对自己的先验选择有信心的情况下才有优势？]]></description>
      <guid>https://stats.stackexchange.com/questions/655504/how-do-we-stop-bayesian-estimates-from-being-overconfident</guid>
      <pubDate>Wed, 09 Oct 2024 01:10:00 GMT</pubDate>
    </item>
    <item>
      <title>如何实现和记录二维矩阵到三维张量的复制/变换以及三维张量到二维矩阵的求和/变换？</title>
      <link>https://stats.stackexchange.com/questions/655503/how-to-implement-and-notate-the-replication-transformation-of-a-2d-matrix-to-a-3</link>
      <description><![CDATA[背景：
我有一个模型，其维度为 $T$，代表 $time$；维度为 $N$，代表 $technologies$；维度为 $P$，代表 $prices$。在此模型中进行计算时，我想添加 $T$ 维度（为每个时间步骤复制数据），并删除 $N$ 维度（总和 N）。
我必须在 numpy 中实现此模型，并以数学方式记录它。我如何

实现并记录 2D 矩阵到 3D 张量的复制/转换？
实现并记录 3D 张量到 2D 矩阵的求和/转换？

一方面，符号应使用尽可能接近使用的 numpy 操作的数学运算符/操作，但也要保持数学文档的正确性，让没有数学学位的用户（比如我）也能读懂。另一方面，使用的 numpy 操作应该可以用数学运算符/概念来表达。
有时不同的数学运算似乎具有相同的数学符号。在其他情况下，在我看来，一个数学运算可以用不同的运算符表示，在某些情况下，一个数学运算似乎有许多可能的 numpy 实现。
如果没有正确或错误的答案，我会对意见、惯例或最佳实践感兴趣。我不确定这是否更适合 stack exchange 数学、stackoverflow 或此平台。

复制维度
从 1D 到 2D：我有一个行向量 $A \in \mathbb{R}^{1 \times P}$。现在，我想将此向量复制到矩阵 $C \in \mathbb{R}^{N \times P}$，例如，每种技术应该具有相同的价格。我考虑过用一个向量来表示这个克罗内克积：
$C^{N \times P} = 1^{N \times 1} \otimes A^{1 \times P}$
C_NxP = np.kron(one_Nx1, A_1xP)

从 2 D 到 3D：现在，我想将这个 $C^{N \times P}$ 矩阵转换为 $D \in \mathbb{R}^{T \times N \times P}$ 张量，例如，每个时间步骤都具有相同的技术和价格。我考虑将其表示为张量积，其符号似乎与克罗内克积相同
$D^{T \times N \times P} = 1^{T \times 1} \otimes C^{N \times P}$
D_Tx1xNxP = np.tensordot(One_Tx1, C_NxP, axis=0) # 错误：返回 Tx1xNxP

但如果 $1^{T \times 1}$ 是实际的 numpy 列向量（形状为 Tx1），则相应的 numpy 操作将返回错误的形状，并且我更希望不要明确地将 2D numpy 向量重塑为 1D numpy 向量。但是，使用 np.einsum 可以工作：
D_TxNxP = np.einsum(&#39;io,jk-&gt;ijk&#39;, One_Tx1, C_NxP)

因此，将其表示为 $T_{ijk} = D_{i1} \cdot C_{jk}$ 是否更好？这里的 Tensorproduct 和 Einstein sum 是否相同？如果是，我可以将其表示为 Tensorproduct 吗？

求和/减少维度：
从 2D 到 1D：我有 $G \in \mathbb{R}^{T \times N}$，我想按时间步长对技术求和。我认为将其表示为矩阵乘法：
$E^{T \times 1} = C^{T \times N} * 1^{N \times 1}$
E_Tx1 = G_TxN @ 1_Nx1

从 3D 到 2D：现在，我想将其应用于张量 $D \in \mathbb{R}^{T \times N \times P}$ 并求和每个价格水平 p 的技术值，例如求和“内部”矩阵 ${N \times P}$ 维度为 N。看来爱因斯坦求和约定又起作用了。
$M_{tp} = B_{tnp} \, C_n$
M_TxP = np.einsum(&#39;tnp,n-&gt;tp&#39;, B_TxNxP, C_Nx1) 

但据我所知，我也可以将其表示为 n 模乘积，这对我来说看起来更具可读性：
$M^{T \times P} = B^{T \times N \times P} \times_{\!N}\, C^{N \times 1}$
这样对吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655503/how-to-implement-and-notate-the-replication-transformation-of-a-2d-matrix-to-a-3</guid>
      <pubDate>Wed, 09 Oct 2024 00:58:41 GMT</pubDate>
    </item>
    <item>
      <title>2024 年诺贝尔物理学奖获奖声明不正确吗？</title>
      <link>https://stats.stackexchange.com/questions/655502/is-the-nobel-prize-in-physics-2024-statement-of-merit-incorrect</link>
      <description><![CDATA[今天，诺贝尔基金会宣布 2024 年诺贝尔物理学奖，获奖理由如下：

表彰那些使机器学习和人工神经网络成为可能的基础性发现和发明

我的问题是：J. Hopfield 和 G. E. Hinton 的工作是否真的使机器学习和人工神经网络成为可能？
（最初发表于 AI，经修改）]]></description>
      <guid>https://stats.stackexchange.com/questions/655502/is-the-nobel-prize-in-physics-2024-statement-of-merit-incorrect</guid>
      <pubDate>Wed, 09 Oct 2024 00:53:52 GMT</pubDate>
    </item>
    <item>
      <title>马尔可夫状态 GBM 的最大似然</title>
      <link>https://stats.stackexchange.com/questions/655501/max-likelihood-of-gbm-with-markov-state</link>
      <description><![CDATA[考虑随机过程
$$dX_t = \mu_{\epsilon_t}X_tdt + \sigma_{\epsilon_t}X_tdW_t$$
其中$W_t$是标准布朗运动。过程$X_t$是几何布朗运动，其均值和方差取决于具有状态空间$\{H,L\}$的独立两状态马尔可夫链。因此，我们有四个参数

$\mu_H$：状态 $H$ 的平均漂移
$\mu_H$：状态 $L$ 的平均漂移
$\sigma_H$：状态 $H$ 的标准差
$\sigma_L$：状态 $L$ 的标准差

马尔可夫过程有自己的转移矩阵：

$p_H$ 是从状态 $L$ 跳转到状态 $H$ 的条件概率

$p_L$ 是从状态 $H$ 跳转到状态 $L$ 的条件概率


总体而言，该模型有六个参数。请注意，马尔可夫过程并非隐藏的，并且假定是可观察的。

问题：如果 $X_t$ 是具有对数正态分布的标准几何布朗运动，我可以根据 $X_t$ 的实现时间序列，找到 $\mu$ 和 $\sigma$ 的简单最大似然估计量。但在更一般的设置中该怎么做？具有状态切换的 $X_t$ 是否也具有已知的 MLE？]]></description>
      <guid>https://stats.stackexchange.com/questions/655501/max-likelihood-of-gbm-with-markov-state</guid>
      <pubDate>Wed, 09 Oct 2024 00:24:00 GMT</pubDate>
    </item>
    <item>
      <title>统计方法分析不同类型医院 PCI 中复杂程度不同的手术量-结果关系</title>
      <link>https://stats.stackexchange.com/questions/655500/statistical-approach-for-analyzing-volume-outcome-relationship-in-pci-with-varyi</link>
      <description><![CDATA[我正在开展一项研究，以评估 PCI（经皮冠状动脉介入治疗）中的数量-结果关系。我有一个数据集，其中包含以下详细信息：
操作员特征，包括：
终生 PCI 经验（每个操作员执行的程序总数）。
自第一次 STEMI 程序以来的年数。
医院类型：每个操作员是在大学医院还是非大学医院工作。
医院 PCI 数量：每家医院的总体 PCI 数量。
从以前的研究中，我知道 30 天死亡率通常用作数量-结果分析的主要结果，但我也有关于其他患者结果的数据，如出血并发症等。
问题是大学医院往往处理更复杂的病例，这可能导致与非大学医院相比，每个操作员的 PCI 数量较低。
另一方面，非大学医院通常处理大量 PCI 手术，但通常处理的病例不太复杂。
评估这种数量-结果关系的最佳统计模型是什么？具体来说：
我如何解释大学医院的操作员可能由于病例复杂性较高而导致 PCI 数量较低，而非大学医院的 PCI 数量可能较高但病例不太复杂这一事实？
我是否应该使用具有医院和操作员随机效应的多变量混合效应逻辑回归模型来解释这种聚类，或者是否有其他方法可能更适合这些数据？
任何关于如何建模的建议或类似分析的例子，将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/655500/statistical-approach-for-analyzing-volume-outcome-relationship-in-pci-with-varyi</guid>
      <pubDate>Tue, 08 Oct 2024 22:51:05 GMT</pubDate>
    </item>
    <item>
      <title>newey-west 错误的具体滞后</title>
      <link>https://stats.stackexchange.com/questions/655499/specific-lag-for-newey-west-errors</link>
      <description><![CDATA[
我目前正在进行一个关于股票收益的研究项目，但我真的不知道该如何进行。我已经在 STATA 上生成了残差的相关图，以了解自相关结构，如图所示。但我真的不知道如何在这种情况下应用 newey-west 误差，因为它要求我为回归指定特定的截断滞后，而自相关结构到处都是。我真的不确定 newey-west 经验法则 q=4(T/100)^2/9 是否合适或应该在这里使用，或者是否应该指定另一个滞后长度。如果有人能帮助我，我将不胜感激。谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/655499/specific-lag-for-newey-west-errors</guid>
      <pubDate>Tue, 08 Oct 2024 22:36:33 GMT</pubDate>
    </item>
    <item>
      <title>如何根据似然比检验构建置信区域？</title>
      <link>https://stats.stackexchange.com/questions/655496/how-to-construct-confidence-regions-based-on-the-likelihood-ratio-test</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/655496/how-to-construct-confidence-regions-based-on-the-likelihood-ratio-test</guid>
      <pubDate>Tue, 08 Oct 2024 21:42:33 GMT</pubDate>
    </item>
    <item>
      <title>具有重复列的岭回归实际上会将系数减半吗？</title>
      <link>https://stats.stackexchange.com/questions/655495/does-ridge-regression-with-a-duplicate-column-actually-halve-the-coefficient</link>
      <description><![CDATA[以下摘录自 Trevor Hastie 的《岭正则化：数据科学中的基本概念》。

如何实际证明这一点？这似乎取决于理解在复制一列时奇异值和右奇异向量如何变化，但似乎并不清楚这些变化究竟是如何变化的（例如，https://math.stackexchange.com/questions/244399/how-does-the-left-singular-value-decomposition-change-when-one-duplicates-a-colu）]]></description>
      <guid>https://stats.stackexchange.com/questions/655495/does-ridge-regression-with-a-duplicate-column-actually-halve-the-coefficient</guid>
      <pubDate>Tue, 08 Oct 2024 21:24:12 GMT</pubDate>
    </item>
    <item>
      <title>重复测量多元方差分析在这里合适吗？</title>
      <link>https://stats.stackexchange.com/questions/655494/is-repeated-measure-manova-appropriate-here</link>
      <description><![CDATA[我有 2020 年至 2022 年患者每年就诊次数的数据，以及与这些就诊相关的特征。每次就诊时，患者都会被问及吸烟状况（过去 3 个月内是否吸过烟 - 是/否）和饮酒状况（过去 3 个月内是否喝过酒 - 是/否）。此外，我还掌握了每位患者年龄组（&lt;20、20-24、25-29、30-39、40-49、50-59、60+）和性别（男/女）的信息。
我想调查不同年龄组的平均就诊次数是否随时间而变化。为此，我按年份汇总了每位患者的数据，包括就诊次数以及这些就诊期间报告的吸烟和饮酒流行率。例如，如果一名患者在 2020 年就诊 5 次，其中 3 次报告吸烟，则其 2020 年的吸烟率将为 3/5 (60%)。
数据设置如下：



患者
年龄组
性别
2020 年就诊次数
2020 年吸烟率
2020 年饮酒率
2021 年就诊次数
2021 年吸烟率
2021 年饮酒率
2022 年就诊次数
2022 年吸烟
2022 %饮酒




1
25-29
男性
5
0.60
0.80
2
0.50
1.0
3
0.667
1.0


2
30-39
女性
1
0.0
1. 0
0
0.0
0.0
0
0.0
0.0


3
50-59
男性
0
0.0
0.0
1
0.0
0.0
3
0.0
0.33



使用这个数据集，我感兴趣的是研究不同年龄组每年平均就诊次数随时间的变化情况，同时控制吸烟和饮酒行为。
RM MANCOVA 是否是分析这些数据的合适方法？]]></description>
      <guid>https://stats.stackexchange.com/questions/655494/is-repeated-measure-manova-appropriate-here</guid>
      <pubDate>Tue, 08 Oct 2024 21:09:53 GMT</pubDate>
    </item>
    <item>
      <title>两个离散变量和连续变量之间的相互信息</title>
      <link>https://stats.stackexchange.com/questions/655493/mutual-information-between-two-discrete-and-a-continuous-variables</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/655493/mutual-information-between-two-discrete-and-a-continuous-variables</guid>
      <pubDate>Tue, 08 Oct 2024 20:33:06 GMT</pubDate>
    </item>
    <item>
      <title>在 10 个样本中，从 21 个列表中选择少于 4 个唯一数字的概率（有放回）</title>
      <link>https://stats.stackexchange.com/questions/655485/probability-of-selecting-less-than-4-unique-numbers-from-a-list-of-21-in-10-samp</link>
      <description><![CDATA[我有一份包含 21 个数字的列表，编号为 0 到 20（或 1 到 21，无所谓）。我随机挑选 10 次，每次都使该选择可用于下一次选择。这 10 次选择中唯一数字少于 4 个的概率是多少？
我用一个我认为正确的公式来解决组合问题，但是当我在电子表格上模拟该过程时，我得到了一个非常不同的结果：请问​​正确的公式是什么？以下是我对如何获得公式和模拟结果的解释。
选择少于 4 个唯一数字的概率是始终选择相同数字的概率 + 选择 2 个不同数字的概率 + 选择 3 个不同数字的概率。
$$P(&lt;4) = P(1) + P(2) +P(3)$$
我第一次从 10 个数字中挑选出一个独特的数字。第二次挑选时，我可以选择相同的数字，概率为 $\frac1{21}$，也可以选择不同的数字，概率为 $\frac{20}{21}$。在第一次选择之后的 9 次选择中始终选择相同数字的概率为
$$P(1) = \left(\frac1{21}\right)^9$$
在第二次选择之后，我选择了一个与第一次不同的数字，然后我还有第三次选择，我可以选择前 2 个数字中的一个，概率为 $\frac2{21}$，或者选择第三个不同的数字，概率为 $\frac{19}{21}$。在前 2 个数字之后，我在剩余的 8 次选择中继续选择相同的 2 个数字的概率为
$(\frac{2}{21})^8$，因此
$$P(2) = \frac{20}{21}\left(\frac{2}{21}\right)^8$$
继续同样的思路，在第 4 次选择时，我可以选择之前选择的 3 个数字之一，概率为 $\frac3{21}$，或者选择第 4 个不同的数字，概率为 $\frac{18}{21}$。在前 3 个数字之后，我在剩余的 7 次选择中继续选择相同的 3 个数字的概率为
$(\frac{3}{21})^7$，因此
$$P(3) = \frac{20}{21}\frac{19}{21}\left(\frac3{21}\right)^7$$
将三项相加
$$P(&lt;4) = \left(\frac1{21}\right)^9 + \frac{20}{21}\left[\left(\frac{2}{21}\right)^8 + \frac{19}{21}\left(\frac3{21}\right)^7\right] = $$
这给了我大约 $P(&lt;4) = 0.00011\%$
当我尝试通过在 Google 表格中模拟该过程来验证结果时，我无法模拟足够的试验进行计算；上面的概率意味着大约 909,000 次试验的平均值是 1，但我发现 Google 表格允许我模拟大约 47,500 次试验。因此，我将问题从 10 次选择缩减为 8 次选择，通过归纳法获得
$$P(&lt;4) = \left(\frac1{21}\right)^7 + \frac{20}{21}\left[\left(\frac{2}{21}\right)^6 + \frac{19}{21}\left(\frac3{21}\right)^5\right] = 0.0052\%$$
但是当我模拟它时，我得到 $P(&lt;4) = 0.016\%$
我用来模拟上述结果的 Google Sheets 公式是
=countif( byrow( map(RANDarray(55000, 8), lambda(x, int(x*21))), lambda(trial,COUNTUNIQUE(trial)) ), &quot;&lt;4&quot;) / 55000
]]></description>
      <guid>https://stats.stackexchange.com/questions/655485/probability-of-selecting-less-than-4-unique-numbers-from-a-list-of-21-in-10-samp</guid>
      <pubDate>Tue, 08 Oct 2024 18:49:31 GMT</pubDate>
    </item>
    </channel>
</rss>