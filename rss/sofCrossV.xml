<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Tue, 01 Oct 2024 09:19:34 GMT</lastBuildDate>
    <item>
      <title>如何计算和比较不同规模群体之间相互作用的风险</title>
      <link>https://stats.stackexchange.com/questions/655157/how-to-calculate-and-compare-risks-of-an-interaction-between-groups-of-different</link>
      <description><![CDATA[我需要计算并比较三个不同规模年龄组内及之间的病毒传播风险：儿童（0-19，N= 20,000）、成人（20-65，N= 60,000）和老年人（66+，N=20,000）。
儿童感染儿童（n=2000）的风险为 10%；儿童感染成人（n=4000）的风险为 20%；儿童感染老年人（n=2000）的风险为 10%。
但这些风险可以相对比较吗：相对于儿童感染其他儿童的风险，儿童感染成人的风险高出 2 倍，感染老年人的风险相同。显然，成年人口是感染目标的 3 倍，这是相关的，但在本次比较中没有考虑。
成年人被儿童感染的风险（n=4000）为 6.67%；成年人被另一个成年人感染的风险（n=6000）为 10%，被老年人感染的风险（n=2000）为 5%。
我不确定是否可以简单地从两个角度呈现风险，并澄清相对风险不考虑互动一方的人口规模；或者将目标人群纳入风险计算。也许还有其他方法？]]></description>
      <guid>https://stats.stackexchange.com/questions/655157/how-to-calculate-and-compare-risks-of-an-interaction-between-groups-of-different</guid>
      <pubDate>Tue, 01 Oct 2024 08:17:42 GMT</pubDate>
    </item>
    <item>
      <title>使用稳定性选择进行预测来定义共识特征集的最佳方法</title>
      <link>https://stats.stackexchange.com/questions/655156/best-approach-to-define-consensus-set-of-features-using-stability-selection-for</link>
      <description><![CDATA[我尝试构建一个机器学习程序，基于大量高度相关的特征（约 7000 个特征）来预测连续变量。我正在使用 LASSO 回归的稳定性选择程序来找到确保方法泛化的稳定特征集。由于我想避免任何类型的过度拟合（数据泄漏），我的第一个猜测是使用嵌套交叉验证，在外循环和内循环中使用 5 倍。但我仍然不确定如何正确执行分析，因为每个循环都会导致不同的特征选择集。以下是我目前的想法和已经实现的内容：

使用 5 倍 CV（外循环）拆分我的数据
对于 (1) 中生成的每个折叠，我生成一个 5 倍嵌套 CV（内循环）
在内循环中执行稳定性选择，产生一组稳定的特征，在验证集中测试模型性能。对于每个内层折叠，我都会获得一组至少出现在稳定性选择所需的 X% 重采样迭代中的特征。使用具有相应稳定特征的线性回归评估每个内层循环的性能。这里可以考虑其他方法，例如随机森林或非线性模型。
然后，我使用来自内层循环的特征的并集拟合线性回归，评估外部 CV 中剩余折叠的 RSME
对外层循环中的每个折叠重复 (3)-(4)，将产生 5 组特征和相应的性能指标
使用来自每个外层折叠的一致特征或使用某些阈值标准来拟合完整数据集的最终模型

我的问题是：我选择特征的嵌入式过程是否合法？我的意思是结合 LASSO 上的稳定性选择来拟合仅具有有限数量特征的线性回归是否正确？是不是正确的做法，避免最后出现过拟合？
欢迎提出意见和建议]]></description>
      <guid>https://stats.stackexchange.com/questions/655156/best-approach-to-define-consensus-set-of-features-using-stability-selection-for</guid>
      <pubDate>Tue, 01 Oct 2024 08:07:42 GMT</pubDate>
    </item>
    <item>
      <title>交互中的先验契约矩阵与分析</title>
      <link>https://stats.stackexchange.com/questions/655155/matrix-and-analysis-of-a-priori-contrats-in-an-interaction</link>
      <description><![CDATA[我被一个问题困扰了好几天，虽然我在论坛上搜索过，但还是找不到解决方案。我有以下类似的数据集
blocks &lt;- rep(1:3, each = 17) 
treatments &lt;- rep(c(rep(&quot;A&quot;, 3), rep(&quot;B&quot;, 3), rep(&quot;C&quot;, 4), rep(&quot;D&quot;, 3), rep(&quot;E&quot;, 4)), times = 3)
Y &lt;- runif(51, min = 0, max = 1)
data &lt;- data.frame(Y = Y, Block = factor(blocks), Treatments = factor(treatments))
table(data$Block,data$Treatments)

我正在使用以下模型测试块内和块之间的治疗是否具有统计差异：
glmmTMB(y=block*treatments, family=beta_family(link=&quot;logit&quot;), data=data)

但是，我对区块内和区块间所有治疗的比较不感兴趣，但我有精确的假设需要检验：
每个区块内：
治疗 B vs. C vs. E，A vs. B，C vs. D
区块间
治疗 A、B、C、E（即区块 1 中的 A vs 区块 2 中的 A vs 区块 3 中的 A）。
为了进行明确的测试，我尝试应用“先验对比”。我为治疗形成了一个矩阵，定义如下：
C vs E&lt;-c(0,0,-1,0,1)
B vs E&lt;-c(0,-1,0,0,1) # C vs B 应隐式
A vs B &lt;-c(1,-1,0,0,0)
C vs D &lt;- c(0,0,1,-1,0)
contrs &lt;- cbind(C vs E, B vs E, A vs B, C vs D)
contrasts(data$treatment) &lt;- contrs

此时我陷入了困境。我无法弄清楚如何为 Block 制定矩阵来执行交互并获得我感兴趣的对比。我发现可以通过进行后验对比来使用 emmeans 包，但我认为有必要进行成对比较，然后从 emmeans 摘要中选择我感兴趣的对比，但我想避免这样做，因为我读到这不是一个正确的做法，当我定义了研究问题时。
我想问一下，使用“先验”对比的想法是否正确，或者我是否完全错了，如果我正确设置了对比，以及如何获得我感兴趣的对比之间的统计差异。
谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/655155/matrix-and-analysis-of-a-priori-contrats-in-an-interaction</guid>
      <pubDate>Tue, 01 Oct 2024 08:04:43 GMT</pubDate>
    </item>
    <item>
      <title>条件概率分布的建模方法，应用于 IPW 的倾向得分估计（因果推断）</title>
      <link>https://stats.stackexchange.com/questions/655154/modeling-approaches-for-conditional-probability-distribution-applied-to-propens</link>
      <description><![CDATA[我正在尝试理解并理想地实施逆概率加权方法来估计因果关系。到目前为止，我的资源是 Pearl 的 Primer 和书籍“如果？”。
对于二元处理，似乎一种常见的方法是简单的逻辑回归。对于非二元处理，我不太确定。可以使用线性模型或 GAM 来模拟 $$W^A=\frac{1}{f(A|Y)}.$$ 中的条件分布
然而，这似乎对模型的选择很敏感。对我来说，使用机器学习或神经网络来获得这些权重似乎非常有吸引力。目前，我真的不知道如何使用任何因果推理包或它们如何工作。对条件分布进行建模比使用机器学习对条件期望进行通常的建模要困难一些，但我已尝试研究现有的方法。似乎可以使用分位数回归，只需修改损失函数，然后计算分位数网格即可。我还听说过其他方法，如 VAE、正则化流或贝叶斯神经网络（我对后两者的工作原理一无所知）。
您将如何解决这个问题？哪种方法可行？当前的统计软件做了什么？我还希望得到有关 R/python 是否更适合使用统计库的建议。目前，我一直在尝试用 Python 实现一些理论，但这个领域很大，我有点迷茫。
非常感谢您的任何回答。]]></description>
      <guid>https://stats.stackexchange.com/questions/655154/modeling-approaches-for-conditional-probability-distribution-applied-to-propens</guid>
      <pubDate>Tue, 01 Oct 2024 07:47:46 GMT</pubDate>
    </item>
    <item>
      <title>与统计模型对比的代数符号</title>
      <link>https://stats.stackexchange.com/questions/655153/algebraic-notation-for-contrasts-from-statistical-model</link>
      <description><![CDATA[在事前事后研究中，我们可以使用线性混合模型将治疗效果估计为时间 x 治疗相互作用的系数，请参见此处（第 19.3 节）：
https://www.middleprofessor.com/files/applied-biostatistics_bookdown/_book/models-for-longitudinal-experiments-pre-post-designs.html
假设我们使用回归样条将此模型扩展到几个后续时期和模型时间。这些系数将无法解释，但我们可以计算每次后续测量时的一系列条件/边际对比，以估计治疗效果，即预测值之间的差异。我正在考虑使用事后估计工具（例如 R 中的包 emmeans、marginaleffects、rms 等）可以获得的对比类型。但是，我不知道如何正确地用代数方式写出这样的对比。我的尝试附在下面的图片中（抱歉，我无法弄清楚如何直接在此网站上书写）。

其中 I 是干预效果，y 是响应变量，x 是预测变量，t 是一系列随访时间，t0 是基线时间，T 是治疗组，C 是对照组。
如果有人能帮我用代数符号正确纠正/写出这个，我将不胜感激，因为假设正态分布误差的线性模型的对比情况。以及这如何推广到具有对数链接的泊松模型。在这种情况下，差异中的差异变成了响应尺度上的比率，但我再次不确定如何使用代数符号正确地写出它。谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/655153/algebraic-notation-for-contrasts-from-statistical-model</guid>
      <pubDate>Tue, 01 Oct 2024 07:44:36 GMT</pubDate>
    </item>
    <item>
      <title>低事件数 Cox 模型的特征选择</title>
      <link>https://stats.stackexchange.com/questions/655152/feature-selection-for-cox-model-with-low-event-number</link>
      <description><![CDATA[我感兴趣的是一组 30 个变量是否可以预测癌症的 OS。在检查多重共线性后，我将特征减少到 15 个。问题是，我的数据集中只有大约 70 个事件（在 182 个人中），我认为这使我很难将所有这些变量都包含在最终模型中。
我不确定可以做什么（如果有的话）来解决这个问题？我一直在阅读有关逐步选择、LASSO 和 PCA 的建议，但我不确定哪种选项（如果有的话）是最好的方法。有人可以提出前进的方向吗？
谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/655152/feature-selection-for-cox-model-with-low-event-number</guid>
      <pubDate>Tue, 01 Oct 2024 07:02:57 GMT</pubDate>
    </item>
    <item>
      <title>高斯混合模型中的对数似然不单调</title>
      <link>https://stats.stackexchange.com/questions/655149/log-likelihood-not-monotonic-in-gaussian-mixture-model</link>
      <description><![CDATA[我实现了一个高斯混合模型，但我发现有时我会得到一个非单调的对数似然函数。这种情况并非总是如此，而且取决于随机初始化，它通常有效。其他时候，我会陷入对数似然先上升然后下降的循环中。这是我的代码：
N = data.shape[0] # 数据点数

mu = np.random.choice(data, size=num_components)

sigma = np.random.uniform( low=3, high = 10, size=num_components) # 标准偏差
print(&quot;Mu guess:\n&quot;, mu)
print(&quot;Sigma guess:\n&quot;, sigma)
pi = np.ones(num_components) * (1.0 / num_components) # 混合系数
r = np.zeros([num_components, N]) # 职责

for iteration in range(tot_iterations):
for k in range(num_components):
r[k, :] = pi[k] * norm.pdf(x=data, loc=mu[k], scale=sigma[k])
r = r / np.sum(r，axis=0)#[K，N]-&gt; [N]
N_k = np.sum(r, axis=1)
for k in range(num_components):
mu[k] = np.sum(r[k, :] * data) / N_k[k]
numerator = r[k] * (data - mu[k]) ** 2
sigma[k] = np.sqrt(np.sum(numerator) / N_k[k])
pi = N_k / N

likelihood = 0.0
for k in range(num_components):
unlikely += pi[k] * norm.pdf(x=data, loc=mu[k], scale=sigma[k])
nll_list.append(np.sum(np.log(likelihood)))

我开始怀疑这是由于某种数字/浮点问题造成的。我能做些什么来解决这个问题吗？令人沮丧的是，它只对一些起始猜测有效，但对全部猜测无效。]]></description>
      <guid>https://stats.stackexchange.com/questions/655149/log-likelihood-not-monotonic-in-gaussian-mixture-model</guid>
      <pubDate>Tue, 01 Oct 2024 05:48:39 GMT</pubDate>
    </item>
    <item>
      <title>发病率的分布及其标准误差是多少</title>
      <link>https://stats.stackexchange.com/questions/655148/what-is-the-distribution-of-incidence-rate-and-its-standard-error</link>
      <description><![CDATA[这个问题困扰了我很长时间。我谷歌了一下，也试过聊天机器人，但都没成功。
这里的发病率是以 xxx 例/yyy 人次的形式表示的。我想弄清楚的是它的分布和标准误差。
感谢您的帮助。
有什么想法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655148/what-is-the-distribution-of-incidence-rate-and-its-standard-error</guid>
      <pubDate>Tue, 01 Oct 2024 05:07:06 GMT</pubDate>
    </item>
    <item>
      <title>（-a,a）中均匀分布的样本估计量的均方误差</title>
      <link>https://stats.stackexchange.com/questions/655146/mean-squared-error-of-an-estimator-of-samples-that-are-uniformly-distributed-in</link>
      <description><![CDATA[令 $MSE(\hat{\theta}) := \mathbb{E}(​​(\hat{\theta}-\theta)^2)$ 为统计量 $\hat{\theta}$ 的均方误差。
我的问题在文章末尾。其余部分由我来处理。

令 $X_{1},...,X_{n}$ 为来自 $(-a,a)$ 上均匀分布的 i.i.d. 样本。
(a) 求矩法估计量 $\hat{a_{1}}$。它是无偏的吗？
(b) 求出 MLE $\hat{a}_{2}$。它是无偏的吗？
(c) 上述两个估计量中哪个 MSE 较低？

(a) 矩法：第一矩消失，因此通过使第二矩相等，我们得到 $$\hat{a}_1 = \sqrt{\dfrac{3(X_1^2+X_2^2+\ldots+X_n^2)}{n}}.$$
但根据 Jensen 不等式 $$\mathbb{E}(​​\hat{a}_1) &lt; \sqrt{E(\hat{a}_1^2)} = a$$，因此估计量是有偏差的。
(b) 常规计算显示 $$\hat{a}_{2} = max\{|X_1|,|X_2|,\ldots,|X_n|\}.$$ 进一步 $|X|$ 在 $(0,a)$ 上均匀分布，因此使用顺序统计分布公式，我们得到 $\mathbb{E}(​​\hat{a}_2) = \dfrac{na}{n+1}$。
(c) 我可以计算 MLE 估计的 MSE，因为分布很容易计算。所以实际的问题是

我们如何计算 $\hat{a}_1$ 的 MSE？
]]></description>
      <guid>https://stats.stackexchange.com/questions/655146/mean-squared-error-of-an-estimator-of-samples-that-are-uniformly-distributed-in</guid>
      <pubDate>Tue, 01 Oct 2024 04:55:57 GMT</pubDate>
    </item>
    <item>
      <title>ARMA(2,2) 的无限移动平均表示</title>
      <link>https://stats.stackexchange.com/questions/655143/infinity-moving-average-representation-of-an-arma2-2</link>
      <description><![CDATA[我正在尝试编写以下 ARMA(2,2) 过程的无限移动平均表示
$$Y_t = 1.1 Y_{t-1} - 0.8Y_{t-2} - 1.7\epsilon_{t-1} + 0.72\epsilon_{t-2} + \epsilon_t,$$
其中 $\epsilon_t \sim WN(0, \sigma^2)$.
我已经验证这是一个因果过程，这意味着它可以用无限移动平均表示。但是，在使用系数之间的关系时，我得到了一个无法以封闭形式表达的递归定律：
$$\psi_k = 1.1 \psi_{k-1} - 0.8 \psi_{k-2}, \hspace{0.15cm} k \geq 3.$$
如果有人能帮助我或提供如何进行的提示，我将不胜感激！
此外，我想提一下，特征多项式中没有公共根（自回归多项式中的虚根），因此无法通过分解项将该过程简化为低阶 ARMA 模型，例如 ARMA(1,1)。]]></description>
      <guid>https://stats.stackexchange.com/questions/655143/infinity-moving-average-representation-of-an-arma2-2</guid>
      <pubDate>Tue, 01 Oct 2024 01:21:24 GMT</pubDate>
    </item>
    <item>
      <title>区分两个高斯</title>
      <link>https://stats.stackexchange.com/questions/655142/distinguishing-two-gaussians</link>
      <description><![CDATA[假设我们有两个高斯$N_0 = \mathcal{N}(0, \Sigma_0)$和$N_1 = \mathcal{N}(0,\Sigma_1)$，其中$\Sigma_0$和$\Sigma_1$是两个$n\times n$协方差矩阵。
区分它们的最佳检验方法是什么？如果 $\Sigma_0$ 和 $\Sigma_1$ 都是可逆的，我知道似然比检验有效，即
$$X^T (\Sigma_0^{-1} - \Sigma_1^{-1})X$$
具有最小检验误差。
如果 $\Sigma_0$ 或 $\Sigma_1$ 退化了怎么办？作为一个猜测，我觉得
$$X^T (\Sigma_0^{\dagger} - \Sigma_1^{\dagger})X$$
可能有效，其中 $\dagger$ 表示 Moore–Penrose 逆。
我的问题是，这是真的吗？在哪里可以找到区分高斯分布的良好参考资料？]]></description>
      <guid>https://stats.stackexchange.com/questions/655142/distinguishing-two-gaussians</guid>
      <pubDate>Tue, 01 Oct 2024 00:16:21 GMT</pubDate>
    </item>
    <item>
      <title>如何避免似然优化中的负方差估计？</title>
      <link>https://stats.stackexchange.com/questions/655131/how-to-prevent-negative-variance-estimates-in-likelihood-optimization</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/655131/how-to-prevent-negative-variance-estimates-in-likelihood-optimization</guid>
      <pubDate>Mon, 30 Sep 2024 18:49:28 GMT</pubDate>
    </item>
    <item>
      <title>样本均值和贝塔回归系数之间有协方差吗？</title>
      <link>https://stats.stackexchange.com/questions/655101/is-there-covariance-between-the-sample-mean-and-beta-regression-coefficients</link>
      <description><![CDATA[在线性回归中，样本均值和 beta 回归估计值之间是否存在协方差？
例如模型如下：
$$ y_i = \beta_0 + \beta_1 x_i + \epsilon_i $$
在此设置中，$\bar{y}$ 是因变量的样本均值，$\bar{x}$ 是自变量的样本均值。
我想要找出答案：
$$ Cov(\bar{y}, \hat{\beta_1})$$
我首先写了 OLS 估计：
$$ \hat{\beta_1} = \frac{\sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n (x_i - \bar{x})^2} $$
然后我以 $y_i$ 的形式写下 $\bar{y}$：
$$ \bar{y} = \frac{1}{n} \sum_{i=1}^n y_i $$
把所有东西放在一起：
$$ Cov(\bar{y}, \hat{\beta_1}) = E[(\bar{y} - E[\bar{y}])(\hat{\beta_1} - E[\hat{\beta_1}])] $$
然后代入公式：
$$ Cov(\bar{y}, \hat{\beta_1}) = E\left[\left(\frac{1}{n} \sum_{i=1}^n y_i - E[\bar{y}]\right)\left(\frac{\sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n (x_i - \bar{x})^2} - E[\hat{\beta_1}]\right)\right] $$
但我不确定如何从这里继续。
我认为协方差确实存在（即非零），因为$\bar{y}$ 具有来自样本的不确定性，而$\hat{\beta_1}$ 具有来自样本的不确定性……但我不确定回归理论是否表示它们之间的协方差基本上为 0，或者在大样本下期望值约为 0，或者实际上非零。
我应该如何进行？

模拟（应 Henry 的要求）：
library(ggplot2)

set.seed(123)

n_sims &lt;- 10000

simulate_and_fit &lt;- function(n = 100) {
x &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- 2 + 3 * x + rnorm(n, 平均值 = 0, sd = 1)
模型 &lt;- lm(y ~ x)
return(c(x_bar = 平均值(x), beta1_hat = coef(model)[2]))
}

结果 &lt;- 复制(n_sims, mock_and_fit())
results_df &lt;- data.frame(x_bar = results[1,], beta1_hat = results[2,])

相关性 &lt;- cor(results_df$x_bar, results_df$beta1_hat)

ggplot(results_df, aes(x = x_bar, y = beta1_hat)) +
geom_point(alpha = 0.5) +
geom_smooth(method = &quot;lm&quot;, color = &quot;red&quot;) +
labs(title = &quot;x-bar 和 beta1-hat 之间的关系&quot;,
x = &quot;x-bar&quot;,
y = &quot;beta1-hat&quot;) +
annotate(&quot;text&quot;, x = min(results_df$x_bar), y = max(results_df$beta1_hat), 
label = paste(&quot;相关性：&quot;, round(correlation, 4)), 
hjust = 0, vjust = 1) +
theme_minimal()


看起来没有相关性 - 但我们如何从数学上证明这一点？]]></description>
      <guid>https://stats.stackexchange.com/questions/655101/is-there-covariance-between-the-sample-mean-and-beta-regression-coefficients</guid>
      <pubDate>Mon, 30 Sep 2024 05:36:49 GMT</pubDate>
    </item>
    <item>
      <title>如何运行统计测试来逐行寻找三种不同表型中特定基因的过度富集？</title>
      <link>https://stats.stackexchange.com/questions/655150/how-to-run-a-statistical-test-to-look-for-over-enrichment-of-specific-genes-acr</link>
      <description><![CDATA[这是我的 contingency_table:
基因组表型 1 表型 2 表型 3
基因组 1 2 4 26
基因组 2 0 0 1
基因组 3 2 6 4
基因组 4 1 0 0
基因组 5 0 0 2
基因组 6 0 0 1
基因组 7 0 0 1
基因组 8 0 1 1
基因组 9 3 0 6
基因组 10 0 0 1

我想识别出一种表型显著富集于其他两种表型的基因组。我认为我需要以逐行方式对每个基因组使用 3x2 矩阵来运行 Fisher 精确检验，对吗？对于每个基因组，我想为 p 值添加一个新列。那么，我是否需要为多重检验校正的 p 值添加一个额外的列，也许可以使用 Bonferroni 校正？
当我说 3x2 矩阵时，我认为每个基因组的数据都可以用 3x2 矩阵格式表示，其中：

列：代表三种表型类别（表型 1、表型 2、表型 3）
行：两行代表正在测试的基因组的计数和其余基因组的计数。

为此，我尝试了以下方法：
# 加载库
library(dplyr)

# 创建列联表作为数据框
contingency_table &lt;- data.frame(
Gene_group = c(&quot;Gene_group1&quot;, &quot;Gene_group2&quot;, &quot;Gene_group3&quot;, &quot;Gene_group4&quot;, &quot;Gene_group5&quot;, &quot;Gene_group6&quot;, &quot;Gene_group7&quot;, &quot;Gene_group8&quot;, &quot;Gene_group9&quot;, &quot;Gene_group10&quot;),
phenotype1 = c(2, 0, 2, 1, 0, 0, 0, 0, 3, 0),
phenotype2 = c(4, 0, 6, 0, 0, 0, 0, 1, 0, 0),
phenotype3 = c(26, 1, 4, 0, 2, 1, 1, 1, 6, 1)
)

# 为每个基因组运行 Fisher 精确检验的函数
run_fisher_test &lt;- function(gene_group_row, total_counts) {
# 提取当前 ST 的计数组
current_counts &lt;- as.numeric(gene_group_row[2:4])

# 剩余组的计数
remaining_counts &lt;- colSums(total_counts[-which(total_counts$Gene_group == gene_group_row$Gene_group), 2:4])

# 创建列联表
contingency_matrix &lt;- rbind(current_counts, remaining_counts)

# 运行 Fisher 精确检验
test_result &lt;- fisher.test(contingency_matrix)

return(test_result$p.value)
}

# 将函数应用于列联表的每一行
contingency_table &lt;- contingency_table %&gt;%
rowwise() %&gt;%
mutate(p_value = run_fisher_test(cur_data(), contingency_table)) %&gt;%
ungroup() # 按行操作后取消分组

# 测试总数
num_tests &lt;- nrow(contingency_table)

# 使用 Bonferroni 校正调整 p 值
contingency_table &lt;- contingency_table %&gt;%
mutate(adjusted_p_value = p.adjust(p_value, method = &quot;bonferroni&quot;)) %&gt;%
mutate(bonferroni_significance = 0.05 / num_tests) # 计算 Bonferroni 显著性水平

# 查看结果
print(contingency_table)

结果如下所示：

所有这些听起来都是正确的方法吗？
然后，我还想运行 2 x 2 Fishers 精确检验来查看在表型 1 或表型 3 中显著富集的基因组，将 p 值和多重检验校正的 p 值添加到每个基因组的附加列中。
我是 R 编码新手，所以任何建议都会非常有帮助。]]></description>
      <guid>https://stats.stackexchange.com/questions/655150/how-to-run-a-statistical-test-to-look-for-over-enrichment-of-specific-genes-acr</guid>
      <pubDate>Mon, 30 Sep 2024 04:30:22 GMT</pubDate>
    </item>
    <item>
      <title>Maxout 激活函数与 ReLU（权重数量）</title>
      <link>https://stats.stackexchange.com/questions/655067/maxout-activation-function-vs-relu-number-of-weights</link>
      <description><![CDATA[据我了解，Maxout 函数的工作原理与 ReLU 完全不同。
ReLU 函数是 max(0, x)，因此输入 x 是 (W_T x + b)
Maxout 函数有许多 W，它是 max(W1_T x + b1, W2_T x + b2, ...)
我理解 ReLU 函数在函数中没有感知器的权重，但 Maxout 函数在函数中有权重。 （并且有更多参数）
我理解得对吗？
许多激活函数，例如 ReLU、Sigmoid、tanh、Leaky ReLU 都使用标量值，这是一个已经计算出的值 (W_T x + b)
Maxout 函数与此不同，对吗？
那么从激活函数的变化来看，权重的数量可以改变吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/655067/maxout-activation-function-vs-relu-number-of-weights</guid>
      <pubDate>Sun, 29 Sep 2024 04:23:30 GMT</pubDate>
    </item>
    </channel>
</rss>