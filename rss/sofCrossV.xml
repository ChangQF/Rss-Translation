<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Sat, 11 May 2024 21:13:10 GMT</lastBuildDate>
    <item>
      <title>概率密度函数的标量乘法</title>
      <link>https://stats.stackexchange.com/questions/647051/scalar-multiplication-with-probability-density-function</link>
      <description><![CDATA[我有一个问题，我需要一种通用方法来将标量与概率密度/质量函数相乘？ （我对连续案例更感兴趣 - 所以 pdf，但适用于 PMF 的解决方案也很好。）
概率分布函数之和相当于概率分布函数的卷积。同样，有没有办法将概率分布与标量/常数相乘？
pdf1 + pdf2 == 卷积(pdf1, pdf2)

所以，
pdf1 + pdf1 == 卷积(pdf1, pdf1)
对于整数值标量，一个简单的解决方案是重复加法。但有没有更快的方法呢？但更重要的是，是否有适用于浮点标量乘法的解决方案？
也就是说，我想做0.5 * pdf1等
&lt;小时/&gt;
就上下文而言，主要用例是成本估算。假设一个请求由两个子请求处理，每个子请求都有一个延迟分布 pdf1 和 pdf2。如果这两者连续发生，那么总请求将遵循 pdf1 + pdf2 == convolve(pdf1, pdf2)。
但是，如果 70% 的请求由 pdf1 处理，30% 的请求使用 pdf2，则总预期延迟将为 0.7*pdf1 + 0.3*pdf2。
任何有关如何执行此操作的指导都会有所帮助。
（与 numpy/scipy 一起使用的解决方案更好）]]></description>
      <guid>https://stats.stackexchange.com/questions/647051/scalar-multiplication-with-probability-density-function</guid>
      <pubDate>Sat, 11 May 2024 20:36:31 GMT</pubDate>
    </item>
    <item>
      <title>小数据集的增强[重复]</title>
      <link>https://stats.stackexchange.com/questions/647046/augmentation-for-small-dataset</link>
      <description><![CDATA[0
我有一个非常小的数据集，因此它的性能非常差（65,20）。如何扩大数据集？我将数据集乘以一系列数字并将其输入到主数据集中（大约7倍），模型的性能得到了提高，但无论我在缩放器中放入多少，数据集都不正常。有谁知道该怎么办吗？
我想要的是能够以我拥有最低轨道的方式增加数据，有人有想法吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/647046/augmentation-for-small-dataset</guid>
      <pubDate>Sat, 11 May 2024 18:17:13 GMT</pubDate>
    </item>
    <item>
      <title>R 中的 Hajek 耦合构造验证</title>
      <link>https://stats.stackexchange.com/questions/647045/hajek-coupling-construction-verification-in-r</link>
      <description><![CDATA[我最近正在阅读 Lehmann 和 Romano 所著的检验统计假设（第四版）。在第 565 页的定理 12.2.2 中，有一个著名的耦合结构，俗称 Hajek Coupling，其中 SRSWOR（带替换的简单随机抽样）指标之和与独立指标之和相结合
伯努利指数以克拉弗方式。这个方法。首次描述于 Hajek (1961) 的论文中。
我尝试模仿这个过程来看看该方法的有效性。为此，我使用以下代码在 R 中进行了小型模拟研究。
&lt;前&gt;&lt;代码&gt;rm（列表= ls（））
库（pbmcapply）


hajek_coupling_generator &lt;- 函数(bern_ind, n){
  B_N = 总和(bern_ind)
  H_ind &lt;-rep(0, times = length(bern_ind))
  
  如果（B_N == n）{
    r＜-1
    H_ind = bern_ind
  }
  否则如果（B_N &lt; n）{
    r＜-2
    ind &lt;- 联合（其中（bern_ind == 1），
                 样本（setdiff（1：N，其中（bern_ind == 1）），
                        大小 = n-B_N，替换 = F))
    
    for (i in ind) {
      H_ind[i] &lt;- 1
    }
  }
  别的{
    r＜-3
    ind &lt;- 样本（其中（bern_ind == 1），
                  大小=n，
                  替换 = F)
    for (i in ind) {
      H_ind[i] &lt;- 1
    }
  }
  返回（列表（H_ind，r））
}



N &lt;- 30000
f_N &lt;- 0.1
n &lt;- 楼层(N*f_N)

硝石 &lt;- 2000
# bern_ind &lt;- rbinom(N, 1, n/N)
x &lt;- seq(从 = 0, 到 = 1,
         长度.输出 = N)

  
  

L2_conv.result &lt;- do.call(rbind, pbmclapply(1:Niter,
                                            函数（一）{
                                              
                                              bern_ind &lt;- rbinom(N, 1, n/N)
                                              tilde_S_n &lt;- sum(x*bern_ind)
                                              
                                              H &lt;- hajek_coupling_generator(bern_ind, n)
                                              H_ind &lt;- H[[1]]
                                              r &lt;- H[[2]]
                                              S_n &lt;- sum(x*H_ind)
                                              
                                              num &lt;- (tilde_S_n - S_n)^2
                                              
                                              
                                            返回（c（r，tilde_S_n，S_n，num））}，mc.cores = 7））


df &lt;- as.data.frame(L2_conv.result)

平均值(df$V4[df$V1 == 1])/var(df$V2[df$ &gt;V1==1])
平均值(df$V4[df$V1 == 2])/var(df$V2[df$ &gt;V1==2])
平均值(df$V4[df$V1 == 3])/var(df$V2[df$ &gt;V1==3])

打印（平均值（L2_conv.结果[,4]）/var（L2_conv.结果[,2]））


绘图（ecdf（df$V2[df$V1==1]））
行（ecdf（df$V3[df$V1==1]），col =“红色”）

绘图（ecdf（df$V2[df$V1==2]））
行（ecdf（df$V3[df$V1==2]），col =“红色”）

绘图（ecdf（df$V2[df$V1==3]））
行（ecdf（df$V3[df$V1==3]），col =“红色”）


图（ecdf（L2_conv.result[,2]），main =“哈耶克耦合”）
行（ecdf（L2_conv.result[,3]），col =“红色”）

这里我们主要检查以下几点，
$$
\frac{\mathbb{E}(​​\tilde{S}_n - S_n)^2}{\text{Var}(\tilde{S}_n)} \to 0,\quad\text{as $\min( n,N-n)\to\infty$}。
$$
书中描述了所有符号。
我的代码无法验证这一点（即我的代码确实显示了与 $0$ 的收敛）。我无法找到问题出在哪里。任何形式的帮助都是值得赞赏的。]]></description>
      <guid>https://stats.stackexchange.com/questions/647045/hajek-coupling-construction-verification-in-r</guid>
      <pubDate>Sat, 11 May 2024 17:49:06 GMT</pubDate>
    </item>
    <item>
      <title>公寓价格数据集：为什么系数符号不同，但以其他值为条件时却不同？</title>
      <link>https://stats.stackexchange.com/questions/647044/apartment-price-dataset-why-are-the-coefficient-signs-different-but-not-when-co</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/647044/apartment-price-dataset-why-are-the-coefficient-signs-different-but-not-when-co</guid>
      <pubDate>Sat, 11 May 2024 17:48:03 GMT</pubDate>
    </item>
    <item>
      <title>多元回归 - 混合变量</title>
      <link>https://stats.stackexchange.com/questions/647042/multiple-regression-mixed-variables</link>
      <description><![CDATA[您好，我正在使用连续 DV 进行多元线性回归。三个连续变量和两个分类变量（一个二元，另一个多类别）。
如何在 spss 上运行回归？我需要创建假人吗？我可以将其全部添加到一个模型上还是需要制作单独的模型。]]></description>
      <guid>https://stats.stackexchange.com/questions/647042/multiple-regression-mixed-variables</guid>
      <pubDate>Sat, 11 May 2024 17:14:16 GMT</pubDate>
    </item>
    <item>
      <title>条件概率陈述的充分条件</title>
      <link>https://stats.stackexchange.com/questions/647040/sufficient-conditions-for-a-conditional-probability-statement</link>
      <description><![CDATA[考虑随机变量$Y、X、D、\epsilon_1、\epsilon_0$，其中

$X$ 支持$\mathcal{X}$，

$D$ 是二进制的，

$(\epsilon_0, \epsilon_1)$ 独立于 $X$ 且完全支持 $\mathbb{R}^2$。


考虑一些实值函数 $g_0(\cdot)$ 和 $g_1(\cdot)$ 并假设：
$$
\开始{对齐}
&amp;Y_0=g_0(X)+\epsilon_0\\
&amp;Y_1=g_1(X)+\epsilon_1\\
&amp;D=1\{Y_1\geq Y_0\}。
\结束{对齐}
$$
还假设存在以下限制：
$$
c(x)\equiv \lim_{u\rightarrow \infty} \Pr(D=1| X=x, Y_1=u)。
$$
问题：我想证明如果
$$
(S) \quad \lim_{u\rightarrow \infty} \Pr(\epsilon_0\leq a+u| \epsilon_1=u)=k&gt;0 \quad \forall a\in \mathbb{R},
$$
然后，
$$
c(x)=k&gt;0 \quad \forall x\in \mathcal{X}
$$
我的尝试：
$$
\开始{对齐}
  \Pr(D=1| X=x, Y_1=u)= \Pr(\epsilon_0\leq u-g_0(x)| \epsilon_1+g_1(x)=u)。
\结束{对齐}
$$
现在，令$a\equiv -g_0(x)$，然后
$$
\开始{对齐}
(S&#39;)\quad \Pr(D=1| X=x, Y_1=u)= \Pr(\epsilon_0\leq a+u| \epsilon_1=u-g_1(x))。
\结束{对齐}
$$
这就是“几乎”了。 (S)但调节事件不同。 (S) 或 (S&#39;) 错了吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/647040/sufficient-conditions-for-a-conditional-probability-statement</guid>
      <pubDate>Sat, 11 May 2024 16:47:53 GMT</pubDate>
    </item>
    <item>
      <title>MATLAB 中频域互相关和 xcorr2 [关闭]</title>
      <link>https://stats.stackexchange.com/questions/647039/cross-correlation-in-frequency-domain-and-xcorr2-in-matlab</link>
      <description><![CDATA[我的频域互相关结果与使用 MATLAB 中的 xcorr2() 函数获得的结果之间存在差异的原因是什么？ xcorr2() 是否有可能执行空间域互相关，这对结果有何影响？
img1 = imread(&#39;1.jpg&#39;);
img2 = imread(&#39;2.jpg&#39;);

img1_gray = rgb2gray(img1);
img2_gray = rgb2gray(img2);

[m，n] = 大小（img1_gray）；
[p，q] = 大小（img2_gray）；

fft_img1 = fft2(img1_gray, m + p - 1, n + q - 1);
fft_img2 = fft2(img2_gray, m + p - 1, n + q - 1);

cross_correlation = (fft_img1 .* conj(fft_img2));
交叉相关 = ifft2(交叉相关);
交叉相关 = fftshift(交叉相关);

cross_correlation_xcorr2 = xcorr2(img2_gray, img1_gray);

数字;
子图(2,1,1);
imshow（交叉相关，[]）；
title(&#39;频率互相关&#39;);
子图(2,1,2);
imshow(cross_correlation_xcorr2, []);
标题(&#39;xcorr2&#39;);

结果：
]]></description>
      <guid>https://stats.stackexchange.com/questions/647039/cross-correlation-in-frequency-domain-and-xcorr2-in-matlab</guid>
      <pubDate>Sat, 11 May 2024 15:59:02 GMT</pubDate>
    </item>
    <item>
      <title>我的项目要使用什么统计测试？</title>
      <link>https://stats.stackexchange.com/questions/647038/what-statistical-test-to-use-on-my-project</link>
      <description><![CDATA[我很困惑在我的项目中在 RStudio 中使用什么样的统计测试，
我测量了 6 个月内 3 个人口密度级别（低、中和高）的平均盐度（因此每个人口密度级别有 6 个平均值）
我想看看平均盐度值（定量连续数据）和人口密度（分类；低、中、高）之间是否存在统计显着性，但我不确定使用哪个测试我已经尝试了弗里德曼&amp; Kruskal-wallis，但不确定使用哪个。
非常感谢您的建议！]]></description>
      <guid>https://stats.stackexchange.com/questions/647038/what-statistical-test-to-use-on-my-project</guid>
      <pubDate>Sat, 11 May 2024 15:44:31 GMT</pubDate>
    </item>
    <item>
      <title>我计算格兰杰因果关系的方法有效吗？</title>
      <link>https://stats.stackexchange.com/questions/647031/is-my-approach-to-compute-granger-causality-valid</link>
      <description><![CDATA[我有两个时间序列，我们称它们为 A（红色）和 B（蓝色）。每个时间序列大约有 770 个数据点。
注意：这两个时间序列实际上都不是记录的原始信号，而是滑动窗口方法的结果。我对两个原始的原始时间序列应用了完全相同的滑动窗口方法，然后计算每个窗口的测量值。这使我能够比较两个信号的测量的时间演变或结构。
问题：虽然两个原始时间序列是平稳的，但滑动窗口方法的结果却不是。从图中可以很容易地看出，滑动窗口时间序列是非平稳的（它们当然无法通过 ADF 和 KPSS 测试）。
目标：我想计算 B（蓝色）格兰杰是否导致 A（红色），因此应用格兰杰因果检验。现在，如果在两个基于滑动窗口的时间序列之间应用格兰杰因果关系在概念上有意义的话，让我们转移这个问题。让我们假设这两个时间序列都源于非平稳原始信号。我遵循 Toda 和 Yamamoto (1995) 的方法来计算 Granger 因果关系，如 Python 链接中所述：
https://rishi-a.github.io/2020/ 05/25/granger-causality.html
这是一个我想测试格兰杰因果关系的图。显示的 p 值 p &lt; 0.001 是在获取每个时间序列的第一个差值后计算的，使它们静止。差分后的 p 值源自 ssr_chi2test 检验，最佳滞后基于 BIC 标准。 （事实上​​，即使没有差异，p 值仍然是 p &lt; 0.001。）差异时间序列通过了 ADF 和 KPSS 测试，而且看起来也完全平稳。

这是对两个时间序列进行差分后的相同图（一阶差分）。正是在这些时间序列上，按照上面链接的所有步骤执行格兰杰因果关系检验。

问题：我有几个问题。

鉴于时间序列基于滑动窗口，手动选择滞后 1 是否有效（同时假设 B 对 A 的影响几乎没有时间滞后）？&lt; /p&gt;

在测试格兰杰因果关系之前，由于其极端不稳定的时间结构，对两个时间序列进行差分以使其平稳是绝对必要的，或者由于非平稳时间序列，在不进行差分的情况下计算格兰杰因果关系是否有效反映测量的真实时间演变？

基于对原始（无差异）时间序列的目视检查，您是否愿意推荐一种与我所关注的链接中描述的方法完全不同的方法来计算格兰杰因果关系？


作为格兰杰因果关系和 VAR 模型的初学者，我通常想知道我引用的链接中的方法和代码（https://rishi-a.github.io/2020/05/25/granger-causality.html）通常适合我的具体数据，或者如果我正在做一些确实有缺陷的事情。]]></description>
      <guid>https://stats.stackexchange.com/questions/647031/is-my-approach-to-compute-granger-causality-valid</guid>
      <pubDate>Sat, 11 May 2024 14:00:36 GMT</pubDate>
    </item>
    <item>
      <title>ANCOVA 主要思想[重复]</title>
      <link>https://stats.stackexchange.com/questions/647030/ancova-main-ideas</link>
      <description><![CDATA[协方差分析只是 OLS 回归加上预测 y 值之上的假设检验吗？
$\hat{y} = BX = B_{treatment}treatment + X_{2...n}B_{2...n}+B_0$
$H_0: \mu_{\hat{y}_{treatment}} - \mu_{\hat{y}_{control}} = 0$ 
$H_1: \mu_{\hat{y}_{treatment}} - \mu_{\hat{y}_{control}} \ne 0$
编辑：我认为正确但省略的一个细节是 $\hat{y_i}$ 假定任何协变量的全局平均值（不包括治疗暴露）以及任何分类变量的参考水平。
换句话说，一旦模型拟合并且可以将一定量的变化归因于 $X$ 中的每个协变量，模型就会被查询两次，一次为治疗组一次，对照组一次；在这两种情况下，都会为所有协变量提供平均值（分类的连续或参考水平）值，从而消除协变量不平衡的影响。假设调整后的 R 平方相当高，则 $\hat{y}$ 周围的方差应该有意义地减少，这会增加测试的灵敏度。
换句话说
$\hat{y_{treatment}} = \beta_{treatment} + \Sigma_{i=1}^{N} \beta_iX_i + \beta_0$ 
$\hat{y_{control}} = \Sigma_{i=1}^{N} \beta_iX_i + \beta_0$
$\Delta = y_{治疗} - y_{控制} $]]></description>
      <guid>https://stats.stackexchange.com/questions/647030/ancova-main-ideas</guid>
      <pubDate>Sat, 11 May 2024 12:52:38 GMT</pubDate>
    </item>
    <item>
      <title>生物神经网络信息传递中的傅里叶变换</title>
      <link>https://stats.stackexchange.com/questions/647024/fourier-transform-in-information-transfer-in-biological-neural-network</link>
      <description><![CDATA[神经设计原理作者：Peter Sterling 和 Simon Laughlin描述了信息论在计算大脑中信息传输速率时的用法。
&lt;块引用&gt;
...当连续信号状态不相关时...信息速率为 I = R \log2 (1 + S/N) 位每秒。该方程假设冗余为零，即信号状态之间不存在相关性。为了实现这一点，信号状态必须随机改变。为了真正随机，信号必须能够从任何状态跳到任何其他状态。但这种能力受到跳跃所需时间的限制...香农通过使用傅里叶变换将连续的模拟信号和噪声转换为其频率分量来解决这个问题...由此可见信号所携带的总信息是其每个分量频率所携带的信息的总和。 I = int(0-co)log2[1 + S(f) / N(f)] * df

所有状态都可以在一定时间内到达。为什么应用傅立叶变换可以解决这个问题？]]></description>
      <guid>https://stats.stackexchange.com/questions/647024/fourier-transform-in-information-transfer-in-biological-neural-network</guid>
      <pubDate>Sat, 11 May 2024 11:02:37 GMT</pubDate>
    </item>
    <item>
      <title>“随机变量的置信区间”是不正确的术语吗？</title>
      <link>https://stats.stackexchange.com/questions/647022/is-it-incorrect-terminology-to-say-confidence-interval-of-a-random-variable</link>
      <description><![CDATA[我见过“总体参数不是随机变量”的说法。在讨论置信区间时。
例如此处
&lt;块引用&gt;
请务必注意，总体参数不是随机变量。

在频率论解释的背景下，我毫不犹豫地接受这一说法。根据这种解释，总体参数是固定的，但未知。它们不是随机变量。
但是术语置信区间是否也带有特定的解释？或者它只是数学函数（如 wiki 所示）：
&lt;块引用&gt;


例如，假设我认为 𝜃（总体参数）是随机变量，X 是随机样本。考虑到它们的联合分布，我计算函数：
P( u(x) &lt; 𝜃 &lt; v(x)) = c ∀ 𝜃
看起来像下图中的红线：

（图借自此处）
现在，我将红线称为“随机变量的置信区间”是错误的吗？ 𝜃？]]></description>
      <guid>https://stats.stackexchange.com/questions/647022/is-it-incorrect-terminology-to-say-confidence-interval-of-a-random-variable</guid>
      <pubDate>Sat, 11 May 2024 10:12:44 GMT</pubDate>
    </item>
    <item>
      <title>关于 t 检验中不同水平重复的问题</title>
      <link>https://stats.stackexchange.com/questions/647019/question-about-replicates-at-different-levels-in-a-t-test</link>
      <description><![CDATA[我是一名生物技术硕士生。在实验中，我们想知道两个样本在特定温度下生长的细菌数量是否存在差异。所以设置如下：

我们对生长板上生长的细菌进行了计数（黄色圆圈）。这就是我的数据。
我取了 3 个稀释度的 2 个重复的平均值。然后我计算了这三个稀释度的平均值。然后我计算了这三个重复的平均值。
这是特定温度（例如 4°C）下的单数，我想将其与不同样品的特定温度下生长的细菌数量进行比较。通常，我可以对最后三个重复进行学生的 T 检验，但由于我采用的是均值，所以我不确定]]></description>
      <guid>https://stats.stackexchange.com/questions/647019/question-about-replicates-at-different-levels-in-a-t-test</guid>
      <pubDate>Sat, 11 May 2024 08:43:43 GMT</pubDate>
    </item>
    <item>
      <title>考试 P 示例问题 # 30</title>
      <link>https://stats.stackexchange.com/questions/647011/exam-p-sample-problems-30</link>
      <description><![CDATA[问题：
&lt;块引用&gt;
一家公司设立了 120 美元的基金，希望从中支付
金额 C，授予 20 名取得高绩效的员工中的任何一位
来年的水平。每个员工有 2% 的机会
来年实现高绩效水平。事件
不同员工在工作期间取得高绩效水平的比例
来年是相互独立的。
计算概率较小的C的最大值
超过 1% 的资金将不足以支付所有费用
高性能。

提供了此问题的解决方案，但我不太了解设置。直觉上我们可以说，高绩效员工的数量是有上限的，一旦超过这个阈值，我们将没有足够的资金来支付奖金。该解决方案表示我们要找到 $x$ 使得 $P(X&gt;x)&lt;0.01$ span&gt; 其中 $X \sim \text{bin}(20, 0.02)$。同样，我们可以找到 $P(X\leq x)&gt;0.99$。
$P(X=0)=0.068, P(X=1)=0.272, P(X=2)=0.053, P(X=3)=0.006$ 
$P(X\leq 0) = 0.068，P(X\leq 1) = 0.94，P(X\leq 2) = 0.068，P(X\leq 3) = 0.999 $
$P(X&gt;0) = 0.332，P(X&gt;1)=0.06，P(X&gt;2)=0.007，P(X&gt;3)=0.001$
那么 $x=2$ 就是 $P(X&gt;x)$ 小于的地方$0.01$。
因此 $C=\frac{120}{2}=60$ 是正确的最终答案.
对我来说问题是我不知道为什么我们想要找到 $P(X&gt;x)&lt;0.01$ 而不是 $P(X=x)&lt;0.01$ 或 $P(X\geq x)&lt;0.01$。
(a) 我将查找 $P(X&gt;x)&lt;0.01$ 解释为：查找“成功”的数量20 次中，假设为 c，获得超过 c 次成功的概率小于 1%。我对“成功”的定义是：这里称为“成为一名高绩效者”。换句话说，我们正在寻找高绩效人员的数量 c，这样拥有超过 c 个高绩效人员的概率小于 1%。
(b) 我将发现 $P(X=x)&lt;0.01$ 解释为：找到高绩效者的数量 c，这样的概率恰好拥有 c 个高绩效员工的比例不到 1%。
(c) 我将查找 $P(X \geq x)&lt;0.01$ 解释为：找到高绩效者的数量 c，使得概率拥有至少 c 名高绩效员工的比例不到 1%。
假设解释（a）、（b）和（c）是正确的，我不明白为什么（b）和（c）不能给我们正确的答案。有人可以向我解释一下为什么（最好是在这个问题的背景下）（a）将引导我们找到解决方案，而（b）和（c）却不能？
例如，如果我使用解释 (b) 来设置问题，那么我会说，因为 $P(X=2)=0.053&gt;0.01$，我们需要 2 名以上的高绩效员工才能维持向所有高绩效员工支付奖金的概率低于 1%。 3 个高绩效者怎么样？ $P(X=3)=0.006 &lt; 0.01 美元。因此，让高绩效人员的数量为 3，将 120 除以 3，我们得到 $C=40$。在没有看到解决方案的情况下，我会认为答案是正确的。
我在这里不明白什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/647011/exam-p-sample-problems-30</guid>
      <pubDate>Sat, 11 May 2024 03:00:51 GMT</pubDate>
    </item>
    <item>
      <title>高斯过程：置信区间 vs 预测区间 vs 可信区间</title>
      <link>https://stats.stackexchange.com/questions/647007/gaussian-process-confidence-interval-vs-prediction-interval-vs-credible-interva</link>
      <description><![CDATA[先具有由高斯过程 (GP) 描述的函数分布，遵循 拉斯穆森和威廉姆斯：
$$
f(\mathbf{x})\sim\mathcal{GP}(m(\mathbf{x}), k(\mathbf{x},\mathbf{x}&#39;))
$$
然后，将均值函数 $m(\mathbf{x})$ 视为零和一组点 $X_* $，我们可以从多元正态分布中采样函数点：
$$\mathcal{N}(\mathbf{0}, K(X_*, X_*))$$
其中 $K(X_*, X_*)$ 是与所选内核对应的协方差矩阵。
考虑到这一点，我们应该如何引用区间$\pm (k\cdot\sigma_{\mathbf{x}})$，其中$k$ 是一个正常数乘以标准差（$K(X_*, X_*)$&lt; 对角线的平方根/span&gt;), $\sigma_{\mathbf{x}}$?
从视觉上看，该区间对应于以下左子图的灰色区域（摘自 Rasmussen 和 Williams）：

从标题中可以看出，作者将此区间称为“置信区域”。
但是，我不明白与该图及其标题相关的一些要点：

由于预测的功能点是标量值，因此该区间不应该是“置信区间”吗？相反？

另一方面，鉴于该区间不对应于任何特定参数，而是对应于我们期望观察功能点的区间，则该区间（对于左侧子图）是否应该被称为“&lt; em&gt;预测区间”？

在计算这个区间时，是否只考虑边缘化的$\sigma_{\mathbf{x}}$的近似值，即丢弃相关信息？

最后，一旦我们以观察到的训练点为条件来预测后验预测分布（右子图），相应的区间不应该也是预测区间嗯&gt;？对于最后一个，我怀疑我们是否应该使用
可信间隔
相反，按照建议，例如作者：此博客。

]]></description>
      <guid>https://stats.stackexchange.com/questions/647007/gaussian-process-confidence-interval-vs-prediction-interval-vs-credible-interva</guid>
      <pubDate>Sat, 11 May 2024 00:22:05 GMT</pubDate>
    </item>
    </channel>
</rss>