<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Mon, 01 Jul 2024 18:20:12 GMT</lastBuildDate>
    <item>
      <title>为什么`pROC::roc`默认计算$\max\{AUC, 1 - AUC\}$？</title>
      <link>https://stats.stackexchange.com/questions/650273/why-would-procroc-calculate-max-auc-1-auc-by-default</link>
      <description><![CDATA[R 中的 pROC::roc 函数有一些有趣的行为。
library(pROC)
set.seed(2024)
N &lt;- 100
p &lt;- rbeta(N, 1/2, 1/2)
y &lt;- rbinom(N, 1, p)
r1 &lt;- pROC::roc(y, p)
r2 &lt;- pROC::roc(y, 1 - p)
r1$auc # 我得到 0.8894
r2$auc # 我得到 0.8894

无论我们使用概率（p）还是翻转所有概率（1-p），该函数都会计算相同的面积ROC 曲线。
但这与通常的计算 ROC 曲线的思路不一致，即通过改变截止阈值并计算每个阈值处的敏感度-特异性对。其中一个应该在接近 1 时显示相当高的 AUC，而另一个应该在接近 0 时显示相当低的 AUC。毕竟，当我们将 p 翻转为 1-p 时，高概率值通常对应于 1 的值，低概率值通常对应于 0 的值，相反，情况正好相反，这会导致可怕的敏感度和特异性值。
library(ModelMetrics)
thresholds &lt;- r1$thresholds
sens1 &lt;- spec1 &lt;- sens2 &lt;- spec2 &lt;- rep(NA, length(thresholds))
yhat1 &lt;- yhat2 &lt;- rep(0, length(thresholds))
for (i in 1:length(thresholds)){

# 我忘了如何以更清晰的方式与阈值进行比较
#
idx1 &lt;- which(p &gt; Thresholds[i])
idx2 &lt;- which(1 - p &gt; 阈值[i])
#
yhat1[idx1] &lt;- 1 
yhat1[-idx1] &lt;- 0 
yhat2[idx2] &lt;- 1 
yhat2[-idx2] &lt;- 0

sens1[i] &lt;- ModelMetrics::sensitivity(y, yhat1)
sens2[i] &lt;- ModelMetrics::sensitivity(y, yhat2)
#
spec1[i] &lt;- ModelMetrics::specificity(y, yhat1)
spec2[i] &lt;- ModelMetrics::specificity(y, yhat2)

}
plot(r1)
points(spec1, sens1, col = &#39;blue&#39;)
points(spec2, sens2, col = &#39;red&#39;)

绘图这样，与 1-p 预测相对应的红色曲线的曲线下面积非常糟糕，正如预期的那样。
因此，我很好奇为什么 pROC::roc 会计算出 AUC 对于如此不同的输入是相同的，一个具有良好的概率值，另一个具有糟糕的概率值。幸运的是，pROC::roc 可以与 direction = &quot;&lt;&quot; 一起运行，以防止函数输出 $\max\{AUC, 1 - AUC\}$，而是返回真实的 AUC 值。但是，这不是默认行为？函数返回 $\max\{AUC, 1 - AUC\}$ 而不是仅仅返回 AUC，这是否有一些统计原因？我想我可以看到一个论点，即$AUC&lt;0.5$意味着对预测值进行简单的转换会给出$AUC&gt;0.5$，但你必须知道要执行这样的校准步骤，否则你会使用可怕的预测值。
由于软件包开发人员是 Cross Validated 的成员，因此我对来自此类来源的答案特别感兴趣。]]></description>
      <guid>https://stats.stackexchange.com/questions/650273/why-would-procroc-calculate-max-auc-1-auc-by-default</guid>
      <pubDate>Mon, 01 Jul 2024 17:47:29 GMT</pubDate>
    </item>
    <item>
      <title>二项式随机变量的期望</title>
      <link>https://stats.stackexchange.com/questions/650271/expectation-of-binomial-random-variable</link>
      <description><![CDATA[最近在一篇论文中读到一些东西，但一直无法理解。
假设我们有 X ~ Binomial(N,p)。论文指出：
$E[X | N,p] = Np$（目前一切顺利）
并且
$E[X] = \mu p$
如果对于 Binomial(N,p)，$\mu$ 定义为 $Np$，那么第二行中的 $p$ 来自哪里？]]></description>
      <guid>https://stats.stackexchange.com/questions/650271/expectation-of-binomial-random-variable</guid>
      <pubDate>Mon, 01 Jul 2024 17:26:16 GMT</pubDate>
    </item>
    <item>
      <title>如何对多个回归模型中的多个系数进行联合显着性检验？</title>
      <link>https://stats.stackexchange.com/questions/650270/how-to-perform-a-joint-significance-test-for-multiple-coefficients-across-severa</link>
      <description><![CDATA[我有 10 个回归模型，每个模型对同一个独立变量 $ x $ 回归不同的因变量 $ y_i $（对于 $ i = 1, 2, \ldots, 10 $）。每个模型都会产生一个 $ x $ 的系数，我有兴趣测试这 10 个系数的联合重要性。
具体来说，我的模型是：
$ y_1 = \beta_{1x} x + \epsilon_1 $
$ y_2 = \beta_{2x} x + \epsilon_2 $
$ \vdots $
$ y_{10} = \beta_{10x} x + \epsilon_{10} $
我想知道测试所有 $\beta_{ix}$（对于 $ i = 1, 2, \ldots, 10 $）与零有显著差异。
背景是，我有一个技术冲击 x，它影响不同的地区，并且随时间变化，预计会影响这些地区行业 y 的就业。我已经建立了这种联系。但是，为了证明我的冲击与位置级别的其他潜在因素无关，我想表明我的冲击无法预测其他所谓不相关行业的就业。这就是为什么我将这些其他行业作为安慰剂行业。
我的结果变量（不同的 y）代表不同地区不同行业的就业，它们具有不同的量级，因此可能具有不同的方差。我的模型中有区域和时间固定效应，观察单位是位置时间，如果这有帮助的话。
是否有统计方法或特定测试可用于此目的？我熟悉 F 检验，但我的理解是 F 检验用于嵌套模型，而这似乎不是我的情况。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/650270/how-to-perform-a-joint-significance-test-for-multiple-coefficients-across-severa</guid>
      <pubDate>Mon, 01 Jul 2024 17:00:03 GMT</pubDate>
    </item>
    <item>
      <title>重复测量分类问题中数据分割的最佳实践</title>
      <link>https://stats.stackexchange.com/questions/650269/best-practices-for-splitting-data-in-a-repeated-measures-classification-problem</link>
      <description><![CDATA[我正在研究一个涉及重复测量的分类问题。我的目标是尽早对阳性患者进行分类。在我的实际应用场景中，一旦患者的目标变为 1，进一步的模型预测对该患者就无关紧要了。在建模方面，特征可能会对目标做出延迟反应，因此当每个患者的目标=1出现时，我不能简单地只保留第一行。数据结构如下：



PatientID
Time
Target
FeatureA




A
2020-01
0
...


A
2020-02
0
...


A
2020-03
1
...


B
&lt; td&gt;2019-12
0
...


B
2020-01
0
...


B
2020-02
1
...


B
2020-03
1
...


B
2020-04
1
...



我正在寻找分割数据集以防止数据泄露的最佳实践。以下是我目前所做的：

患者级别分割：我在患者级别分割数据，以确保每个患者要么在训练集，要么在测试集中，但绝不会同时在两者中。对于交叉验证，我使用 GroupKFold 来保持这种分离。

时间分割问题：我正在考虑时间分割，但我担心潜在的数据泄漏。如果患者同时出现在训练集和测试集中，模型可能会记住患者的目标变为 1。例如，如果患者 B 截至 2020-02 的数据在训练集中，而 2020-03 以后的数据在测试集中，则患者特征中的自相关可能会导致泄漏，因为模型已经从 2020-02 的类似特征值中学习，并且很可能会正确分类 2020-03 以后的数据。在理想情况下，模型只会从其他类似患者身上学习。


问题：

我的担忧有意义吗？
当同一患者出现在两个集合中并且特征具有自相关性时，有没有办法在不引入泄漏的情况下实现时间分割？如果我控制特征自相关性，这个问题会解决吗？
有没有其他交叉验证策略可以更好地解决这个问题？
有没有处理这种类型数据的特定模型？使用时间序列方法有意义吗？

谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/650269/best-practices-for-splitting-data-in-a-repeated-measures-classification-problem</guid>
      <pubDate>Mon, 01 Jul 2024 16:49:09 GMT</pubDate>
    </item>
    <item>
      <title>lme4 不一致</title>
      <link>https://stats.stackexchange.com/questions/650268/lme4-inconsistency</link>
      <description><![CDATA[我们旨在模拟完全受试者间设计中各组之间的反应时间 (RT) 差异。我们还预计项目难度会影响响应并与组交互。每个受试者 (n=120) 完全嵌套在五个组中的一个中。每个受试者有 200 个观察值，我们计划为每个受试者添加一个随机截距，以解释观察值的不独立性。但是，我们希望这个随机截距能够解释受试者在组内的嵌套，以避免混淆我们的主要固定组效应。每个项目都完全嵌套在一个难度级别中，并且应该遵循相同的嵌套策略。
为了解释这种嵌套，我们使用了以下语法：(1|Group:Subject)。 Robert Long 在此处的回答（交叉和嵌套随机效应组合的 Lmer 模型语法）表明，这种语法不是必需的，而 (1|Subject) 就足够了，因为 R 应该自动知道数据是嵌套的。
但是，如下所示在两个模型中测试这一点会显示不同的结果，请参见下文。
数据和脚本可以在此处找到：https://osf.io/g3wqh/，并且也嵌入在下面。数据结构如下：
Subject Group RT Item Diff
1 A 1547 43 3 
1 A 1432 85 7 
... Etc 
120 C 1048 23 2 

代码如下：
#Packages----
library(lme4)

#Preliminaries----
data &lt;- read.csv(&quot;lme4 data.csv&quot;, header = TRUE)
attach(data)

data$Group &lt;- as.factor(data$Group)
data$Subject &lt;- as.factor(data$Subject)
data$Item &lt;- as.factor(data$Item)
data$Diff &lt;- as.integer(data$Diff)

#Models

Model1 &lt;- lmer(RT~Group*Diff + (1|Diff:Item) + (1|Group:Subject),data=data, lmerControl(optimizer = &quot;bobyqa&quot;), REML=F, na.action=na.omit)
anova(Model1,type=3) 
summary(Model1)

结果：
Factor Pr(&gt;F)
Group 7.643e-05
Diff 1.274e-09
Group:Diff 3.346e-16

Model2 &lt;- lmer(RT~Group*Diff + (1|Item) + (1|Subject),data=data, lmerControl(optimizer = &quot;bobyqa&quot;), REML=F, na.action=na.omit)
anova(Model2,type=3) 
summary(Model2)

结果：
因子 Pr(&gt;F)
Group 8.300e-05
Diff 1.350e-09
Group:Diff 5.308e-06

如您所见，这两个模型产生了不同的结果，尽管它们不应该如此。没有警告消息。lme4 是最新的。非常欢迎任何解释。]]></description>
      <guid>https://stats.stackexchange.com/questions/650268/lme4-inconsistency</guid>
      <pubDate>Mon, 01 Jul 2024 16:10:41 GMT</pubDate>
    </item>
    <item>
      <title>用于测量事件发生随时间变化的适当测试（RStudio）</title>
      <link>https://stats.stackexchange.com/questions/650267/appropriate-test-for-measuring-change-in-event-occurrence-over-time-rstudio</link>
      <description><![CDATA[我目前正在协助的项目是查看为组织提供的降低事件发生率的培训计划是否真的具有减少事件发生率的预期效果。
每个参与研究的组织（理论上）都会让尽可能多的组织成员参加一项调查，要求他们以 1 到 5 的评分自我报告他们的经历。我说理论上是因为并非所有组织每年都进行调查，所以有些组织可能在前两年进行调查，第三年不进行调查，但在第四年再次进行调查，在选择统计测试时可能也需要考虑这一点。对于每个组织，都会计算出该组织中给出 4 或 5 评分的人员百分比的平均值。
然后，我在 RStudio 中对组织进行分组，以获得不同日历年（例如 2015、2016、2017）、注册日期的年份（注册的第一年、第二年、第三年等）和调查编号（第一次、第二次、第三次参加调查，无论他们是否在几年之间休息过等）的平均百分比。
我现在想分析这些平均值，看看这些不同的组的平均百分比是否会随着时间的推移而下降，但我不确定最合适的方法是什么。我附上了一些我制作的示例图：

最明显的方法是进行某种相关性/线性回归分析，但由于调查数字是连续的，因此并非完全独立，我不确定这样做是否正确？我知道有可能做类似配对/重复测量方差分析的事情，但我只见过最多 3 次时间测量，而我有至少 7 个时间点，所以我不确定是否有硬性数字限制。我也没有多个组来比较平均值，这只是逐年的变化 - 但是因为并非所有组织都每年都进行调查，所以我不知道是否也应该进行某种注册年份*调查编号方差分析比较来解释这一点。
如果我听起来很愚蠢，我深表歉意。我获得了动物学相关专业的本科学位，在第一年我使用预先编写的代码工作表学习了 R 中最基本的统计测试，从那时起我所做的一切都是基于调整这些基本代码和大量的谷歌猜测。我申请了这份实习，希望能更多地了解如何正确地进行数据分析，因为我认为这很酷，实际上并没有指望被选中，现在事实证明，在这里工作的人也不知道如何进行数据分析，所以如果我不确定任何事情，我不能问任何人。如果有人对此有任何建议，请提前谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/650267/appropriate-test-for-measuring-change-in-event-occurrence-over-time-rstudio</guid>
      <pubDate>Mon, 01 Jul 2024 15:59:41 GMT</pubDate>
    </item>
    <item>
      <title>实践中单位根背后的直觉</title>
      <link>https://stats.stackexchange.com/questions/650263/intuition-behind-unit-roots-in-practice</link>
      <description><![CDATA[单位根在时间序列建模中的应用似乎非常直观的一个领域是气候变化：二氧化碳停留在空气中，因此过去的冲击（流量大小）对股票规模有累积效应，不会随着时间的推移而消失。
另一方面，在 EMH 下，股票市场价格应该被建模为单位根，这似乎也很直观，因为这意味着未来实现底层 DGP 的最佳预测指标是其今天的实现。
这两个都是我们使用单位根的原因。我们能以某种方式将它们背后的原理联系起来吗？例如，有没有办法将持续冲击/存量流量解释与股票市场相匹配？]]></description>
      <guid>https://stats.stackexchange.com/questions/650263/intuition-behind-unit-roots-in-practice</guid>
      <pubDate>Mon, 01 Jul 2024 13:56:46 GMT</pubDate>
    </item>
    <item>
      <title>不同传感器之间的信号融合</title>
      <link>https://stats.stackexchange.com/questions/650262/signal-fusion-between-different-sensors</link>
      <description><![CDATA[我有一个 30 年的时间序列变量（三个深度的土壤含水量），限制在最大值和最小值之间。在此期间，使用了三种不同类型的传感器来记录三个不同时间的测量值。问题是，我想确定信号的平均值是否随时间变化，但每个传感器测量的范围（最大值/最小值）不同，导致传感器切换时时间序列出现人为变化（见下图）。要测试信号是否在变化，我需要将三个信号连接成一个连续的时间序列。到目前为止，我已经尝试通过其最大测量值标准化每个信号的输出；然而，我担心这会迫使时间序列的平均值保持平稳，但我怀疑它不是。
有人能帮我提出关于如何解决信号融合问题的想法吗？
]]></description>
      <guid>https://stats.stackexchange.com/questions/650262/signal-fusion-between-different-sensors</guid>
      <pubDate>Mon, 01 Jul 2024 13:55:27 GMT</pubDate>
    </item>
    <item>
      <title>核密度估计的 L1 误差也是总变差距离经验测度和真实测度</title>
      <link>https://stats.stackexchange.com/questions/650260/l1-error-of-kernel-density-estimator-is-also-total-variation-distance-empirical</link>
      <description><![CDATA[在以下名为“经验过程理论的简单介绍”的讲义中，他们在示例 3.25 中做出了以下陈述。

$\textbf{示例 3.25}$（核密度估计）。让$X_{1},\ldots,X_{n}$为 i.i.d。来自 $P$ 上的分布 $\mathbb{R}$（该参数可以很容易地推广到 $\mathbb{R}^d$），其密度为 $\phi .$ 我们希望使用核密度估计器 (KDE) $\hat{\phi}_n:\mathbb{R}\to[0,\infty)$ 非参数估计
$\phi$，其定义为
$$\hat{\phi}_{n}(x)=\frac{1}{nh_{n}}\sum_{i=1}^{n}K\left(\frac{x-X_{i}}{h_{n}}\right),\quad \text{for } x\in\mathbb{R},$$
其中 $h_{n}&gt; 0$ $是$平滑带宽，而$K$是非负核$（即$K\geq 0$和
$\int K(x)dx=1)$。估计量 $\hat\phi_n$ 的 $L_1$ 误差为
$$Z\equiv f(X_1,\dots,X_n):=\int|\hat{\phi}_n(x)-\phi(x)|dx.$$
随机变量 $Z$ 不仅提供了 $\hat{\phi}_n$ 和 $\phi$ 之间差异的度量，而且 $Z= 2\sup _{A}| P_{n}( A) - P( A) |$ (练习 ( HW1)：显示此内容) 其中上确界位于 $
\mathbb{R}$ 中的所有 Borel 集上，并且 $P_{n}$ 表示对应于 KDE $\hat{\phi } _{n}$ 的分布，$Z$ 还捕获了 $P_{n}$ 和 $P$ 在总变差距离上的差异。

有人知道如何显示练习 HW1 吗？也就是说，如何证明$$Z= \int|\hat{\phi}_n(x)-\phi(x)|dx = 2\sup _{A}| P_{n}( A) - P( A) |$$]]></description>
      <guid>https://stats.stackexchange.com/questions/650260/l1-error-of-kernel-density-estimator-is-also-total-variation-distance-empirical</guid>
      <pubDate>Mon, 01 Jul 2024 13:43:22 GMT</pubDate>
    </item>
    <item>
      <title>使用 STL 分解进行手动计算</title>
      <link>https://stats.stackexchange.com/questions/650259/manual-calculation-using-stl-decomposition</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/650259/manual-calculation-using-stl-decomposition</guid>
      <pubDate>Mon, 01 Jul 2024 13:04:28 GMT</pubDate>
    </item>
    <item>
      <title>内生变量与二元预测因子 (feols) 的相互作用</title>
      <link>https://stats.stackexchange.com/questions/650257/interaction-of-endogenous-variable-with-binary-predictors-feols</link>
      <description><![CDATA[我想询问使用 feols 函数指定内生变量与二元预测因子（时间和治疗）相互作用的正确方法。
理想情况下，我想指定治疗变量（2 个类别）、时间变量（2 个类别）和内生变量之间的三向相互作用。但现在我决定只使用时间变量的双向交互，并将我的数据划分为治疗和控制子样本。
feols(Y ~ 时间 + 其他 exos | FE | endo:time+endo ~ IV:time+IV, data, cluster=~CL)
我是否应该在第一部分公式中添加时间的主要影响？
如果我进一步将样本分为前后和治疗对照，与运行上述交互相比，对内生变量系数的解释会有何不同。]]></description>
      <guid>https://stats.stackexchange.com/questions/650257/interaction-of-endogenous-variable-with-binary-predictors-feols</guid>
      <pubDate>Mon, 01 Jul 2024 12:33:12 GMT</pubDate>
    </item>
    <item>
      <title>为什么均匀分布会有差异？[关闭]</title>
      <link>https://stats.stackexchange.com/questions/650256/why-there-is-variation-in-uniform-distribution</link>
      <description><![CDATA[为什么均匀分布会有差异？但在整个定义范围内，其概率是相同的。]]></description>
      <guid>https://stats.stackexchange.com/questions/650256/why-there-is-variation-in-uniform-distribution</guid>
      <pubDate>Mon, 01 Jul 2024 12:32:38 GMT</pubDate>
    </item>
    <item>
      <title>工厂零件的预测性维护</title>
      <link>https://stats.stackexchange.com/questions/650243/predictive-maintenance-of-factory-parts</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/650243/predictive-maintenance-of-factory-parts</guid>
      <pubDate>Mon, 01 Jul 2024 09:36:01 GMT</pubDate>
    </item>
    <item>
      <title>使用已知协方差矩阵的特征向量将收益分解为系统成分和特殊成分</title>
      <link>https://stats.stackexchange.com/questions/650239/decomposing-returns-into-systematic-and-idiosyncratic-components-using-eigenvect</link>
      <description><![CDATA[我正在研究一个因子模型，其中股票收益由以下方程给出：
$r=\beta^Tf+\epsilon$
其中

$r$ 是收益的 n 维向量
$f$ 是因子收益的 k 维向量
$\beta$ 是因子载荷的 n x k 矩阵
$\epsilon$ 是特异收益的 n 维向量

我有一个已知的收益协方差矩阵 $\Omega$，是根据已知的 beta 和因子协方差以及对角线特定风险创建的。
$\Omega = \beta \Omega_f \beta^T + \Omega_\epsilon$
我还从 beta 和因子协方差（形成已知的系统成分）以及股票特定风险（形成已知的特殊成分）生成了一些随机数据 X。
我的目标是将收益分解为系统成分和特殊成分，但我只知道 $\Omega$。我不知道 $\beta$ 或 $\Omega_f$，也看不到 $f$。
为了实现这一点，我使用了协方差矩阵 $\Omega$ 的前几个特征向量 Q。使用这些随机数据进行的实验表明，X.Q.Q’ 是收益系统性成分的良好近似值。
但是，X.Q.Q’ 并不能完美地产生已知的系统性收益。我理解这是因为 $Q$ 和 $\beta$ 不是一回事。然而，由于分解是一个很好的近似值，因此它们显然是相关的。
我的问题是，是否有任何方法可以计算给定 $\Omega$ 的近似优度期望（类似 $R^2$）？
演示分解的示例代码
set.seed(123)
n_secs &lt;- 50
n_factor &lt;- 7

beta &lt;- runif(n = n_secs * n_factor) |&gt; matrix(ncol = n_factor)

factor_var &lt;- runif(n = n_factor, min = 0.5) |&gt; diag()

common_risk &lt;- beta %*% factor_var %*% t(beta)

specific_vars &lt;- runif(n = n_secs, min = 0.2, max = 0.4) * 10

covar &lt;- common_risk + diag(specific_vars)

n_days &lt;- 1000

factor_returns &lt;- MASS::mvrnorm(n = n_days, Sigma = factor_var, mu = rep(0, n_factor))
systematic_returns &lt;- factor_returns %*% t(beta)
idio_returns &lt;- sapply(1:n_secs, \(i_sec)rnorm(n = n_days, sd = sqrt(specific_vars[i_sec])))
returns = systems_returns + idio_returns

evv &lt;- eigen(covar)
zv &lt;- evv$vectors[,1:n_factor, drop = FALSE]

est_syst_returns_v &lt;- returns %*% zv %*% t(zv)

plot(systematic_returns[,1], est_syst_returns_v[,1], asp = 1)
abline(a = 0, b = 1, col = &quot;blue&quot;)

估计的系统收益与已知的系统收益有很好的近似值，但并不完美。我可以估计给定 $\Omega$ 的近似值有多好吗？即使我无法进行此估计，我至少可以使用一些分析论证来证明这种转换的合理性吗？我现在所拥有的只是上述经验/数值实验。
]]></description>
      <guid>https://stats.stackexchange.com/questions/650239/decomposing-returns-into-systematic-and-idiosyncratic-components-using-eigenvect</guid>
      <pubDate>Mon, 01 Jul 2024 08:16:30 GMT</pubDate>
    </item>
    <item>
      <title>导出 $k_i$ 以获得 $\hat{\beta} = \sum_{i=1}^n k_i y_i$，其中 $\hat{\beta}$ 是 OLS 估计量</title>
      <link>https://stats.stackexchange.com/questions/650226/deriving-k-i-for-hat-beta-sum-i-1n-k-i-y-i-where-hat-beta-is-t</link>
      <description><![CDATA[此问题与此帖子相关：证明截距的 OLS 估计量为 BLUE
由于我还不能直接在原始帖子下发表评论，所以我在这里发布我的问题。
在原始帖子中，回归模型定义为 $y_i = \alpha + \beta x_i + u_i$，而 $\beta$ 的 OLS 估计量自然表示为 $\hat{\beta}$。
然后 $\hat{\beta}$ 进一步定义为线性组合，形式为 $\hat{\beta} = \sum_{i=1}^n k_i y_i$，其中 $k_i = \frac{x_i - \bar{x}}{\sum_{i=1}^n (x_i - \bar{x})^2}$。
我假设 $\hat{\beta}=\frac{\sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n (x_i - \bar{x})^2}$，我想知道 $k_i$ 是从所述线性组合直接得出的。]]></description>
      <guid>https://stats.stackexchange.com/questions/650226/deriving-k-i-for-hat-beta-sum-i-1n-k-i-y-i-where-hat-beta-is-t</guid>
      <pubDate>Mon, 01 Jul 2024 00:51:52 GMT</pubDate>
    </item>
    </channel>
</rss>