<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Thu, 22 Aug 2024 01:09:24 GMT</lastBuildDate>
    <item>
      <title>关于使用软件功效和样本量计算的问题</title>
      <link>https://stats.stackexchange.com/questions/653147/questions-about-use-software-power-and-sample-size-calculation</link>
      <description><![CDATA[我正在使用功效和样本量计算来计算两组之间跌倒风险比的样本量
在独立的前瞻性环境中，我需要输入实验对象相对于对照组的相对失败风险 (R)。
这里的相对失败风险是什么意思？
例如，对照组的跌倒改善率为 0.3，干预组为 0.5。
这里的比率是指 0.5/0.3，还是 (1-0.5) / (1-0.3)？
]]></description>
      <guid>https://stats.stackexchange.com/questions/653147/questions-about-use-software-power-and-sample-size-calculation</guid>
      <pubDate>Thu, 22 Aug 2024 00:49:44 GMT</pubDate>
    </item>
    <item>
      <title>贝塔回归模型参数估计值的解释</title>
      <link>https://stats.stackexchange.com/questions/653143/interpretation-of-parameter-estimates-from-a-beta-regression-model</link>
      <description><![CDATA[我在 R 中使用 beta 回归模型。我将用模拟数据进行说明，以便理解解释。假设结果变量称为 outcome，其范围在 0 和 1 之间。我还有两个协变量：treatment，其有 3 个类别（A、B 和 C）和使用标准正态分布模拟的 iq。我的目标是调查结果和协变量之间是否存在关联。
用于模拟数据的 R 代码：
set.seed(1)
mydata = data.frame(outcome=runif(100),treatment = factor(sample(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),100,replace=TRUE)),iq=rnorm(100))

然后我们可以使用 betareg 函数拟合 beta 回归模型。
library(betareg)
library(tidyverse)
library(dplyr)
library(marginaleffects)
library(ggeffects)
library(ordbetareg)
library(knitr)
library(parameters)

model_beta = betareg(outcome~factor(treatment)+iq | factor(treatment)+iq,
data=mydata,link=&quot;logit&quot;)
summary(model_beta)

模型摘要如下。我理解有两个不同的部分：一个用于均值模型，另一个用于精度模型。由于我们使用了 logit 链接，因此估计值是对数几率估计。
第一个问题：我可以从以下输出中做出推断吗？我可以解释为“如果 iq 增加 1 个单位，则 .......
调用：
betareg(formula = consequence ~ factor(treatment) + iq | factor(treatment) + iq, data = mydata, link = &quot;logit&quot;)

标准化加权残差 2：
最小值 1Q 中位数 3Q 最大值 
-2.5729 -0.5849 0.0389 0.6002 2.0709 

系数（带 logit 链接的均值模型）：
估计标准差。误差 z 值 Pr(&gt;|z|) 
(截距) -0.02176 0.17159 -0.127 0.899 
因子(治疗)B -0.13444 0.26595 -0.506 0.613 
因子(治疗)C 0.24357 0.26630 0.915 0.360 
iq -0.19714 0.11071 -1.781 0.075 .

Phi 系数（带对数链接的精度模型）：
估计标准差。误差 z 值 Pr(&gt;|z|) 
(截距) 0.99059 0.20671 4.792 1.65e-06 ***
因子(治疗)B -0.68443 0.28269 -2.421 0.0155 * 
因子(治疗)C -0.12546 0.31100 -0.403 0.6867 
iq 0.07665 0.11955 0.641 0.5214 
---
有效代码: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 

估计量类型：ML（最大似然）
对数似然：8 Df 上的 6.014
伪 R 平方：0.04711
迭代次数：30（BFGS）+ 1（Fisher 评分）

但是，我也遇到了类似以下的输出（概率差异）。
 #get difference
avg_comparisons(model_beta)%&gt;%
kable()

输出如下。
|term |contrast |estimate|std.error|statistic|p.value|s.value|conf.low|conf.high|predicted_lo|predicted_hi|predicted|
|:---------|:-----------------|-----------:|---------:|-----------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|
|iq |平均值(+1) | -0.0483355| 0.0264920| -1.8245311| 0.0680718| 3.8767987| -0.1002589| 0.0035879| 0.4774381| 0.4286290| 0.4774381|
|治疗 |平均值(B) - 平均值(A) | -0.0332144| 0.0656963| -0.5055740| 0.6131557| 0.7056745| -0.1619768| 0.0955481| 0.5110320| 0.4774381| 0.4774381|
|treatment |mean(C) - mean(A) | 0.0600606| 0.0653734| 0.9187318| 0.3582359| 1.4810184| -0.0680689| 0.1881902| 0.5110320| 0.5714338| 0.4774381|

第二个问题：我可以使用上述输出进行推断吗？我理解上表中的估计值是概率的差异。我可以说以下吗？

如果 iq 增加 1 个单位，则在保持其他变量不变的情况下，结果的概率会降低 4.83%。
在保持其他变量不变的情况下，治疗 = C 与治疗 = A 的结果概率增加 6%。

第三个问题：还有其他简单的解释吗？
第四个问题：如果我的数据中 结果 变量中有 0 和 1，该怎么办？我发现我们可以使用零一膨胀贝塔回归模型？任何有关 R 的帮助都将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/653143/interpretation-of-parameter-estimates-from-a-beta-regression-model</guid>
      <pubDate>Wed, 21 Aug 2024 21:23:33 GMT</pubDate>
    </item>
    <item>
      <title>推导 Fisher 的神秘估计量来应对未知物种问题</title>
      <link>https://stats.stackexchange.com/questions/653142/deriving-fishers-mysterious-estimator-for-the-unseen-species-problem</link>
      <description><![CDATA[摘自维基百科：

20 世纪 40 年代初，亚历山大·史蒂文·科贝特 (Alexander Steven Corbet) 在英国马来亚花了两年时间捕捉蝴蝶。他记录了观察到的蝴蝶种类，以及捕获了每种蝴蝶的数量。例如，他捕获了 74 种不同的蝴蝶，但只捕获了 2 只。
当 Corbet 回到英国时，他找到了生物统计学家 Ronald Fisher，询问他如果再捕捉两年，可以捕获多少种新蝴蝶；实际上，Corbet 是在问他观察到了多少种零次的蝴蝶。
Fisher 给出了一个简单的估计：再捕捉两年，Corbet 可以捕获 75 种新蝴蝶。他使用一个简单的求和方法做到了这一点：

取你发现的奇数物种数量，然后从中减去你发现的偶数物种数量。
维基百科文章引用了这篇论文，但并未提供证明。该论文引用了 Fisher、Corbet 和 Williams 于 1943 年撰写的这篇论文，但我没有在其中看到任何与该公式类似的内容。维基百科文章还引用了Good 和 Toulmin 的这篇论文来证实 Fisher 的和，但它也不存在。
我对这个估计量感到非常困惑。]]></description>
      <guid>https://stats.stackexchange.com/questions/653142/deriving-fishers-mysterious-estimator-for-the-unseen-species-problem</guid>
      <pubDate>Wed, 21 Aug 2024 21:18:59 GMT</pubDate>
    </item>
    <item>
      <title>最大化某个平均值机会的最小数字</title>
      <link>https://stats.stackexchange.com/questions/653138/minimum-number-to-maximize-the-chance-of-a-certain-average</link>
      <description><![CDATA[解决以下问题的方法是什么。
在测试中，每个问题的答案都会得到 0 到 100 之间的分数（含 0 和 100）。从长远来看，我的平均成绩是 60，这是既定事实。如果测试包含无数个问题，我的平均成绩将接近 60。对于给定的问题，我可能会得到 0 到 100 之间的任何分数。
问题 1：假设出于某种原因我需要 70 的平均成绩。要使我的平均成绩达到 70，最少需要回答多少个问题？
问题 2：第一个问题我的得分是 20。现在，要使我的平均成绩达到 70，最少需要回答多少个问题？]]></description>
      <guid>https://stats.stackexchange.com/questions/653138/minimum-number-to-maximize-the-chance-of-a-certain-average</guid>
      <pubDate>Wed, 21 Aug 2024 19:40:35 GMT</pubDate>
    </item>
    <item>
      <title>GraphPad Prism 中的 Friedman 检验存在问题</title>
      <link>https://stats.stackexchange.com/questions/653137/issue-with-friedman-test-in-graphpad-prism</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/653137/issue-with-friedman-test-in-graphpad-prism</guid>
      <pubDate>Wed, 21 Aug 2024 19:39:49 GMT</pubDate>
    </item>
    <item>
      <title>R lmer 帮助理解我的混合模型输出</title>
      <link>https://stats.stackexchange.com/questions/653130/r-lmer-help-understanding-my-mixed-model-output</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/653130/r-lmer-help-understanding-my-mixed-model-output</guid>
      <pubDate>Wed, 21 Aug 2024 15:49:36 GMT</pubDate>
    </item>
    <item>
      <title>使用引导法比较两种治疗方法时 P 值为 0</title>
      <link>https://stats.stackexchange.com/questions/653127/p-value-of-0-when-comparing-two-treatments-using-bootstrap-method</link>
      <description><![CDATA[我正在比较两种治疗方法，并进行 t 检验或 Wilcoxon 检验，我得到的 p 值 为 2.2e-16。
我想尝试引导，因为样本很大（超过 1000 个样本）并且长度不相等（300 个样本差异）。但是，当我尝试在 Rstudio 中运行此代码时，我将得到 p 值 为 0。这难道不是表明没有大于观察到的差异的值吗？这是否在告诉我，两种治疗方法是如此不同，以至于我甚至无法从比较中获得 p 值？
这是我正在运行的脚本的示例，数据集是虚拟数据，而不是实际数据，但它将导致相同的 p 值=0
set.seed(123)

# 虚拟数据集
dataset1 &lt;- rnorm(100, mean = 10, sd = 2)
dataset2 &lt;- rnorm(100, mean = 15, sd = 2)

combined_df &lt;- data.frame(
value = c(dataset1, dataset2),
group = factor(c(rep(&quot;Group1&quot;, length(dataset1)), rep(&quot;Group2&quot;, length(dataset2))))
)

# 数量观察值
n &lt;- length(combined_df$value)
# bootstrap 迭代次数
B &lt;- 10000

# Bootstrap
variable &lt;- combined_df$value
boots &lt;- matrix(sample(variable, size=n*B, replace=TRUE), nrow=n, ncol=B)

bootstat1 &lt;- numeric(B) # 表示平均差异
bootstat2 &lt;- numeric(B) # 表示中位数差异

# 观察到的差异
observed_means_diff &lt;- abs(mean(dataset1) - mean(dataset2))
observed_medians_diff &lt;- abs(median(dataset1) - median(dataset2))

# 循环计算 bootstrap 统计数据
for (i in 1:B) {
boot_sample &lt;- boots[, i]
bootstat1[i] &lt;- abs(mean(boot_sample[1:100]) - mean(boot_sample[101:200]))
bootstat2[i] &lt;- abs(median(boot_sample[1:100]) - median(boot_sample[101:200]))
}

# 计算 p 值
p_value_mean &lt;- mean(bootstat1 &gt;= perceived_means_diff)
p_value_median &lt;- mean(bootstat2 &gt;= perceived_medians_diff)

非常感谢您帮助我了解这里发生的事情]]></description>
      <guid>https://stats.stackexchange.com/questions/653127/p-value-of-0-when-comparing-two-treatments-using-bootstrap-method</guid>
      <pubDate>Wed, 21 Aug 2024 15:31:32 GMT</pubDate>
    </item>
    <item>
      <title>如何正确报告交叉验证的结果，特别是标准差</title>
      <link>https://stats.stackexchange.com/questions/653125/how-to-properly-report-results-from-cross-validation-specifically-standard-devi</link>
      <description><![CDATA[这似乎是一个标准问题，但不幸的是，我还没有找到任何好的解释资源。
所以，我的情况如下。我想评估一个机器学习模型并报告其对未见数据的准确性。由于我的数据集非常小，我采用交叉验证。
一旦我获得了所有折叠的准确度值，我想报告这些值的平均值和标准差。
但是，互联网上的几个来源并不直接报告标准差。相反，他们倾向于先将标准差除以折叠数的平方根。
我没有找到任何关于为什么这样做的理由。]]></description>
      <guid>https://stats.stackexchange.com/questions/653125/how-to-properly-report-results-from-cross-validation-specifically-standard-devi</guid>
      <pubDate>Wed, 21 Aug 2024 15:27:19 GMT</pubDate>
    </item>
    <item>
      <title>根据样本预测唯一观测值总数 - R</title>
      <link>https://stats.stackexchange.com/questions/653120/predict-total-unique-observations-based-on-sample-r</link>
      <description><![CDATA[我有一组包含 N 个唯一元素的数据，这些元素可以重复任意次以得到 X 个总元素。
N 和 X 的值未知。
我有此数据的样本，并计算了样本总大小和样本中唯一元素总数。
为了了解样本的结构，我以一系列样本大小重复进行了子样本抽样，没有进行替换，并计算了唯一元素。
绘制于此处：

（红色 = 总样本，黑色 = 下采样。每个可见黑点实际上是 20 个重复）。
由此，我想在 R 中拟合一条超出 x 的观测值的曲线，以预测 y 的最大值（例如：数据集中唯一元素的总数，N）。
样本中的元素总数：185718411
样本中的唯一元素总数：51588754
下采样数据：
x=c(1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 1e+07, 2.5e+07, 2.5e+07, 2.5e+07, 
2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 
2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 
2.5e+07, 2.5e+07, 2.5e+07, 2.5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 
5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 
5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 
7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 
7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 
7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 
7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 7.5e+07, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 
1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 
1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1e+08, 1.25e+08, 1.25e+08, 
1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08,
1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 
1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.25e+08, 1.5e+08, 1.5e+08, 
1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 
1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.5e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08 , 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 1.75e+08, 
1.75e+08, 1.75e+08) y=c(8879407L, 8882853L, 8879146L, 8879963L, 8879973L, 8877565L, 8879535L, 8879441L, 8881377L, , 8880186L, 8879063L, 8881647L, 8879511L, 8881403L, 8878382L, 8879544L, 8881002L, 8880604L, 8880240L, 18927193L, 18924435L、18923731L、18920494L、18923974L、18923199L、18923360L、18923648L、18923131L、18922984L、18926592L、18924276L、1 8923680L、18923344L、18926252L、18921600L、18924428L、18928711L、18925935L、18922126L、30157610L、30155501L、30158640L、 30159612L, 30158025L, 30157679L, 
30154834L, 30159222L, 30160493L, 30157565L, 30158045L, 30157807L, 
30155821L, 30155840L, 30158622L, 30159742L, 30161088L, 30158046L, 
30159089L, 30155885L, 37409984L, 37400952L, 37402514L, 37408682L, 
37404248L, 37403547L、37401649L、37407739L、37405915L、37407328L、37402003L、37408206L、37398749L、37406762L、37401890L、37406383L、3 7404693L、37409054L、37403259L、37405316L、42387997L、42386810L、42386963L、42390976L、42390837L、42387186L、42387391L、 42385265L、42383010L、42392749L、42390451L、42390822L、42389636L、42389803L、42385593L、42390989L、42386302L、42389008L、4 2390049L、42386454L、45991832L、45992758L、45991351L、45993242L、45993277L、45990663L、45992366L、45992018L、45994867L、 45996211L、45992212L、45991838L、45991638L、45992517L、45993411L、45993444L、45992878L、45993934L、45993354L、45993045L、4 8707677L、48710261L、48705408L、48705354L、48706640L、48708658L、48708765L、48708926L、48707986L、48709516L、48705780L、 48708451L, 48707766L, 48711356L, 48708200L, 48707612L, 
48708961L, 48707509L, 48708770L, 48706288L, 50821205L, 50820451L, 
50819444L, 50821245L, 50821327L, 50820153L, 50819789L, 50821493L, 
50821043L, 50819115L, 50821689L, 50821538L, 50821014L, 50819974L, 
50821665L, 50819515L, 50820771L, 50819985L, 50820110L, 50819491L, 
51588754L)

我认为曲线的形状符合渐近回归，我研究过各种拟合方法，但我认为这并不是我想要的。
我知道对样本进行下采样并不等同于重复采样 - 但这是我所能获得的全部。因此，我必须基于（有效）假设，即考虑到样本的大小和重复的一致性，样本可以代表整个数据集。
我想对许多不同的数据集重复此操作，因此正在寻找一种可以一致应用的方法。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/653120/predict-total-unique-observations-based-on-sample-r</guid>
      <pubDate>Wed, 21 Aug 2024 14:21:44 GMT</pubDate>
    </item>
    <item>
      <title>回归模型与配对 t 检验比较，但方差膨胀</title>
      <link>https://stats.stackexchange.com/questions/653118/regression-models-comparison-with-paired-t-test-but-inflated-variance</link>
      <description><![CDATA[我有 2 个依赖数据集 D1 和 D2，我用它们在嵌套交叉验证中训练和评估回归模型，该模型具有 L 外循环。对于每个循环，我使用皮尔逊相关性评估模型，因此为每个数据集提供了 L 皮尔逊相关系数。
然后，我用配对 t 检验评估了 2 个模型是否给出了不同的结果（即皮尔逊相关性差异是否平均不同于 0？），但我得到的结果不显著，而我实际上知道 D2 应该给出更高的结果。问题是 D2 产生的模型为 L 皮尔逊相关性增加了更多可变性。我认为方差是由另一个因素引起的，但测试该假设并重新训练模型不是一种选择，主要是因为这会花费太多时间。
那么，是否有任何方法可以运行配对 t 检验并解决此类问题？我已阅读有关使用 L 皮尔逊相关性来获取参数估计，或对其应用 收缩 系数来减少方差的文章。但我不确定这些方法是否真的合适（以及如何应用它们）或者是否有更好的选择？
编辑：从 wzbillings 的评论来看，这确实是我真正需要的置信区间，但可以考虑到方差膨胀问题。]]></description>
      <guid>https://stats.stackexchange.com/questions/653118/regression-models-comparison-with-paired-t-test-but-inflated-variance</guid>
      <pubDate>Wed, 21 Aug 2024 13:46:33 GMT</pubDate>
    </item>
    <item>
      <title>因变量零值，数据正确结构，零膨胀模型</title>
      <link>https://stats.stackexchange.com/questions/653115/zero-values-in-dependent-variable-correct-structure-of-the-data-zero-inflate</link>
      <description><![CDATA[我想了解宏观经济变量与特定基金（二级基金）募资量之间的关系。
我得到了以下数据集（假设一个表格：
1.
基金名称：
Abbott Secondary Opportunities III LP
募资日期：
06/2024
基金规模：
6200 万
2.
基金名称：
ABS Ventures VI, L.P.
募资日期：
01/2004
基金规模：
6400 万
...
我得到了 2000 年至 2024 年之间的 200 只其他基金。
作为独立变量，我选择了特定时期的利率水平、通货膨胀率、GDP 指数、IPO 数量和 sp500 指数。例如，我查找了 2024 年 6 月和 2004 年 1 月的利率水平以及另外 200 只基金的利率水平2000 年至 2024 年之间。
现在我不知道应该使用哪种类型的回归以及如何构建我的回归。
如果我进行月度回归，我将有 150 个零观测值作为因变量，因为根据数据，每个月都没有筹款，而有些基金在同一时期正在筹集资金。例如，对于 2024 年 6 月，我的因变量将是 6200 万，但对于 2024 年 5 月可能为零……
我可以删除零吗？我可以使用零膨胀模型吗？但我不知道您是否将这些数据视为计数数据？
或者建议使用以下结构？
我只包括获得筹款信息的月份（筹款&gt; 0），因此在这种情况下，我会直接从 06/2024 跳到 01/2004，因为在这两者之间它将是零（当然这个例子是夸张的，这两者之间有资金但不是每个月......）]]></description>
      <guid>https://stats.stackexchange.com/questions/653115/zero-values-in-dependent-variable-correct-structure-of-the-data-zero-inflate</guid>
      <pubDate>Wed, 21 Aug 2024 13:07:38 GMT</pubDate>
    </item>
    <item>
      <title>当风险差异如此容易解释时，为什么 Cohen's h 对于比较比例有用？</title>
      <link>https://stats.stackexchange.com/questions/653098/why-is-cohens-h-useful-to-compare-proportions-when-risk-difference-is-so-interp</link>
      <description><![CDATA[当风险差异如此易于解释时，为什么 Cohen&#39;s h 可用于比较比例？
我认为这与标准化不同比例量级的比较有关（例如，当 $p_{1}$ 和 $p_{2}$ 分别接近 0、接近 0.5 和接近 1 时，$p_{1}-p_{2}$）。
但我很难在脑海中将其形式化。]]></description>
      <guid>https://stats.stackexchange.com/questions/653098/why-is-cohens-h-useful-to-compare-proportions-when-risk-difference-is-so-interp</guid>
      <pubDate>Wed, 21 Aug 2024 05:46:44 GMT</pubDate>
    </item>
    <item>
      <title>优化正定矩阵的简单问题</title>
      <link>https://stats.stackexchange.com/questions/653090/simple-problem-of-optimizing-a-positive-definite-matrix</link>
      <description><![CDATA[我正在编写一个关于约束优化的简单教程。我计划使用两个示例：约束一个向量具有单位范数，约束一个矩阵为对称正定矩阵。我想用合成数据来提供一些此类优化的非常简单的示例。
例如，对于单位范数约束，我生成单位圆上分布的随机样本，然后优化一个向量 $\theta$，以最小化到样本的平均平方距离。当不约束 $\theta$ 时，结果不在单位圆内，而添加约束后，我们得到一个在单位圆内的 $\theta$。
我试图想出一个同样简单直观的问题，涉及优化某个应该是正定的矩阵 $\Sigma$。但是，我想不出任何简单明了的东西。例如，如果我们想按照上述方法操作并找到最小化与一组正定矩阵的距离的矩阵，则不受约束的结果将是正定的。我曾考虑过使用一个损失函数将 $\Sigma$ 推向非 SPD 矩阵，但我认为优化过程不会收敛。
因此，我的问题是，矩阵 $\Sigma$ 上的一些简单的、表现良好的优化问题是什么，直观地了解我们为什么要让它是正定的，以及如果我们在优化中不包含约束，它在哪里不会是正定的？我希望能够在我的教程中用不太多的代码为我的问题合成数据。
编辑：我实现了答案中建议的示例。在此处查看结果 https://dherrera1911.github.io/posts/2024/08/constrained-learning-with-pytorch-parametrizations/]]></description>
      <guid>https://stats.stackexchange.com/questions/653090/simple-problem-of-optimizing-a-positive-definite-matrix</guid>
      <pubDate>Tue, 20 Aug 2024 22:33:09 GMT</pubDate>
    </item>
    <item>
      <title>准确计算截断二项式期望</title>
      <link>https://stats.stackexchange.com/questions/653081/compute-a-truncated-binomial-expectation-accurately</link>
      <description><![CDATA[我需要计算二项式随机变量的以下期望值
$$E_{S \sim \rm{Binom}(\frac{k}{M}; N)} \left[\left(\frac{k-1}{k}\right)^S 1_{\{S \leq k\}}\right] = \sum_{s=0}^k \binom{N}{s} \left(\frac{k}{M}\right)^s \left(1 - \frac{k}{M}\right)^{N-s} \left(\frac{k-1}{k}\right)^s.$$
变量的典型范围是 $0 &lt; k \leq 256$，$M = N = 10^9$。如果 $k = N$，则可以使用二项式 RV 的独立伯努利分解来很好地评估。如果不存在 $\left(\frac{k-1}{k}\right)^s$ 项，则这是二项式的累积分布函数，等于不完全 Beta 积分，并且在数值上相当稳定。但是，如何以数值稳定的方式处理上述混合公式？我不需要它很快，只需要给我合理的数字而不是 nan 或类似的数字 $&gt; 1$.
更新：为了完整性，总和可以用超几何函数重写
$$\sum_{s=0}^k \binom{N}{s} p^s q^{N-s} = q^N\left((1 + p/q)^N - (p/q)^{k+1} \binom{N}{k+1} {}_2F_1(1, k-N + 1; k + 2; -p/q)\right),$$
其中
\begin{align*}
{}_2F_1(a, b; c; z) := \sum_{n=0}^\infty \frac{(a)_n(b)_n}{(c)_n} \frac{z^n}{n!}.
\end{align*}
但是对于非常大的 $N$，这会导致数字溢出。总和在 $n &gt; N - k + 1$ 之后终止，但不值得用 $k+1$ 项的总和与具有更多项的总和进行权衡。]]></description>
      <guid>https://stats.stackexchange.com/questions/653081/compute-a-truncated-binomial-expectation-accurately</guid>
      <pubDate>Tue, 20 Aug 2024 20:03:48 GMT</pubDate>
    </item>
    <item>
      <title>“重复测量方差分析” vs “以受试者为随机效应的方差分析” vs “以受试者为随机效应的重复测量方差分析”</title>
      <link>https://stats.stackexchange.com/questions/653051/repeated-measures-anova-vs-anova-with-subject-as-random-effect-vs-repeated</link>
      <description><![CDATA[运行重复测量方差分析（对每个受试者随时间重复测量）与以受试者为随机效应的方差分析之间有什么区别？`
我也看到过提到“以受试者为随机效应的重复测量方差分析”。
对于上下文，我有 6 个组和每个组/受试者 3 个基线后时间点。每个受试者都是一个组的成员。我想比较同一时间点的两个不同组的平均值（例如，时间点 B 的组 1 与组 3）以及不同时间点的同一组的平均值（例如，时间点 B 的组 1 与时间点 C 的组 1）。
我将使用 ls-means 来比较均值，但我真的不明白上述三个模型类别之间的区别。如果有区别的话！
非常感谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/653051/repeated-measures-anova-vs-anova-with-subject-as-random-effect-vs-repeated</guid>
      <pubDate>Tue, 20 Aug 2024 13:42:20 GMT</pubDate>
    </item>
    </channel>
</rss>