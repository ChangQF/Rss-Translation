<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Wed, 20 Nov 2024 01:18:49 GMT</lastBuildDate>
    <item>
      <title>确定在随机抽样的情况下样本实际上来自两个不同集合的可能性</title>
      <link>https://stats.stackexchange.com/questions/657534/determine-the-likelihood-given-random-sampling-that-your-samples-are-actually-co</link>
      <description><![CDATA[在大多数实验中，您都有一个对照组和一个实验组。在研究结束时，您将进行 t 检验或类似测试，以确定两个群体之间是否存在显著差异。这是大多数研究的基础。
在盲测的情况下，有没有办法通过随机抽样来引导，而无需知道样本来自哪个组，以回答以下问题：
一旦揭盲，如果存在真正的差异，是否可以检测到？例如，变异是否足够紧密，以至于一旦揭盲，您甚至可以做出判断？]]></description>
      <guid>https://stats.stackexchange.com/questions/657534/determine-the-likelihood-given-random-sampling-that-your-samples-are-actually-co</guid>
      <pubDate>Wed, 20 Nov 2024 00:43:14 GMT</pubDate>
    </item>
    <item>
      <title>重新调整对数正态先验以进行贝叶斯拟合</title>
      <link>https://stats.stackexchange.com/questions/657533/rescaling-a-lognormal-prior-for-a-bayesian-fit</link>
      <description><![CDATA[我正在使用贝叶斯方法拟合非线性回归，我有一个问题，我认为它很简单，但现在我对此感到困惑。
假设我们正在拟合一个非线性函数$\eta (x_i; \theta)$，其中$\theta$是要拟合的参数。此外，$\theta$的先验是对数正态的：$\theta \sim \textrm{Lognormal}(\mu,\sigma^2)$。现在我重新调整$\theta$的先验，使得先验分布的新均值为 1，方差保持不变。因此，我们有了一个新的参数 $\theta&#39;\sim \textrm{Lognormal}(\mu&#39;,\sigma&#39;^2)$。我们可以使用 此链接 中的函数在 $\theta$ 和 $\theta&#39;$ 之间来回切换：
$$
\theta&#39; = f(\theta) \\
\theta = f^{-1}(\theta&#39;)
$$
函数 $f(\theta)$ 在上面链接中明确定义，但函数的细节对我的问题并不重要。然后，我拟合函数 $\eta&#39;(x_i; \theta&#39;)$，使得 $\eta&#39;(x_i; \theta&#39;) = \eta(x_i; \theta = f^{-1}(\theta&#39;))$。本质上，我从 $\theta&#39;$ 中提取先验值，但将其反向转换为 $\theta$，作为新函数 $\eta&#39;$ 的一部分。实际上，这让我能够用真实参数值拟合原始函数 $\eta$，同时从均值为 1 的重新缩放先验中抽取。然后，我从该模型的贝叶斯拟合中获得后验估计。
我的问题是：给定后验抽取，我可以简单地使用函数 $f^{-1}(\theta&#39;)$ 来取回真实参数吗？我的第一个想法是可以的，但后来我意识到真实先验分布 $\theta$ 和重新缩放先验分布 $\theta&#39;$ 之间的转换 $\theta&#39; = f(\theta)$ 假设这两个分布都是对数正态的。因此，如果我将后验抽取的结果输入到转换函数 $f^{-1}$ 中，我本质上假设后验分布是对数正态的，但这不一定正确。通过在后验抽取中使用 $f^{-1}$，我还假设它实际上来自重新缩放的先验分布 $\theta&#39;$，并且我将其转换为在原始先验分布 $\theta$ 下具有相同概率的数字。所有这些似乎都与后验抽取有关。我能感觉到我的推理在某些地方存在缺陷，但我不知道在哪里。欢迎任何帮助，不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/657533/rescaling-a-lognormal-prior-for-a-bayesian-fit</guid>
      <pubDate>Wed, 20 Nov 2024 00:27:10 GMT</pubDate>
    </item>
    <item>
      <title>平均值标准误差的传播</title>
      <link>https://stats.stackexchange.com/questions/657532/propagation-of-the-standard-error-of-the-mean</link>
      <description><![CDATA[假设我有随机变量$x$、$y$，并且我有一个这些随机变量的函数$f(x,y)$。假设 $x$ 和 $y$ 是独立的，我可以使用误差传播来计算 $f$ 的标准差，$\sigma_f$:
$$\sigma_f\approx\sqrt{\left(\frac{\partial f}{\partial x}\right)^2\sigma_x^2 + \left(\frac{\partial f}{\partial y}\right)^2\sigma_y^2}$$
但是，假设我对平均值的标准误差感兴趣（$s=\sigma/\sqrt{N}$) 来代替。假设我尝试测量 $x$、$y$ 的分布，并分别取 $N_x$ 和 $N_y$ 个数据点。那么我可以简单地用标准差代替标准误差吗，即，以下情况是否也正确
$$s_f\approx\sqrt{\left(\frac{\partial f}{\partial x}\right)^2s_x^2 + \left(\frac{\partial f}{\partial y}\right)^2s_y^2}$$
其中$s_x=\sigma_x/\sqrt{N_x}$，$s_y=\sigma_y/\sqrt{N_y}$？有没有对此进行有力的证明，并且鉴于我没有用 $N_f$ 个数据点直接测量 $f$，那么 $f$ 的平均值的标准误差意味着什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/657532/propagation-of-the-standard-error-of-the-mean</guid>
      <pubDate>Tue, 19 Nov 2024 22:17:09 GMT</pubDate>
    </item>
    <item>
      <title>确定预测模型的置信阈值</title>
      <link>https://stats.stackexchange.com/questions/657531/determining-confidence-threshold-for-a-predictive-model</link>
      <description><![CDATA[我有一个模型，其准确率为 $A$。它对许多样本做出 $Y$ 置信度的预测。样本被观察多次，但并非所有样本的观察结果都是相同的。所以我的数据如下所示：
模型准确率 (A) 模型预测置信度 (Y) 样本 ID
0.80 0.90 1
0.80 0.95 1
0.80 0.70 1
0.80 0.88 2
0.80 0.92 2
0.80 0.80 3
0.80 0.93 4
0.80 0.85 4
0.80 0.60 4
0.80 0.97 4

我想将我的分析限制在 95% 确定是真实的样本上。如果我将模型预测严格过滤为高于确定的$X$，我必须观察一个样本多少次才能让它落入这个范围内。
我的想法是，如果我喜欢$X$，我的数据中就会有更多的样本，因此尽管我对它们不太有信心，但也许这被我对更大数字的信心所抵消了？
我无法引导模型。
谢谢你的帮助。]]></description>
      <guid>https://stats.stackexchange.com/questions/657531/determining-confidence-threshold-for-a-predictive-model</guid>
      <pubDate>Tue, 19 Nov 2024 22:09:12 GMT</pubDate>
    </item>
    <item>
      <title>如何处理建立分类模型的重复测量？</title>
      <link>https://stats.stackexchange.com/questions/657530/how-to-deal-with-repeated-measures-for-building-a-classification-model</link>
      <description><![CDATA[我收集了纵向和横断面研究的数据。所有研究都有相似的方面，例如每个数据集都被标记为基线、恶化、治疗、恢复。我想结合所有研究的数据并构建分类模型来发现每个类别的特征。我的问题是：我应该如何处理纵向研究中的个体重复测量？]]></description>
      <guid>https://stats.stackexchange.com/questions/657530/how-to-deal-with-repeated-measures-for-building-a-classification-model</guid>
      <pubDate>Tue, 19 Nov 2024 21:53:52 GMT</pubDate>
    </item>
    <item>
      <title>如何重新表示概率向量，而不使其值超出 [0, 1] 的界限？</title>
      <link>https://stats.stackexchange.com/questions/657526/how-to-re-mean-a-vector-of-probabilities-without-having-values-beyond-the-0-1</link>
      <description><![CDATA[假设我们有一个概率向量 $x$。其平均值为 $\bar{x}$。现在，假设我们想将向量重新平均为 0 到 1 之间的任意值。这是某个给定的比例，$p$。
我想要做的是从 $x$ 转到 $x&#39;$，其中 $\bar{x&#39;} = p$。但是，这些表示概率，因此 $x&#39; \in [0, 1]$ 也需要满足。
一种做法是简单地降低变量的平均数并重新添加 $p$：
$x&#39; = x - \bar{x} + p$
但是，这会强制值低于 0 或高于 1，因此不再表示概率。
另一种做法是将 $x$ 和 $p$ 都带入逻辑空间，在那里重新赋予意义，然后将其带回来。为了简便起见，我使用 $logit$ 作为逻辑函数，使用 $invlogit$ 作为其逆函数：
$x&#39; = invlogit(logit(x) - \overline{logit(x)} + logit(p))$
但是，概率空间中的平均值将不再是 $p$。
如何重新表示概率向量，而不使值超出 [0, 1] 的界限？
以下是 R 中的演示。
remean &lt;- function(x, p) x - mean(x) + p

remean_logit &lt;- function(x, p) {
x &lt;- qlogis(x)
x &lt;- x - mean(x) + qlogis(p)
return(plogis(x))
}

set.seed(1839)
p &lt;- .56
x &lt;- runif(1000)

summary(x) # 平均值为 .497
summary(remean(x, p)) # 平均值正确，但最大值 &gt; 1
summary(remean_logit(x, p)) # 值在 0 和 1 之间，但平均值不正确
]]></description>
      <guid>https://stats.stackexchange.com/questions/657526/how-to-re-mean-a-vector-of-probabilities-without-having-values-beyond-the-0-1</guid>
      <pubDate>Tue, 19 Nov 2024 19:56:55 GMT</pubDate>
    </item>
    <item>
      <title>lmerMod 与 lmerModLmerTest - 有什么区别以及哪个是正确的？</title>
      <link>https://stats.stackexchange.com/questions/657524/lmermod-vs-lmermodlmertest-what-are-the-differences-and-which-is-correct</link>
      <description><![CDATA[我进行了三次试验，想知道试验顺序是否会影响结果。我正在使用 ChatGPT 检查我的工作，发现他们的结果与我的结果存在差异。这是 ChatGPT 中的虚拟代码：
# 加载必要的库
library(lme4)
library(lmerTest)
library(emmeans)

# 定义合成数据集，并为每个试验指定明确的分数
set.seed(123) # 设置可重复性的种子

# 20 个受试者的分数，每个受试者完成 3 次试验
scores &lt;- c(80, 85, 78, # 受试者 1
75, 80, 82, # 受试者 2
84, 79, 81, # 受试者 3
77, 82, 79, # 受试者 4
80, 83, 85, # 受试者 5
79, 78, 76, # 受试者 6
82, 84, 79, # 受试者 7
81, 80, 82, # 受试者 8
78, 80, 84, # 主题 9
82, 81, 83, # 主题 10
79, 78, 77, # 主题 11
84, 87, 89, # 主题 12
83, 85, 84, # 主题 13
82, 81, 83, # 主题 14
80, 79, 82, # 主题 15
78, 80, 81, # 主题 16
85, 88, 87, # 主题 17
79, 82, 80, # 主题 18
81, 82, 85, # 主题 19
84, 85, 86) # 主题 20

# 创建数据集
data &lt;- data.frame(
Subject = rep(1:20, each = 3), # 20 个受试者
Trial = rep(1:3, times = 20), # 三次试验
Score = scores # 定义的分数
)

# 将 Trial 视为数字变量
data$Trial &lt;- as.numeric(data$Trial)

# 将 Trial 视为数字，拟合线性混合效应模型
model_continuous &lt;- lmer(Score ~ Trial + (1 | Subject), data = data)

# 模型摘要
summary(model_continuous)

我得到了不同的输出。我认为这与 lmerMod 和 lmerTest 有关，我不知道如何复制它们的结果。
我的：
REML 拟合的线性混合模型。 t 检验使用 Satterthwaites 方法 [&#39;lmerModLmerTest&#39;]
公式：分数 ~ 试验 + (1 | 主题)
数据：数据

收敛时的 REML 标准：282.2

缩放残差：
最小值 1Q 中位数 3Q 最大值
-1.93939 -0.48327 0.08381 0.51236 1.94184
......
固定效应：
估计标准差误差 df t 值 Pr(&gt;|t|) 
(截距) 80.0833 0.8456 54.7267 94.707 &lt;2e-16 ***
试验 0.7500 0.3157 39.0000 2.376 0.0225 * 

ChatGPT:
REML [&#39;lmerMod&#39;] 拟合的线性混合模型
公式：分数 ~ 试验 + (1 | 主题)
数据：数据

收敛时的 REML 标准：104.7192

缩放残差：
最小 1Q 中位数 3Q 最大
-2.1934 -0.5690 -0.0162 0.5091 2.3361
.....
已修复效果：
估计标准误差 t 值 Pr(&gt;|t|) 
（截距） 80.1000 0.7123 112.48 &lt;2e-16 ***
试验 2.0000 0.6232 3.21 0.0056 ** 

来自 R 文档：
如果生成了有效的 lmer 对象 (lmerMod)，但 Satterthwaite df 所需的计算失败，则返回 lmerMod 对象 - 而不是 lmerModLmerTest 对象。
这是什么意思？哪个是正确的？我怎么知道该使用哪一个？如果需要，如何在 lmerMod 和 lmerModLmerTest 之间切换？]]></description>
      <guid>https://stats.stackexchange.com/questions/657524/lmermod-vs-lmermodlmertest-what-are-the-differences-and-which-is-correct</guid>
      <pubDate>Tue, 19 Nov 2024 19:10:04 GMT</pubDate>
    </item>
    <item>
      <title>当b=1时，如何得到第一类广义Beta（GB1）的分位数函数？</title>
      <link>https://stats.stackexchange.com/questions/657523/how-to-get-quantile-function-of-the-generalized-beta-of-the-first-kind-gb1-whe</link>
      <description><![CDATA[# GB1 分布的 PDF 函数
dgb1 &lt;- function(y, a, p, q) {
density &lt;- (a * y^(a * p - 1) * (1 - y^a)^(q - 1)) / beta(p, q)
return(density)
}

# GB1 分布的 CDF 函数
pgb1 &lt;- function(y, a, p, q) {
return(pbeta(y^a, p, q)) # I_{y^a}(p, q)
}

# GB1 分布的分位数函数
qgb1 &lt;- function(prob, a, p, q) {
return(qbeta(prob, p, q)^(1 / a)) # I^{-1}(p, q)^(1/a)
}

# GB1 分布的随机样本生成函数
rgb1 &lt;- function(n, a, p, q) {
u &lt;- runif(n) # 生成 (0, 1) 中的均匀随机变量
return(qgb1(u, a, p, q)) # 使用分位数函数进行变换
}

这是我的代码，它定义了 GB1 分布的 pdf cdf 和分位数函数（当 b=1 时），但我不知道是否可以直接使用它们（pbeta、qbeta）来生成 pgb1、qgb1、rgb1 这些函数。我尝试证明这是正确的，但结果并不好，我该怎么办？]]></description>
      <guid>https://stats.stackexchange.com/questions/657523/how-to-get-quantile-function-of-the-generalized-beta-of-the-first-kind-gb1-whe</guid>
      <pubDate>Tue, 19 Nov 2024 18:26:13 GMT</pubDate>
    </item>
    <item>
      <title>嵌套交叉验证中的模型选择的统计检验？</title>
      <link>https://stats.stackexchange.com/questions/657519/statistical-tests-for-model-selection-in-nested-cross-validation</link>
      <description><![CDATA[我使用嵌套交叉验证来评估多个模型和超参数配置。在使用不同的随机种子（外部：3 倍，10 个种子，内部：5 倍，50 个种子）运行试验后，我注意到模型 A 在内部循环中始终获胜的概率约为 50%，而其他一些模型在不同试验中的表现也类似。
我想量化模型 A 真正胜过其他模型的可能性，而不仅限于特定的拆分和种子。具体来说：
估计模型 A 表现的概率：
假设模型 A 在内循环中的胜率为 50%，我如何估计它在随机试验中以 &gt;95% 的置信度胜过其他模型的概率？
统计显著性检验：
我可以使用二项式或多项式检验来评估模型 A 在外循环中的表现是否具有统计显著性吗？
考虑试验之间的依赖关系：
由于嵌套的交叉验证折叠不是独立的，我如何处理试验之间的依赖关系？使用多个随机种子是否可以缓解这种情况？
模型选择有效性：
使用这种统计方法进行模型选择是否有效，或者是否会引入偏差，因为外循环结果通常不直接用于选择？]]></description>
      <guid>https://stats.stackexchange.com/questions/657519/statistical-tests-for-model-selection-in-nested-cross-validation</guid>
      <pubDate>Tue, 19 Nov 2024 17:31:14 GMT</pubDate>
    </item>
    <item>
      <title>如何处理具有一定依赖性的单向方差分析？</title>
      <link>https://stats.stackexchange.com/questions/657516/how-to-approach-a-one-way-anova-with-some-dependence</link>
      <description><![CDATA[我希望使用单向方差分析比较多个组。每个组彼此独立，但每个组内的样本彼此之间有一定的依赖性（即，组中的部分（或全部）样本来自同一受试者，但在不同的时间测量（测量时间在这里无关紧要））。
单向方差分析适合这项任务吗？例如，将每个受试者的均值用作组内的单个数据点是否会使其更合适？如果所有组都是单个受试者，情况会改变吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/657516/how-to-approach-a-one-way-anova-with-some-dependence</guid>
      <pubDate>Tue, 19 Nov 2024 15:28:18 GMT</pubDate>
    </item>
    <item>
      <title>使用引导法计算范围的置信区间</title>
      <link>https://stats.stackexchange.com/questions/657514/confidence-interval-for-the-range-using-bootstrapping</link>
      <description><![CDATA[我有一台机器，生产长度各异的零件，每个包装包含 5 个零件（它们应该是相同的），如果包装中最大零件和最小零件之间的距离大于 5cm，则该包装被视为拒收。我可以测量单个零件的长度（我从机器中抽样并测量了 180 个随机零件），但是我无法对单个包装进行任何抽样或测量，因为它们是按需包装的，这可能需要很长时间。
我需要为包装的拒收率制定一个置信区间。
PS：给定 viz，长度分布几乎呈正态分布，并且 180 未能拒绝 p 值为 16% 的 wilk-shapiro 检验。
我使用的方法基本上是使用百分位数法进行引导以获得置信区间。
首先，我从 180 个样本中抽取 100 个，然后使用这 100 个模拟 500 个包装，计算每个包装的范围并测量被拒包装的比例，重复此过程 10000 次，并使用百分位数法获得置信区间。
为了验证这种方法，我假设一个具有随机均值和标准差的正态随机变量，然后我抽取了 500,000 个 5 件包装并获得了被拒包装的比例，我假设这是真实比例。然后我从我的随机变量中抽取了 180 个样本，我运行了上面解释的方法并生成了 1000 个 60% 置信区间，以检查其中约 60% 是否包含真实值。但是，我运行的每次模拟 100% 的区间都包含真实值，即使我使用完全随机的离散随机变量，我也会得到相同的结果。我不明白这是怎么发生的，我认为我的模拟或引导程序出了问题，但我无法弄清楚。]]></description>
      <guid>https://stats.stackexchange.com/questions/657514/confidence-interval-for-the-range-using-bootstrapping</guid>
      <pubDate>Tue, 19 Nov 2024 14:31:08 GMT</pubDate>
    </item>
    <item>
      <title>GAM 计数模型残差中的不确定序列自相关</title>
      <link>https://stats.stackexchange.com/questions/657495/uncertain-serial-autocorrelation-in-gam-count-model-residuals</link>
      <description><![CDATA[我希望使用广义加性模型 (GAM) 来平滑计数时间序列并估计一阶导数，即识别计数增加、稳定或减少的时期。
我正在使用 R 并发现 mgcv::gam() 模型残差中存在序列自相关。由于对非高斯分布加上序列自相关（即 MASS::glmmPQL()）的 mgcv::gamm() 的信心不足，我转向了 mvgam::mvgam()。mvgam 的平滑实际上与 gam 的平滑相同，但 mvgam 模型的诊断没有显示“显著”自相关。
以下是本文底部示例代码的一些图表（按顺序：gam smooth、mvgam smooth、mvgam diagnostics、gam acf()、mvgam acf()）。





gam 模型偏差残差的 acf() 和 pacf() 图表明负“AR3”自相关。 mvgam 模型分位数残差的诊断不表示负自相关，但是平均分位数残差的 acf() 和 pacf() 表示负自相关！
存在自相关还是不存在？关于矛盾的 mvgam 诊断，我怀疑 acf(平均残差) != 平均值(acf(残差))。
我确实尝试使用 trend_model = &quot;AR3&quot; 拟合 mvgam，但这些 AR 系数不精确且“不显著”。
gam 模型适合用途，因为它比 mvgam 更快，更容易提取一阶导数和置信区间，而且我对预测不感兴趣。但是，如果 gam 偏差残差的 acf() 图可靠，则很难说服同行置信区间是准确的。
为了更彻底地研究序列自相关，我考虑从拟合的 gam 进行模拟以生成 acf() 和 pacf() 系数的分布（类似于 mvgam 所做的）。也许这些模拟会显示序列自相关最常在容差范围内。我不确定如何编码。
library(&quot;mgcv&quot;) # mgcv_1.9-1
library(&quot;rstan&quot;) # rstan_2.32.6; cmdstanr 对我不起作用
library(&quot;mvgam&quot;) # mvgam_1.1.3
library(&quot;gratia&quot;) # gratia_0.9.2
## 数据
# 一些年度计数和人口（100,000）
# 想法是模拟比率 = 计数 / 100,000 人口
# n = 29 是一个短时间序列
dat &lt;- data.frame(time = 1996:2024,
count = c(314, 590, 725, 953, 1218, 1688, 2227, 2751,
3395, 4189, 4865, 5650, 5829, 6664, 7097, 8078, 8720,
9455, 9773, 10382, 10519, 10576, 10814, 11904, 13176,
14631, 15075, 16282, 17371),
pop = c(23.48816, 23.81456, 24.08718, 24.39848, 24.71095,
25.08078, 25.35108, 25.59605, 25.78745, 26.0291, 26.2812,
26.66912, 27.13734, 27.61413, 28.0111, 28.35941, 28.73572,
29.17764, 29.64432, 30.10587, 30.59446, 31.10672, 31.52141,
31.9123, 32.20657, 32.11941, 32.41207, 33.22432, 34.03657))
## gam 模型（具有负二项式误差分布）
mod1 &lt;- gam(count ~ offset(log(pop)) + s(time, k=10),
data = dat, family = nb())
summary(mod1) # nb theta = 2715.554
png(filename=&quot;mod1diag.png&quot;)
gam.check(mod1) # 诊断确定
dev.off()
## mvgam 模型
mod2 &lt;- mvgam(count ~ offset(log(pop)) + s(time, k=10),
data = dat, family = nb())
summary(mod2, include_betas=FALSE) # nb theta = 1800
png(filename=&quot;mod2diag.png&quot;)
plot(mod2, type=&quot;residuals&quot;) # 自相关在容差范围内
dev.off()
## 拟合平滑
png(filename=&quot;mod1smooth.png&quot;)
draw(mod1)
dev.off()
png(filename=&quot;mod2smooth.png&quot;)
drawDotmvgam(mod2)
dev.off()
## gam 偏差残差；acf 几乎相同 type=&quot;pearson&quot;
r1 &lt;- residuals(mod1, type=&quot;deviance&quot;)
png(filename=&quot;mod1acf.png&quot;)
par(mfrow=c(2,1))
acf(r1, main=&quot;gam deviance residuals&quot;)
pacf(r1)
par(mfrow=c(1,1)) 
dev.off()
## mvgam 平均（或中位数）残差与上面的 acf 图相矛盾
r2 &lt;- residuals(mod2)[, 1]
png(filename=&quot;mod2acf.png&quot;)
par(mfrow=c(2,1))
acf(r2, main=&quot;mvgam 平均分位数残差&quot;)
pacf(r2) 
par(mfrow=c(1,1))
dev.off()
]]></description>
      <guid>https://stats.stackexchange.com/questions/657495/uncertain-serial-autocorrelation-in-gam-count-model-residuals</guid>
      <pubDate>Tue, 19 Nov 2024 10:48:58 GMT</pubDate>
    </item>
    <item>
      <title>功效分析能否计算 n 来检测总体平均值随时间的变化？</title>
      <link>https://stats.stackexchange.com/questions/657469/can-a-power-analysis-calculate-n-to-detect-changes-in-a-population-mean-over-tim</link>
      <description><![CDATA[将功效分析解释为：计算检测总体平均值从一个时间点到另一个时间点的变化（%）所需的最小样本量的一种可能方法（？）是否不正确。例如，在未来的调查中，我需要多大的样本量才能检测到总体平均值的 30% 变化？
以 Cohen 的 D 效应量公式作为功效分析的示例；如果“M”是样本平均值，“σ”是样本标准差（共同估计当前总体平均值），“µ”可以被视为未来总体平均值（当前平均值的 30% 变化，没有样本误差）吗？这是针对“前后”的重复测量设计。
那么得出这样的结论是错误的吗：
# 效应大小，Cohen&#39;s D：d=(M-μ)/σ
# M=1，σ=0.5，µ=0.7
# 0.6 = (1-0.7)/0.5

&gt; pwr.t.test(d = 0.6, 
+ power = 0.8000, 
+ n = NULL, 
+ type = &quot;paired&quot;,
+ alternative = &quot;two.sided&quot;,
+ sig.level = 0.05)

配对 t 检验功效计算 

n = 23.79452
d = 0.6
sig.level = 0.05
power = 0.8
alternative = two.sided

注意：n 是 *对* 的数量

结论：样本量为 24 足以在未来调查中检测到当前人口平均值的 +/-30% 变化（双尾检验），概率为 80%，alpha=0.05。
现在对配对数据定义功效分析是否不正确方式？
我猜这是不正确的措辞。功效分析不是为了检测从一个时间点到另一个时间点的变化，而是为了通过抽样来测试估计的总体参数的准确性，不是吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/657469/can-a-power-analysis-calculate-n-to-detect-changes-in-a-population-mean-over-tim</guid>
      <pubDate>Mon, 18 Nov 2024 21:16:56 GMT</pubDate>
    </item>
    <item>
      <title>Logitstic 回归在 statsmodels GLM、statsmodels Logit 和 skylearn LogisticRegression 函数中有所不同 [重复]</title>
      <link>https://stats.stackexchange.com/questions/657458/logitstic-regression-varies-among-statsmodels-glm-statsmodels-logit-and-skylea</link>
      <description><![CDATA[大家好，
我发现，简单二元数据的逻辑回归在以下函数中差异很大。

statsmodels.api.GLM
statsmodels.api.Logit
sklearn.linear_model.LogisticRegression


statsmodels.api.GLM 完全符合数据，在我看来，sklearn.linear_model.LogisticRegression 比statsmodels.api.Logit。
上图表明，不同函数的解不同，但对数奇数（odd）的指数可能并非如此，如下所示：

statsmodels.api.GLM 1.2
sklearn.linear_model.LogisticRegression 1.1
statsmodels.api.Logit 1.03

知道这些函数为什么会有所不同吗？
谢谢
这是代码

从 scipy.special 导入 expit
导入 matplotlib.pyplot 作为 plt
导入 numpy 作为 np
从 sklearn.linear_model 导入 LogisticRegression
从 sklearn.metrics 导入 classes_report, chaos_matrix
导入 statsmodels.api 作为 sm

x_glm=np.arange(50)
x=x_glm.reshape(-1,1)

x_with_ones=np.ones((len(x),2))
x_with_ones[:,1]=x_glm

y=np.ones(50)
y[:25]=0
y[20:24]=1
y[30:34]=0

############Skylearn Logistic 回归 ######################
############Skylearn逻辑回归 ######################
model_logistic = LogisticRegression(solver=&#39;liblinear&#39;, random_state=0).fit(x, y)
sigmoid_auto=model_logistic.predict_proba(x)[:,1]
# sigmoid1=model_logistic.predict() # 应用截止值 0.5 后
print(model_logistic.intercept_)
print(model_logistic.coef_)

######### GLM 逻辑回归 ###############
######### GLM 逻辑回归 ###############
modelC =sm.GLM(y,x_with_ones,family=sm.families.Binomial(link=sm.families.links.Logit())).fit()
sigmoid_glm=modelC.predict(x_with_ones)
# 获取可用链接列表与特定家族相关，打印
打印（sm.families.family.Binomial.links）
打印（modelC.params）
######### sm.Logit 回归 ###############
######### sm.Logit 回归 ###############
model_logit = sm.Logit(y, x_with_ones).fit()
sigmoid_logit=model_logit.predict(x_with_ones)
打印（model_logit.params）
打印（model_logit.summary）

################ 图 #######################
################ 图 #######################
plt.figure()
plt.scatter(x,y,facecolors=&#39;none&#39;, edgecolors=&#39;b&#39;,label=&#39;observations&#39;)
plt.scatter(x,sigmoid_auto,facecolors=&#39;none&#39;, edgecolors=&#39;g&#39;,label=&#39;sklearn LogisticRegression&#39;)
plt.scatter(x,sigmoid_glm,c=&#39;k&#39;,marker=&#39;+&#39;,
label=&#39;sm.GLM&#39;)
plt.scatter(x,sigmoid_logit,marker=&#39;^&#39;,label=&#39;sm.Logit&#39;)

plt.legend( fontsize=&quot;20&quot;)

#%% 解释 
# coef
# sm.GLM
print(np.exp(modelC.params[3]))
# Skylearn LogisticRegression
# # x 增加一个单位，(y) 的奇数就会增加 .... 
print(np.exp(model_logistic.coef_))
#sm.Logit
print(np.exp(model_logit.params))```

]]></description>
      <guid>https://stats.stackexchange.com/questions/657458/logitstic-regression-varies-among-statsmodels-glm-statsmodels-logit-and-skylea</guid>
      <pubDate>Mon, 18 Nov 2024 16:54:09 GMT</pubDate>
    </item>
    <item>
      <title>从两个样本中估计两个集合的Jaccard[重复]</title>
      <link>https://stats.stackexchange.com/questions/657453/estimate-jaccard-of-two-sets-from-two-samples</link>
      <description><![CDATA[假设我有两个集合，我开始从每个集合中取样。我如何将样本的重叠部分推断到整个集合？
具体示例：假设我有来自集合 A 的 1M 元素的 1% 样本（总共 1 亿个元素），以及来自集合 B 的 1M 元素的 0.33% 样本（集合 B 中总共 3 亿个元素）。如果我了解到 A 和 B 这两个样本之间有 350,000 个重叠，我该如何推断以估计非采样集的重叠？
我遇到了基于样本估计 Jaccard 相似度，但我的问题略有不同，因为每个子集的采样率可能不同，并且集合的大小可能有很大差异。
使用该帖子中编辑的公式：𝐿=|𝐴∩𝐵|
我们可以估计 𝐴∪𝐵=|𝐴|+|𝐵|−𝐿≈|𝐴′|𝑃+|𝐵′|𝑃+𝐿 并且 Jaccard 的估计量是：𝑒𝑠𝑡_𝑗𝑎𝑐𝑐𝑎𝑟𝑑(𝐴′,𝐵′)=𝐿/(|𝐴′|/𝑃+|𝐵&#39;|/𝑃+𝐿)
我会有 L = 350000/(.0033 * .01) 然后 est_jaccard(A,B) = 350000/(.0033 * .01) / (1,000,000 / .01) + (1000000/.0033) + 350000/(.0033 * .01)) = 96%。这显然是错的，我这里遗漏了什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/657453/estimate-jaccard-of-two-sets-from-two-samples</guid>
      <pubDate>Mon, 18 Nov 2024 16:26:35 GMT</pubDate>
    </item>
    </channel>
</rss>