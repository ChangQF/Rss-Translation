<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Mon, 18 Mar 2024 21:13:36 GMT</lastBuildDate>
    <item>
      <title>假设检验中的显着性值</title>
      <link>https://stats.stackexchange.com/questions/642900/significance-value-in-hypothesis-testing</link>
      <description><![CDATA[一位建筑商声称，目前钦奈正在建造的所有房屋中 $70\%$ 都安装了热泵。如果对该城市的新房进行的随机调查显示，$8$ 中的 $15$，您是否同意这一说法？是否安装了热泵？使用 $10\%$ 显着性水平。
这里的原假设(H$_0$)是$p = 0.7$和备择假设(H$_A$) : $p \neq 0.7$。所以，这是一个双向测试。
我想使用定义 P 计算类型 1 错误的值 ($A^c$ |  $H_0$ 为 true），其中 A 是接受集，但我无法正确地表达它。我们如何定义接受集？
我已完成以下两个步骤。
$\bullet$ 如果则拒绝$H_0$ $\big|T-10.5\big| &gt; c$.
$\bullet$ P($A^c$ | $H_0$ 为 true ) = $\text{P} (T &gt; c+10.5 \,\, \text{or} \,\, T &lt; 10.5-c \,\, | \,\, p = 0.7 \,)= \text{P} (T &gt; c+10.5 \,\,| \,\, p =0.7) + P( \,\, T &lt; 10.5-c \,\, | \,\, p = 0.7 \,)$。
上述步骤会造成混乱。任何帮助将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/642900/significance-value-in-hypothesis-testing</guid>
      <pubDate>Mon, 18 Mar 2024 21:09:20 GMT</pubDate>
    </item>
    <item>
      <title>有人能给我一个直观的解释，为什么我的平均绝对误差收敛到 66.6%？</title>
      <link>https://stats.stackexchange.com/questions/642897/can-somebody-give-me-an-intuitive-explanation-why-my-mean-absolute-error-converg</link>
      <description><![CDATA[假设我的实际数字（随机生成）在 1 到 1000 之间。我们进一步假设，我的预测模型尝试预测实际数字。我的“预测”模型是一只真正随机按下 1 到 1000 之间按钮的猴子，本质上它与用于生成实际数字的函数相同。我只是将两组随机生成的数字放在一起并计算它们的差异（“错误”）。
如果我遵循这个逻辑并计算猴子模型的平均绝对误差并用实际数字对其进行标准化，MAE 将约为 66%。需要确认的是，MAE 的计算公式为：SUM(ABS(Actual-Forecast))/SUM(Actual)。
您可以在 Excel 中轻松创建此模型。
有人可以给我一个直观的解释，为什么我生成的数字越多，得到的值恰恰是 66.666%？我的理解是，平均而言，我对实际数字的预测有 66% 是错误的。]]></description>
      <guid>https://stats.stackexchange.com/questions/642897/can-somebody-give-me-an-intuitive-explanation-why-my-mean-absolute-error-converg</guid>
      <pubDate>Mon, 18 Mar 2024 19:32:19 GMT</pubDate>
    </item>
    <item>
      <title>自相关残差是否会导致 OLS 系数出现偏差？</title>
      <link>https://stats.stackexchange.com/questions/642892/do-autocorrelated-residuals-cause-ols-coefficients-to-be-biased</link>
      <description><![CDATA[我到处都看到不同的答案。直观上，我认为如果残差是自相关的，那么有些信息您没有纳入模型中，并且是有偏拟合的标志。然而，我看到消息来源说这没有偏见，但不是“最好的”。估计。
答案是什么？为什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/642892/do-autocorrelated-residuals-cause-ols-coefficients-to-be-biased</guid>
      <pubDate>Mon, 18 Mar 2024 18:38:50 GMT</pubDate>
    </item>
    <item>
      <title>用于具有单调链接的单索引模型的 R 包？</title>
      <link>https://stats.stackexchange.com/questions/642891/r-package-for-single-index-model-with-monotone-link</link>
      <description><![CDATA[给定
$$p_i = \pi(\mathbf{x_i}^T\gamma), t_i \in (0,1),||\gamma||=1$$
如果我想估计未知链接函数的单调性约束下的回归参数，我该怎么办？根据 Guntuboyina 和Sen，2018，P29，现有的 R 包 simset 处理凸单索引模型中的计算。但是，我找不到任何可以处理单调链接的现有软件包。我知道处理单调链接的唯一 R 包是 isoreg，但它似乎只估计给定 $y$ 的阶跃函数和 $x$。然而，我的兴趣是获取回归参数 $\gamma$。从文献来看，这似乎仍然是一个活跃的问题，并且提出了一些算法。但是，我找不到任何公共代码和资源并自己编写软件。有人对这个模型有经验并有什么建议吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/642891/r-package-for-single-index-model-with-monotone-link</guid>
      <pubDate>Mon, 18 Mar 2024 18:13:39 GMT</pubDate>
    </item>
    <item>
      <title>关于弱监督语义分割的伪掩模[重复]</title>
      <link>https://stats.stackexchange.com/questions/642889/pseudo-mask-about-weakly-supervised-semantic-segmentation</link>
      <description><![CDATA[我正在按照该图像中描述的过程进行操作 ---&gt; 来生成用于语义分割任务的高质量伪掩码。然而，在训练分类模型获得CAM（类激活图）后，我注意到CAM的质量不理想（为什么同一区域中不同类有重叠，有些不存在的类，但也出现在其相应类别的 CAM？...）。如何生成高质量的 CAM？]]></description>
      <guid>https://stats.stackexchange.com/questions/642889/pseudo-mask-about-weakly-supervised-semantic-segmentation</guid>
      <pubDate>Mon, 18 Mar 2024 17:03:00 GMT</pubDate>
    </item>
    <item>
      <title>从非正态数据集中进行有偏采样</title>
      <link>https://stats.stackexchange.com/questions/642886/biased-sampling-from-a-non-normal-dataset</link>
      <description><![CDATA[对于我的分析，我对非正态分布总体中的特定子集感兴趣。因此，我想从该人群中生成一个样本。样本将具有显着不同的均值/方差并且具有“已知”的数据。形状本身可能是正常的、“半正常的”。 （看起来很正常，但不是平滑的钟形曲线），或者更有可能，完全是其他东西。
目前，我正在通过获取多个（任意构造的）不同形状的子样本并将它们组合起来来构造我的样本，直到获得所需的“已知”样本。形状。我提供了一个快速草图来说明这个想法。该分析实际上不是关于睡眠的，我只是选择了一些东西来背景化单位/形状。

希望您可以看到，如果组合子样本 1、2、3，您将接近目标分布。我绘制了一个随机形状，但目标也可以是正态或半正态的。
有了这些背景，我的问题很简单：这个过程是否有名称和/或其是否合理？如果这是我不知道的一件非常常见的事情，我很想知道 R/Python 中的一些包可以帮助解决这个问题，因为我不需要一个这样的示例，而是多个，每个都有不同的示例形状。
据我了解，它与 这篇文章，但他们正在寻找至少相似的发行版，而我正在寻找完全不同的东西。]]></description>
      <guid>https://stats.stackexchange.com/questions/642886/biased-sampling-from-a-non-normal-dataset</guid>
      <pubDate>Mon, 18 Mar 2024 16:50:18 GMT</pubDate>
    </item>
    <item>
      <title>回归模型时间序列预测中不平衡时间序列数据集下采样的解决方案</title>
      <link>https://stats.stackexchange.com/questions/642885/solutions-to-downsampling-imbalanced-time-series-dataset-in-time-series-forecast</link>
      <description><![CDATA[我有一个不平衡的时间序列数据集，用于回归的时间序列预测问题（给定 1 个 24 小时数据视频（144 7x7 图像），预测 1 个 24 小时数据视频（144 7x7 图像））。我做了一个测试，其中我从训练集中过滤了数据，使得训练目标数据等于或小于验证目标数据的均值，这使得损失（梯度差损失+ MAE）和指标（自第一个 epoch 以来，训练、验证和测试集的 RMSE 和 MAE）在早期 epoch 中变得更好，这是一个非常明显的变化。我理解，这样训练数据会更加平衡，因为数据开始具有与验证数据更相似的分布，从而与测试数据更相似。据我核实，这是一种采样技术，我相信它会是下采样。我想知道这种方法是否有效，如果无效，有什么好的解决方案。我用来下采样的 Python 代码：
mean_Y_val = np.mean(Y_val)
mask_Y_train = np.mean(Y_train, axis=(1, 2, 3)) &lt;= Mean_Y_val
Y_train = Y_train[mask_Y_train]
X_train = X_train[mask_Y_train]

提前非常感谢您！]]></description>
      <guid>https://stats.stackexchange.com/questions/642885/solutions-to-downsampling-imbalanced-time-series-dataset-in-time-series-forecast</guid>
      <pubDate>Mon, 18 Mar 2024 16:47:25 GMT</pubDate>
    </item>
    <item>
      <title>哪些模型可用于估计相对预期寿命（以年为单位，而不是以风险比为单位）？</title>
      <link>https://stats.stackexchange.com/questions/642884/which-models-are-available-to-estimate-relative-life-expectancy-in-years-not-i</link>
      <description><![CDATA[我有一个表型良好的生存数据集（即，它具有大量用于死亡率研究的相关协变量），我可以根据该数据集估计某些条件如何影响预期寿命 (LE)。在损失或增加的生命年数中计算这一点比通过 Cox 模型陈述风险比会提供更多信息。
我想知道人们的想法或经历是什么

比较 Cox 模型与 LE 模型中容易获得的中位预期寿命

在 PH 假设内拟合参数生存模型（Weibull 或 Cox-Gompertz 模型，如 https://www.sciencedirect.com/science/article/pii/S0167668720300500#fig1）和计算 LE

使用 Aalen 的附加危险模型

有人尝试过机器学习吗？似乎许多深度学习仍然以 Cox-PH 作为 FastCPH 的核心。生存随机森林是根据最后叶子中的 Kaplan-Meier 进行预测的，因此中值的估计值将比任何外推值更好）

还有其他选择吗？


之前也提出过类似的问题，根据 cox 回归模型计算预期寿命所需的最少信息是什么？
https://stackoverflow.com/questions/ 28491796/how-to-predict-survival-time-in-coxs-regression-model-in-r，主要是关于从 Cox-PH 获取预期寿命，并建议采取第一个或第二个选项，所以我主要对其他非 Cox 模型选项感到好奇。]]></description>
      <guid>https://stats.stackexchange.com/questions/642884/which-models-are-available-to-estimate-relative-life-expectancy-in-years-not-i</guid>
      <pubDate>Mon, 18 Mar 2024 16:01:47 GMT</pubDate>
    </item>
    <item>
      <title>一个变量具有统计显着性但未被分类方法选择为重要意味着什么？</title>
      <link>https://stats.stackexchange.com/questions/642883/what-does-it-mean-for-a-variable-to-be-statistically-significant-but-not-selecte</link>
      <description><![CDATA[我基本上是在玩一些脂质组学数据来练习，所以我的问题纯粹是理论上的。
我想看看是否能找到两组之间不同的脂质类别，并且我正在比较结果。当我使用假设检验（参数和非参数）时，我始终发现一种脂质类别在调整多重比较后发生了显着变化。然而，当我运行其他类型的分析（例如朴素贝叶斯、随机森林和 LASSO（作为多响应高斯回归））时，我得到的精度非常低，而且重要的变量完全不同。
数据如下所示：

x 轴代表每种脂质类别经过 log2 转换后的总浓度。 LPE 是不断出现显着变化的类别，但对分类方法来说并不重要。
这些结果是否表明假设检验不适用于该数据？]]></description>
      <guid>https://stats.stackexchange.com/questions/642883/what-does-it-mean-for-a-variable-to-be-statistically-significant-but-not-selecte</guid>
      <pubDate>Mon, 18 Mar 2024 15:53:09 GMT</pubDate>
    </item>
    <item>
      <title>MRP/MDP中的奖励函数定义，强化学习不同的符号</title>
      <link>https://stats.stackexchange.com/questions/642876/reward-function-definition-in-mrp-mdp-reinforcement-learning-different-notation</link>
      <description><![CDATA[几周前我开始自学强化学习。这几天我遇到了奖励函数定义的问题。
奖励函数，定义和量化代理将获得的奖励，在(s)或(s, a)或(s, a, s&#39;) [取决于我们在特定问题中定义的奖励函数]。我们通常说的MDP是一个5元元组，即(𝓢, 𝓐, P, r, gamma)，其中：

𝓢 ：包含所有s的状态集，s ∈ 𝓢
𝓐：包含所有动作a的动作集，aε𝓐
gamma：折扣因子
P：转移概率，即P(s&#39; | s, a)

但是，对于“r”、“R”或“𝓡”在元组中，我发现不同的教科书对它的定义有点不同......
&lt;小时/&gt;
在萨顿&amp; Barto 的“强化学习：简介”：

r是奖励
Rt 或 Rt+1 是代理在特定时间步长获得的实际奖励
 是包含所有可能奖励值的奖励集，它是实数的子集 
r (s, a) 或 r (s) 是 (s, a) 处的预期奖励值 或（s）

其实我没看到“5元组”这个词在教科书中，他们只是简单地定义了“关节”。概率为p(s&#39;, r | St = s, At = a)。
&lt;小时/&gt;
在 David Silver 关于强化学习介绍的讲座中：

Rt 或 Rt+1 是代理在特定时间步长获得的实际奖励
 是“奖励函数”，它是 预期奖励值 ( s、a) 或 (s)

&lt;小时/&gt;
在其他一些来源中（多伦多大学，CSC311 讲座幻灯片）：

Rt 或 Rt+1 是代理在特定时间步长获得的实际奖励
 是 (s, a) 处可能奖励的分布（对于随机奖励过程）


来自[chrome-extension://fcejkolobdcfbhhakbhajcflakmnhaff/pages/viewer.html?file=https%3A%2F%2Fwww.cs.toronto.edu%2F~michael%2Fteaching%2Fcsc311_w23%2Flectures%2Flec12_mz.pdf#pagemode=thumbs] 
此外，从StackExchange网站上的一些其他答案中，有些人解释了“奖励功能”因为它定义了实际的奖励/奖励分配，而不是代理在 (s, a) 或 (s) 或 (s, a, s&#39;) 处获得的预期奖励值
&lt;小时/&gt;
据我所知，在不同的来源中，符号可能有点不同。对于确定性奖励过程，奖励的期望值就是实际奖励值本身。对于随机奖励过程，预期奖励和智能体从分布（或奖励可能性分布）中获得的实际奖励是不同的概念。
当人们定义“奖励函数”一词时，我对所有这些不同的表示法“标准”感到有点困惑。
奖励函数的定义r(s)，或r(s, a)，或r(s, a, s&#39;)&lt; /em&gt;，有时人们会提到预期奖励函数，它定义了预期奖励（确定性和随机性）。其他时候，人们只指奖励函数，它定义了实际奖励（确定性）/奖励分配（随机）。
我认为在强化学习领域，这两种“奖励函数”的定义只是可以互换使用。这个问题可能看起来有点“浪费时间”，但我只是在这里发帖，以供是否有人也遇到过和我类似的情况..谢谢]]></description>
      <guid>https://stats.stackexchange.com/questions/642876/reward-function-definition-in-mrp-mdp-reinforcement-learning-different-notation</guid>
      <pubDate>Mon, 18 Mar 2024 14:25:44 GMT</pubDate>
    </item>
    <item>
      <title>零假设下 Mann-Whitney U 检验的意外 p 值分布</title>
      <link>https://stats.stackexchange.com/questions/642850/unexpected-p-value-distribution-of-mann-whitney-u-test-under-null-hypothesis</link>
      <description><![CDATA[我在原假设下得到了曼-惠特尼 U 检验 p 值分布的非常意外的结果。
我正在处理真实数据，但我能够在具有相似分布的人工数据上复制结果。数据分布类似于零膨胀对数正态分布。
我的分析背后的想法是检查我是否可以对我的数据使用 Mann-Whitney U 检验。最初，我对常规 T 检验进行了类似的测试，但由于我正在研究非正态分布，我收到了太多 I 类错误。但对于 T 检验来说，这是预期的，因为不满足检验假设。因此，我使用 Mann-Whitney U 检验重复了相同的模拟，期望得到均匀的 p 值分布，但结果却得到了与我预期非常不同的分布。
这是我的代码：
# 加载库
将 numpy 导入为 np
将 pandas 导入为 pd
从 scipy.stats 导入 mannwhitneyu
from joblib import 并行，延迟
    
### 模拟
# 定义单个模拟代码
定义过程（）：
    # 对第一个样本进行采样，它有 95% 的零，其余为对数正态分布，使用乘法将两者合并
    样本1 = (np.random.uniform(0, 1, 10_000_000)&lt;0.05)*np.random.lognormal(平均值=2.7, 西格玛=2, 大小=10_000_000)
    # 对第二个样本进行采样，相同的分布
    样本2 = (np.random.uniform(0, 1, 10_000_000)&lt;0.05)*np.random.lognormal(平均值=2.7, 西格玛=2, 大小=10_000_000)
    # 执行测试
    res = mannwhitneyu(样本1, 样本2)
    返回（res）
        
# 并行运行模拟以更快地获得结果
结果=并行（n_jobs = 15）（延迟（过程）（i）对于范围（100）内的i）
    
### 可视化结果
# 从模拟中提取 p 值
p_vals = [结果中 el 的 el.pvalue]
# 绘制 p 值
pd.Series(p_vals).hist()

这是我得到的 p 值分布：

如您所见：

我得到了错误的 I 类错误率（I 类错误为 0%！）。
该分布与预期的均匀分布相差甚远。

我认为最奇怪的事情是，完全相同的代码但样本较小（每个样本中有 1,000 个 obs 或 100,000 个）不会导致任何问题（p 值均匀分布）。因此，我认为由于数字很大，可能会发生一些数值错误，使检验统计量远低于应有的水平。
有什么想法、建议吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/642850/unexpected-p-value-distribution-of-mann-whitney-u-test-under-null-hypothesis</guid>
      <pubDate>Mon, 18 Mar 2024 08:50:47 GMT</pubDate>
    </item>
    <item>
      <title>随机变量递减函数的期望值与随机变量期望值的关系</title>
      <link>https://stats.stackexchange.com/questions/642824/expected-value-of-decreasing-function-of-random-variable-versus-expected-value-o</link>
      <description><![CDATA[给定两个随机变量 $X_1$ 和 $X_2$ （相同的样本空间$\mathcal{X}$) 
$$\mathbb{E}[X_1]=\int_{\mathcal{X}}xf_1(x)dx &gt; \mathbb{E}[X_2]=\int_{\mathcal{X}}x f_2(x)dx$$
我们可以说 $\mathbb{E}[g(X_1)] $\mathbb{E}[g(X_1)] &lt; \mathbb{E}[g(X_2)]$ 给定函数 $g(\cdot)$ 正在减少？
在无意识统计学定律之后我立即陷入困境 $\mathbb{E}[g(X)] = \int_{\mathcal{X}}g(x) f_X (x)dx$ 并且不知道如何继续。
也许这是一个愚蠢的问题？因为如果 $X_1 \sim \mathcal{N(\mu_1,\sigma_1^2)}$ 和 $X_2 \sim \mathcal{N(\mu_2,\sigma_2^2)}$ 和 $\mu_1 &gt; \mu_2$ 但我们可以选择方差，以便对数正态 $-\log(X_1)$ 和 $-\log(X_2)$，即 $-\exp(\mu_1+0.5\sigma_1)$ 和 $-\exp(\mu_2+0.5\sigma_2)$，有任何关系。]]></description>
      <guid>https://stats.stackexchange.com/questions/642824/expected-value-of-decreasing-function-of-random-variable-versus-expected-value-o</guid>
      <pubDate>Sun, 17 Mar 2024 17:19:01 GMT</pubDate>
    </item>
    <item>
      <title>将双重差分应用于前期成本比较</title>
      <link>https://stats.stackexchange.com/questions/642768/apply-difference-in-differences-to-pre-cost-comparison</link>
      <description><![CDATA[一开始就随机分配了两组用户（“控制”和“测试”）。
在第 0 周到第 6 周之间，我们对“控制”不执行任何操作，并为“测试”应用 30% 的折扣
从第 7 周到第 12 周，“对照”保持不变，我们为“测试”应用了 20% 的折扣
我们想要衡量“测试”组在应用 30% 折扣与 20% 折扣时的销售额差异。
尝试看看是否可以应用“差异中的差异”来考虑“时间”效应
对于遵循传统“DID”结构的前后比较：“测试”的“治疗”值为 1 或 2（30% 折扣或 20% 折扣），“控制”值为 0； “时间”的“后期”值为 1，“前期”值为 0； “DID”将为“时间”*“治疗”（0 或 2）。

&lt;标题&gt;

测试组
时间段
用户
时间
处理
DID（时间*治疗）
销售额


&lt;正文&gt;

控制
第 0~6 周
a
0
0
0
x1


测试
第 0~6 周
b
0
1
0
x2


控制
第 7~12 周
a
1
0
0
x3


测试
第 7~12 周
b
1
2
2
x4



因为目标是在“测试”组内比较“30% 折扣”与“20% 折扣”。如果我们对下面的示例中的 Sales ~ Time + Treatment + Time*Treatment 进行类似的线性回归。我的想法是我们无法得到我们需要的东西？但想跟这个小组确认一下。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/642768/apply-difference-in-differences-to-pre-cost-comparison</guid>
      <pubDate>Sat, 16 Mar 2024 17:38:44 GMT</pubDate>
    </item>
    <item>
      <title>营销应用中的机器学习。使用哪种型号？ [关闭]</title>
      <link>https://stats.stackexchange.com/questions/642724/machine-learning-in-marketing-application-which-model-to-use</link>
      <description><![CDATA[对于一个零售商，我有客户数据，其中包括客户 ID、性别、年龄、距最近零售商的距离、获取渠道等列，以及通过运行 BYTD 统计模型获得的个人 CLV（客户生命周期价值）。
我的目标是了解构成最高 CLV 客户的固有特征，以便找到并获取具有类似特征的其他客户。
需要明确的是，我不是在构建机器学习模型来预测 CLV，而是使用贝叶斯统计模型来预测 CLV，而是试图了解具有高 CLV 的客户的特征，以便我可以定位我的营销工作中有更多这样的内容。
哪种机器学习算法最适合我的应用程序？]]></description>
      <guid>https://stats.stackexchange.com/questions/642724/machine-learning-in-marketing-application-which-model-to-use</guid>
      <pubDate>Fri, 15 Mar 2024 20:52:00 GMT</pubDate>
    </item>
    <item>
      <title>何时计算偏差校正几何平均值</title>
      <link>https://stats.stackexchange.com/questions/642689/when-to-calculate-the-bias-corrected-geometric-mean</link>
      <description><![CDATA[大多数来源都给出了一个简单的方程来计算对数正态分布的数据样本的几何平均值 (GeoMean)。
GeoMean = exp(m)

其中m是值的自然对数（以e为底）的平均值
偏差校正方程在：Parkin, T. B. &amp; 中给出。 Robinson, J.A. 对数正态分布变量的中值估计量的统计评估。土壤科学。苏克。是。 J. 57, 317–323 (1993)。
GeoMean = exp(m - s^2/2n)

这里，m和s是值的自然对数的平均值和标准差，n是值的数量在样本中。对于较大的n（和/或较小的s），该方程接近更简单、更常用的方程。但对于较小的 n 和/或较大的 s，结果可能会相差很大。
这是一个热图，可以了解修正的幅度有多大。每个值都是与简单（传统）GeoMean 相乘的校正因子，以获得偏差校正的 GeoMean。正如预期的那样，校正仅对大 GeoSD 和小样本量有意义。

我的问题：

这个偏差校正方程正确吗？我没有在其他地方看到它，并且在搜索谷歌或维基百科时找不到任何提及。应该一直使用它吗？
如果它是正确且值得推荐的，为什么？偏见从何而来？
]]></description>
      <guid>https://stats.stackexchange.com/questions/642689/when-to-calculate-the-bias-corrected-geometric-mean</guid>
      <pubDate>Fri, 15 Mar 2024 13:18:52 GMT</pubDate>
    </item>
    </channel>
</rss>