<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>最近 30 个来自 stats.stackexchange.com</description>
    <lastBuildDate>Thu, 11 Apr 2024 12:24:30 GMT</lastBuildDate>
    <item>
      <title>对死亡率表进行抽样</title>
      <link>https://stats.stackexchange.com/questions/644790/sampling-a-mortality-table</link>
      <description><![CDATA[我有一些死亡率表：
age_range_0yearly_probability_0
年龄范围_1 年概率_1
...
年龄范围_k 年概率_k
over_range_k 年概率_over
例如：
[35,45) 0.001
[45-55) 0.003
[55-65) 0.01
[65-75) 0.03
[75-85) 0.08
[85，无穷）0.18
对于离散事件模拟，如何对该表进行采样以获得给定当前年龄的人的事件发生时间（死亡时间）？
谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/644790/sampling-a-mortality-table</guid>
      <pubDate>Thu, 11 Apr 2024 11:02:41 GMT</pubDate>
    </item>
    <item>
      <title>在 OLS 模型中测试和训练 RSS</title>
      <link>https://stats.stackexchange.com/questions/644789/test-and-train-rss-in-ols-model</link>
      <description><![CDATA[我遇到了以下正确/错误问题：
&lt;块引用&gt;
给定一个训练样本，其中包含 $\ N $ 观测值和拟合的 OLS 模型
样本，训练样本的RSS将小于或等于
来自同一分布的所有测试样本的 RSS 的期望
并且样本量相同。

答案是错误的。我很难理解为什么。我想我可以理解为什么对于某些测试样本，RSS 会低于训练集的 RSS，但为什么所有测试样本的期望值都会低于训练集的 RSS？]]></description>
      <guid>https://stats.stackexchange.com/questions/644789/test-and-train-rss-in-ols-model</guid>
      <pubDate>Thu, 11 Apr 2024 11:02:17 GMT</pubDate>
    </item>
    <item>
      <title>预测方波</title>
      <link>https://stats.stackexchange.com/questions/644788/forecasting-square-waves</link>
      <description><![CDATA[我正在与其他大学生一起进行社会实验。该实验涉及模拟可以购买或出售特定资产以立即交付的市场当前价格。我们，参与者就当前价格进行谈判；然后我们的教授会记录谈判的价值，我们每天最多可以召开3次会议和谈判。我们的教授向我们展示了数据图表，看起来像。

我们的教授要求我们在下次“会议”之前预测价格的价值。显然我可以对数据执行移动平均并执行 ARIMA，但仔细检查图形看起来像数字信号，我想知道是否有可以用来预测数字信号的技术。一种方法是使用傅里叶变换，将方波信号转换为正弦信号，然后进行预测，但我想知道这是否是正确的路径。]]></description>
      <guid>https://stats.stackexchange.com/questions/644788/forecasting-square-waves</guid>
      <pubDate>Thu, 11 Apr 2024 11:01:59 GMT</pubDate>
    </item>
    <item>
      <title>在训练模型时如何对某些输入元素进行分类？</title>
      <link>https://stats.stackexchange.com/questions/644787/how-do-i-classify-certain-input-elements-in-training-my-model</link>
      <description><![CDATA[我有大量网球运动员的数据&amp;我想训练我的模型以了解每个不同的玩家都是单独的实体。然后，我想输入 2 个玩家，让我的模型预测哪个玩家会获胜。]]></description>
      <guid>https://stats.stackexchange.com/questions/644787/how-do-i-classify-certain-input-elements-in-training-my-model</guid>
      <pubDate>Thu, 11 Apr 2024 10:49:57 GMT</pubDate>
    </item>
    <item>
      <title>截断数据和未见数据之间的差异</title>
      <link>https://stats.stackexchange.com/questions/644786/difference-between-truncated-and-unseen-data</link>
      <description><![CDATA[我有 2 个相关问题。
假设我们想要建立一个模型来研究一些随机离散变量$x$，它遵循 PMF 的一些已知分布$P(x)$，但参数未知，我们应该通过最大似然估计。假设我们有训练数据，但我们知道 $x$ 的值低于 $a$那里不存在，可能是由于数据收集方式的原因。那么（我认为？）最好使用 $x$ 的左截断分布来代替 $P(x| x &gt; a)$.

通过将 $P(x|x &gt; a)$ 拟合到截断值而获得的 MLE 是否与通过拟合 &lt; 获得的 MLE 往往相同span class=&quot;math-container&quot;&gt;$P(x)$ 到未截断的数据？我们可以分析 $x 在非截断数据上的行为，然后使用非截断模型吗？我的猜测是答案是“是”，因为 $$P(x|x &gt; a) = \frac{P(x , x &gt; a)}{ P(x&gt;a)} = \frac{P(x&gt;a|x)P(x)}{P(x &gt; a)} \leftrightarrows P(x) = \frac{P(x|x&gt;a) ) P(x &gt; a)}{\left[x &gt; a) a\right]}.$$

现在，假设训练数据集是有限的，并且 $x$ 的支持不是有限的，那么将会有很多可能的 $x$ 我们在训练数据中看不到的值。难道我们不应该认为那些看不见的点被“截断”了吗？以及培训部分？

]]></description>
      <guid>https://stats.stackexchange.com/questions/644786/difference-between-truncated-and-unseen-data</guid>
      <pubDate>Thu, 11 Apr 2024 10:45:29 GMT</pubDate>
    </item>
    <item>
      <title>为什么我们只使用时间点过程的事件历史？</title>
      <link>https://stats.stackexchange.com/questions/644785/why-do-we-use-only-event-history-for-temporal-point-processes</link>
      <description><![CDATA[我正在尝试理解时间点过程。特别是神经 TPP。在我读过的所有作品中，输入模型的唯一特征是一系列事件时间戳和标记（如果存在）。他们使用一些 RNN 对其进行编码，然后使用隐藏状态来参数化危险函数。
为什么只使用这些功能？对我来说，能够预测复杂系统的行为似乎是一个非常简单的输入。提供额外的功能（例如，如果您尝试预测冰淇淋的销量、温度）有用吗？
同样，为什么只提供有关事件发生的确切时间的信息？对系统的一些最近信息进行编码是否会有帮助（例如冰淇淋示例，不仅包括出售冰淇淋时的温度，还包括过去 24 小时内的温度，以了解现在是否可能出售）。
也许这源于我对TPP的误解。任何指向相关文献的指示都会非常有帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/644785/why-do-we-use-only-event-history-for-temporal-point-processes</guid>
      <pubDate>Thu, 11 Apr 2024 10:40:15 GMT</pubDate>
    </item>
    <item>
      <title>我们可以在测试集中使用分解的时间序列来获得模型的准确性指标吗？</title>
      <link>https://stats.stackexchange.com/questions/644784/can-we-use-decomposed-time-series-in-a-test-set-to-obtain-models-accuracy-metric</link>
      <description><![CDATA[目前，我正在交叉验证（滚动时间窗口、不同的测试长度）多个预测模型，以获得高度倾斜时间序列（由于真正的偶尔异常值）的性能比较。我的目标是判断哪些模型能够最好地提取“真实”信息。使用 MAE（准确度）和 ME（偏差）来自原始时间序列的（中值）信号（类似正弦 - 具有很强的季节性）。因此，我使用基于原始数据的模型进行预测，并将其与分解数据（趋势+季节性之和）进行比较。
我知道季节性和趋势成分是不可观察的，分解永远不会让我得到“真实”的信息。信号，但总的来说，这种方法有多大错误？
我也知道对给定分布或异常值处理的模拟数据进行交叉验证，但这不是我的观点。]]></description>
      <guid>https://stats.stackexchange.com/questions/644784/can-we-use-decomposed-time-series-in-a-test-set-to-obtain-models-accuracy-metric</guid>
      <pubDate>Thu, 11 Apr 2024 10:36:42 GMT</pubDate>
    </item>
    <item>
      <title>随机森林应用中的特征依赖性</title>
      <link>https://stats.stackexchange.com/questions/644782/feature-dependence-in-random-forest-application</link>
      <description><![CDATA[我正在对目标变量 y 应用随机森林回归，购买的商品数量
在运行回归时，我可以在 n 分钟前访问变量 y 的“运行总计”。
例如如果我在实验结束前 0 分钟运行回归，则我的购买商品数量的运行总计值将只是此示例的目标变量本身。
我想将其用作我的回归中的一个功能，以及我已经拥有的一些功能，因为它为我提供了其他功能无法提供的宝贵见解。运行回归的时间会有所不同，因此 n 可以是任何值。
对于训练数据，我可以对按设定时间间隔购买的商品的运行总数进行采样，因为我有一个时间序列。对于测试数据我不能这样做。
出于这个原因，我认为也许我可以包含另一个功能，采样时间，并复制不同时间间隔的训练数据，以便对此进行训练。
例如，对于单个训练实例：
训练数据将变成：
 样本时间（前分钟）、样本购买商品数量、购买总数 (y)

1 100 50 250
2 50 52 250
3 10 75 250
4 5 150 250
5 2 190 250

                     

测试数据
 样本时间（前分钟）、样本购买商品数量、购买总数 (y)

1 53 25 ？
                    

这里，如果没有采样时间，购买商品的样本数量功能就没有意义，所以我不确定这种方法是否有意义。在仍然使用随机森林模型的同时，是否有更好的方法来处理这个问题？]]></description>
      <guid>https://stats.stackexchange.com/questions/644782/feature-dependence-in-random-forest-application</guid>
      <pubDate>Thu, 11 Apr 2024 09:41:08 GMT</pubDate>
    </item>
    <item>
      <title>所有分位数统一的分位数回归的渐近结果</title>
      <link>https://stats.stackexchange.com/questions/644780/asymptotic-results-for-quantile-regression-uniformly-over-all-quantiles</link>
      <description><![CDATA[在标准分位数回归 (QR) 框架中，我们通常只考虑一个感兴趣的分位数水平，例如 $\tau$。通过标准渐近结果，我们得到 $\sqrt{n}(\hat{\beta}(\tau) - \beta(\tau))$，其中 $\hat{\beta}(\tau)$ 是 Koenker 和 Bassett (1978) 的标准 QR 估计器。这为我们提供了一种使用渐近方差估计来对大样本进行推理的方法。
但是，在阅读论文时，我有时也会遇到在所有分位数水平上一致的渐近结果 $\tau \in (0, 1)$。这些结果似乎并不是一个分位数水平结果的简单扩展。例如，在 Belloni 等人的《计量经济学杂志》论文中。 （2019）提到
&lt;块引用&gt;
我们注意到对函数$u \to \beta(u)$的推断，特别是对参数$\beta(u)$ 一致地适用于所有 $u ∈ U$，其中 $ U$ 是一组感兴趣的分位数指数，很困难，因为基于极限分布的标准渐近理论（van de Vaart 和 Wellner，1996）在这里没有帮助，因为过程 $u \to \sqrt{n}(\hat{\beta}(u)−\beta(u))$ 一般来说没有限制
即使在适当的标准化之后，分布也是如此。

这只是我见过的多篇论文中的一篇，这些论文在所有分位数指数上都得出了如此统一的结果。我看过 Van der Vaart 和 Wellner (1996)，但我没有确切地找到 $u \to \sqrt{n}(\hat{\beta }(u)−\beta(u))$ 没有限制。有谁知道为什么会出现这种情况？我想建立一些直觉，了解为什么标准技术不起作用以及如何得出一致的结果。任何帮助或参考其他作品来更详细地解释这一点将不胜感激。]]></description>
      <guid>https://stats.stackexchange.com/questions/644780/asymptotic-results-for-quantile-regression-uniformly-over-all-quantiles</guid>
      <pubDate>Thu, 11 Apr 2024 08:16:53 GMT</pubDate>
    </item>
    <item>
      <title>再现认知诊断评估的估计分类一致性和准确性[关闭]</title>
      <link>https://stats.stackexchange.com/questions/644779/reproduce-the-estimating-classification-consistency-and-accuracy-for-cognitive-d</link>
      <description><![CDATA[I really need to。Here is the code I wrote myself without logic
library(MASS)
library(CDM)
set.seed(0)
参数设置
sample_sizes &lt;- c(100, 500, 1000) # 样本大小
num_attributes &lt;- c(3, 5, 8) # 属性数量级别
num_simulations &lt;- 2000 # 每种情况下的模拟次数
num_items &lt;- 20
num_students &lt;- 1000
存储结果
results &lt;- list()
for (k in num_attributes) {
创建独立属性的协方差矩阵
independent_cov &lt;- diag(1, k)
创建中度相关属性的协方差矩阵
moderately_correlated_cov &lt;- matrix(0, nrow = k, ncol = k)
diag(moderately_correlated_cov) &lt;- 1
moderately_correlated_cov[upper.tri(moderately_correlated_cov)] &lt;- runif((k*(k-1))/2, min = 0.3, max = 0.5)
moderately_correlated_cov[lower.tri(moderately_correlated_cov)] &lt;- t(moderately_correlated_cov)[lower.tri(moderately_correlated_cov)]
创建高度相关属性的协方差矩阵
highly_correlated_cov &lt;- matrix(0, nrow = k, ncol = k)
diag(highly_correlated_cov) &lt;- 1
highly_correlated_cov[upper.tri(highly_correlated_cov)] &lt;- runif((k*(k-1))/2, min = 0.5, max = 0.8)
highly_correlated_cov[lower.tri(highly_correlated_cov)] &lt;- t(highly_correlated_cov)[lower.tri(highly_correlated_cov)]
生成独立属性模式
independent_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = independent_cov)
true_attribute_patterns[[paste(k, &quot;independent&quot;, sep = &quot;_&quot;)]] &lt;- independent_attributes
生成中度相关属性模式
moderately_correlated_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = moderately_correlated_cov)
true_attribute_patterns[[paste(k, &quot;moderately_correlated&quot;, sep = &quot;_&quot;)]] &lt;- moderately_correlated_attributes
生成高度相关属性模式
highly_correlated_attributes &lt;- mvrnorm(n = num_students, mu = rep(0, k), Sigma = highly_correlated_cov)
true_attribute_patterns[[paste(k, &quot;highly_correlated&quot;, sep = &quot;_&quot;)]] &lt;- highly_correlated_attributes
}
for (n_sample in sample_sizes) {
for (n_attr in num_attributes_levels) {
# 根据属性数量确定Q矩阵中测量属性的概率
prob_attribute_measured &lt;- if (n_attr == 3) {
0.5
} else if (n_attr == 5) {
0.3
} else { # n_attr == 8
0.1825
}
辅助函数，生成模拟响应数据
simulateDataCDM &lt;- function(true_attribute_patterns, Q_matrix, num_items) {
此函数应生成符合DINA模型的学生响应模式
这里只是一个占位符
response_patterns &lt;- matrix(sample(0:1, nrow(true_attribute_patterns) * num_items, replace = TRUE), nrow = nrow(true_attribute_patterns))
return(list(
true_attribute_patterns = true_attribute_patterns,
response_patterns = response_patterns
))
}# 进行模拟
for (sim in 1:num_simulations) {
模拟属性掌握情况
true_attribute_patterns &lt;- matrix(runif(n_sample * n_attr) &lt; prob_attribute_measured, nrow = n_sample)
模拟Q矩阵
Q_matrix &lt;- matrix(runif(num_items * n_attr) &lt; prob_attribute_measured, nrow = num_items, ncol = n_attr)
生成模拟数据集
sim_data &lt;- simulateDataCDM(true_attribute_patterns, Q_matrix)
sim_data &lt;- simulateDataCDM(true_attribute_patterns, Q_matrix, num_items) # 这里传递num_items作为参数
拟合DINA模型
fit &lt;- din(data = sim_data$response_patterns, q.matrix = Q_matrix)
评估分类一致性和准确性
class_accuracy &lt;- cdm.est.class.accuracy(fit, sim_data$response_patterns)
存储结果
results[[paste(n_sample, &#39;sample&#39;, n_attr, &#39;attributes&#39;, sim, &#39;simulation&#39;, sep = &#39;_&#39;)]] &lt;- class_accuracy
}
}
}
对每种属性数量进行模拟
使用二分法将正态分布变量转换为二进制属性模式
假设大于等于0的值表示属性被掌握
for (i in names(true_attribute_patterns)) {
true_attribute_patterns[[i]] &lt;- ifelse(true_attribute_patterns[[i]] &gt;= 0, 1, 0)
}
查看生成的属性模式
true_attribute_patterns
评估所有模拟结果
evaluate_criteria &lt;- function(Pc, Pa) {
results &lt;- list(
Pc_mean = mean(Pc),
Pc_sd = sd(Pc),
Pc_skewness = skewness(Pc),
Pc_kurtosis = kurtosis(Pc),
Pa_mean = mean(Pa),
Pa_sd = sd(Pa),
Pa_skewness = skewness(Pa),
Pa_kurtosis = kurtosis(Pa)
)
Pc_theoretical_sd &lt;- sqrt(var(Pc) / length(Pc)) # 这里应用渐近正态理论
Pa_theoretical_sd &lt;- sqrt(var(Pa) / length(Pa)) # 同上
比较实证分布和理论分布
results$Pc_theoretical_sd_diff &lt;- abs(Pc_theoretical_sd - results$Pc_sd)
results$Pa_theoretical_sd_diff &lt;- abs(Pa_theoretical_sd - results$Pa_sd)
return(results)
}
调用评估函数
evaluate_all_simulations(results)]]></description>
      <guid>https://stats.stackexchange.com/questions/644779/reproduce-the-estimating-classification-consistency-and-accuracy-for-cognitive-d</guid>
      <pubDate>Thu, 11 Apr 2024 07:39:20 GMT</pubDate>
    </item>
    <item>
      <title>概率和运算顺序[重复]</title>
      <link>https://stats.stackexchange.com/questions/644778/probability-and-order-of-operations</link>
      <description><![CDATA[我很困惑......

&lt;标题&gt;


汽车
自行车
总线
其他


&lt;正文&gt;

新生
10
5
7
2


大二
20
10
11
5


初级
25
20
31
4


高级
18
17
16
14



如果我做 P（新生 | 巴士），答案将是 P（新生给巴士）或“巴士”组中有多少人？ （即 [7, 11, 31, 16]）是新生，即
7/(7 + 11 + 31 + 16) = 7/65
但是，如果我做 P（汽车 | 大二或大四）...
我可以将其视为 P((汽车 | 大二或大四) 或 P(汽车 | (大二或大四))
如果我假设 P((汽车 | 大二) 或大四)：
给定逻辑 P(A 或 B) = P(A) + P(B) - P(A 和 B)
并给出逻辑 P(A 和 B) = P(A) * P(B)，
我也可以构造这样的逻辑：P(A 或 B) = P(A) + P(B) - P(A) * P(B)
我假设：
P(A 或 B) = P(A) + P(B) - P(A) * P(B)
翻译为
P((汽车 | 大二) 或 高年级) = P(汽车 | 大二) + P(高年级) - P(汽车 | 大二) * P(高年级)
求解子方程：
P（汽车 | 大二）= 20 / (20 + 10 + 11 + 5) = 20/46 = 0.43478
P(高级) = (18 + 17 + 16 + 14) / (18 + 17 + 16 + 14 + 25 + 20 + 31 + 4 + 5 + 11 + 10 + 20 + 2 + 7 + 5 + 10 ) = 65/215 = 0.30233
这意味着：
P((汽车|大二)或大四) = 0.43478 + 0.30233 - 0.43478 * 0.30233
P((汽车|大二)或大四)= 0.60566
如果我假设 P(Car | (大二或大四))：
我可以将 [二年级，汽车] 单元格和 [高年级，汽车] 单元格相加，然后将结果除以高年级学生总数和二年级学生总数：
P(汽车 | (大二或大四)) = (20 + 18) / (20 + 10 + 11 + 5 + 18 + 17 + 16 + 14)
P(汽车 | (大二或大四)) = 38 / 111
P(汽车 | (大二或大四)) = 0.34234
我的困惑：
什么时候应该应用联合概率与边际概率？另外，我是否遗漏了一些关于首选操作顺序的内容，或者我是否在编造事情？]]></description>
      <guid>https://stats.stackexchange.com/questions/644778/probability-and-order-of-operations</guid>
      <pubDate>Thu, 11 Apr 2024 07:28:21 GMT</pubDate>
    </item>
    <item>
      <title>为什么在使用 lme4 比较 R 中结果变量的多级模型（对数变换与常规尺度）时 ICC 有所不同？</title>
      <link>https://stats.stackexchange.com/questions/644775/why-does-the-icc-differ-when-comparing-multilevel-models-log-transformations-vs</link>
      <description><![CDATA[我目前正在利用 lme4 包在 R 中开展一个多级建模项目。该研究的主要目的是评估家庭间和家庭内部差异在解释个人收入差异方面的相对重要性。通过检查类内相关系数 (ICC)，我试图量化家庭间差异与家庭内部差异所造成的总收入差异的比例。
为了进行此分析，我生成了一个综合数据集，其中包含嵌套在 40 个族中的 80 个观察值。每个观察结果都包括收入和年龄变量，并将个人分配到不同的家庭。随后，我安装了四个不同的多级模型：
利用原始收入规模（收入）的模型。
采用对数变换的收入规模（对数收入）的模型。
尽管使用相同的数据集，但我观察到这些模型的 ICC 值存在差异。这种不一致是出乎意料的，因为我认为 ICC 应该对结果变量规模的转换保持不变。
下面是我用来生成数据集并拟合模型的代码片段：
库(lme4)
设置.种子(123)

n &lt;- 80 # 观察值数量
n_families &lt;- 40 # 组（族）数量

# 一级变量（个人收入）
收入 &lt;- rnorm(n，平均值 = 40000，标准差 = 10000)

# 2 级变量（家庭效应）
family_id &lt;-rep(1:n_families, every = n/n_families) # 家庭归属
family_effect &lt;- rnorm(n_families,mean = 0,sd = 5000) # 家庭对收入的影响

# 根据family_id将家庭影响分配给个人收入
收入 &lt;- 收入 + family_effect[family_id]

# 创建数据框
data &lt;- data.frame(收入 = 收入, 年龄 = 年龄, family_id = 因子(family_id))
数据$log Revenue &lt;- log(data$收入)


# 使用 lmer 拟合多级模型
model_regular_scale &lt;- lmer(收入 ~ 1 + (1 | family_id), data = data)
model_log &lt;- lmer(logvenue ~ 1 + (1 | family_id), data = data)


# 模型总结
摘要（模型_常规_规模）
摘要（模型日志）
摘要（model_10）

# ICC值的计算
icc_regular_scale &lt;- 5518713/(5518713 + 91636300)
icc_log_scale &lt;- 0.003098/(0.003098 + 0.058133)

我将非常感谢任何关于为什么对数转换模型和非缩放模型之间 ICC 值不同的见解或建议。估计过程或结果解释是否存在潜在问题？感谢您的帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/644775/why-does-the-icc-differ-when-comparing-multilevel-models-log-transformations-vs</guid>
      <pubDate>Thu, 11 Apr 2024 06:20:00 GMT</pubDate>
    </item>
    <item>
      <title>关于分层对数秩检验的最早论文</title>
      <link>https://stats.stackexchange.com/questions/644772/earliest-paper-on-stratified-log-rank-test</link>
      <description><![CDATA[最早提出对数秩检验的分层版本的论文是什么？
不幸的是，在教科书中查找既定统计程序的引文/参考文献很困难。]]></description>
      <guid>https://stats.stackexchange.com/questions/644772/earliest-paper-on-stratified-log-rank-test</guid>
      <pubDate>Thu, 11 Apr 2024 03:24:52 GMT</pubDate>
    </item>
    <item>
      <title>滞后增强局部投影和标准误差</title>
      <link>https://stats.stackexchange.com/questions/644757/lag-augmented-local-projection-and-standard-errors</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/644757/lag-augmented-local-projection-and-standard-errors</guid>
      <pubDate>Wed, 10 Apr 2024 22:29:14 GMT</pubDate>
    </item>
    <item>
      <title>个体治疗和协变量与汇总调查结果之间的关联（仅每 1 个协变量）</title>
      <link>https://stats.stackexchange.com/questions/644754/association-between-individual-treatment-covariates-and-aggregated-survey-outc</link>
      <description><![CDATA[我想评估在给定协变量 X 的公司中，进行培训（治疗 T）的员工是否对成长机会（结果 Y）有更好的认知，例如：

性别、年龄范围
副方向、方向、执行方向
城市/国家
级别范围、合同类型

结果 Y（成长机会得分）是通过人力资源调查按照 11 点调查量表（NPS 量表范围从 0 到 10）进行衡量的。
由于这是一项调查，参与率并非 100%。
我们仅在每个协变量 X 的聚合水平上得到 Y（见上文）。
换句话说，我们得到每个协变量值的均值（无方差）。
协变量国家/地区示例：

英国国家/地区为 8.8
美国国家/地区为 6.2

治疗 T 定义为调查前（之前 12 个月）的训练时间总和。
这个数量在个体层面上是已知的，并且我们确实有个体层面上所有协变量 X（见上文）的值。

在这种情况下，采用个体治疗和自变量（协变量）以及仅 1 个自变量值的汇总结果（例如：按国家/地区）的建模方法是什么。

如果我想查看一组大于 1 的协变量的影响，该怎么办。如果有的话，建模方法是什么（可能有很多假设）？

]]></description>
      <guid>https://stats.stackexchange.com/questions/644754/association-between-individual-treatment-covariates-and-aggregated-survey-outc</guid>
      <pubDate>Wed, 10 Apr 2024 22:02:45 GMT</pubDate>
    </item>
    </channel>
</rss>