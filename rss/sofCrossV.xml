<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Sat, 02 Nov 2024 01:14:56 GMT</lastBuildDate>
    <item>
      <title>具有 2 个响应的贝叶斯线性回归的闭式解？</title>
      <link>https://stats.stackexchange.com/questions/656615/closed-form-solution-for-bayesian-linear-regression-with-2-responses</link>
      <description><![CDATA[我正在从频率论者的角度思考第一原理，从具有 1 个响应的回归转变为具有 2 个响应的回归。考虑到这一点，我正在尝试弄清楚如何将具有 1 个响应的贝叶斯线性回归转变为具有 2 个响应的回归。
单变量 OLS：假设我们处于通常的 OLS 设置中
$y = X\beta + \varepsilon$
在这种情况下，$y$ 是一个长度为 $n$ 的向量，$X$ 是一个 $n \times p$ 矩阵。频率派 OLS 解决方案是
$\hat{\beta} = (X^T X)^{-1} X^Ty$，其协方差是 $(X^T X)^{-1} \sigma^2 / (n-p)$
在 2 个响应的情况下，我们有
$Y = X\beta + E$
在这种情况下，$Y$ 和 $E$ 都是 $n \times 2$ 矩阵。频率派的解决方案是
$\hat{\beta} = (X^T X)^{-1} X^T Y$，其协方差是$(X^T X)^{-1} \otimes \Sigma$，其中$\otimes$是克罗内克积，$\Sigma$估计为$\hat{E}^T \hat{E}$，即残差的$2 \times 2$协方差矩阵。 $\hat{E}^T \hat{E}$ 的右上角显示了 2 个响应之间的相关性。
在具有 1 个响应且具有高斯先验的贝叶斯线性回归中，也有一个闭式解。假设 $\sigma^2$ 是固定的。先验服从正态分布，均值为 $\beta_0$，先验协方差为 $\Sigma_0$。
后验为
\begin{align}
p(\beta | X, y) &amp;= N(\beta_N, \Sigma_N) \\
\Sigma_N &amp;= (\Sigma_0^{-1} + \frac{1}{\sigma^2} X^T X)^{-1} \\
\beta_N &amp;= \Sigma_N (\Sigma_0^{-1} \beta_0 + \frac{1}{\sigma^2} X^T X \beta)
\end{align&gt;
是否有自然延伸当 $Y$ 是 2 列响应矩阵时，此代数解的解是什么？我特别想知道是否有频率论解的代数对应项，该解使用克罗内克积来模拟协方差矩阵的右上角，这反映了响应之间的相关性]]></description>
      <guid>https://stats.stackexchange.com/questions/656615/closed-form-solution-for-bayesian-linear-regression-with-2-responses</guid>
      <pubDate>Sat, 02 Nov 2024 00:26:14 GMT</pubDate>
    </item>
    <item>
      <title>时间相关效应：使用 coxph() 中的 nsk() 的 tt 函数</title>
      <link>https://stats.stackexchange.com/questions/656611/time-dependent-effects-tt-function-using-nsk-in-coxph</link>
      <description><![CDATA[我使用 coxph() 比较三种处理方法（大、小、对照）之间的树苗存活率数据。然而，coxzph() 显示小处理方法的系数随时间而变化。为了解决这个问题，我在 coxph () 中添加了一个 tt(Small)，并使用 nsk() 来实现回归样条，并且我正在使用指示变量进行治疗。
我的问题是，当使用 tt() 和 nsk() 时，系数是如何解释的，特别是对于时间相关变量？
以下是模型输出。
cox.tt4 &lt;- coxph (Surv (no.yrs.alive, censor) ~ Large + Small +
tt(Small) + frailty (Line), data = spruce.complete,
tt = function (x,t,...) x*nsk(t, knots = c(3)))
summary(cox.tt4)
## 调用：
## coxph(formula = Surv(no.yrs.alive, censor) ~ Large + Small + 
## tt(小) + frailty(Line), 数据 = spruce.complete, tt = function(x, 
## t, ...) x * nsk(t, knots = c(3)))
## 
## n= 96, 事件数= 35 
## 
## coef se(coef) se2 Chisq DF p 
## 大 -2.520 0.7409 0.7396 11.57 1.00 0.00067
## 小 -3.427 1.2067 1.2065 8.07 1.00 0.00450
## tt(小)1 3.056 1.7592 1.7585 3.02 1.00 0.08200
## tt(小)2 3.183 1.4072 1.4061 5.12 1.00 0.02400
## frailty(Line) 6.24 2.33 0.06000
## 
## exp(coef) exp(-coef) lower .95 upper .95
## Large 0.08044 12.43122 0.018830 0.3436
## Small 0.03249 30.77809 0.003052 0.3458
## tt(小)1 21.23826 0.04708 0.675532 667.7166
## tt(小)2 24.12159 0.04146 1.529754 380.3560
## gamma:L1 1.06620 0.93791 0.575824 1.9742
## gamma:L2 0.59206 1.68903 0.283618 1.2359
## gamma:L3 1.27464 0.78454 0.713532 2.2770
## gamma:L5 1.39426 0.71722 0.780017 2.4922
## gamma:L6 0.67284 1.48624 0.326825 1.3852
## 
## 迭代次数：6 外部，22 Newton-Raphson
## 随机效应方差 = 0.1925677 I-似然 = -134.1 
## 项的自由度 = 1.0 1.0 2.0 2.3 
## 一致性 = 0.813 (se = 0.041 )
## 似然比检验 = 44.22 on 6.32 df, p=9e-08

时间相关的 Therneau 等人。 2024 插图第 4.2 节指出“系数是节点 2、3 处的预测值，... - 节点 1 处的预测值”。
在这种情况下，这是否意味着第一个时间段（时间 0 到时间 3）的小治疗系数将是 -3.427 + 3.056 = -0.371？而对于第二个时间段（&gt;时间 3），-3.427 + 3.056 = -0.244？
此外，我可以对这些系数取指数来计算相对于参考治疗的风险比，两个时间段的风险比不同吗？
我对这种方法还不熟悉，非常感谢任何见解或建议。]]></description>
      <guid>https://stats.stackexchange.com/questions/656611/time-dependent-effects-tt-function-using-nsk-in-coxph</guid>
      <pubDate>Fri, 01 Nov 2024 20:17:45 GMT</pubDate>
    </item>
    <item>
      <title>如何计算和解释 R 中的多级方差膨胀因子？</title>
      <link>https://stats.stackexchange.com/questions/656610/how-to-compute-and-interpret-a-multilevel-variance-inflation-factor-in-r</link>
      <description><![CDATA[我正在 R 中运行一些多级（混合效应）模型，该模型有两个级别：三个评估时间点（级别 1）在个体内聚类（级别 2）。我想检查模型中预测因子之间的多重共线性。这是一个示例模型，其中焦虑（主要预测因子）和抑郁（协变量）预测担忧，焦虑在每个时间点都以人均值为中心（级别 1），并且对每个人的时间点取平均值（级别 2）。
lmer(worry ~ anxious_person_centered + anxious_person_mean_centered + inhibition + (1|participant)

这个 10 年前的问题是 Cross Validated 上唯一相关的问题，它链接到这个 13 年前的博客帖子，其中提供了git 存储库中的一些代码来计算多级方差膨胀因子，复制如下。fit 参数是要测试的 lmer 模型。
vif.mer &lt;- function (fit) {
## 改编自 rms::vif

v &lt;- vcov(fit)
nam &lt;- names(fixef(fit))

## 排除截距
ns &lt;- sum(1 * (nam == &quot;Intercept&quot; | nam == &quot;(Intercept)&quot;))
if (ns &gt; 0) {
v &lt;- v[-(1:ns), -(1:ns), drop = FALSE]
nam &lt;- nam[-(1:ns)]
}

d &lt;- diag(v)^0.5
v &lt;- diag(solve(v/(d %o% d)))
names(v) &lt;- nam
v}

我试过这个代码，它给了我每个预测变量的一个数字，但我不明白它是如何获得这些数字的。出于出版原因，我需要能够引用一篇已发表的经验文章（不是博客文章），说明计算多级 VIF 是一件事情，并且这个代码可以完成它应该做的事情。我无法引用Patrick Carl Clark Jr 未发表的论文，而且我很难理解Yu 及其同事 (2015) - 我不知道“条件数 kappa”是什么。
您能否像我是一名聪明的高中生一样向我解释一下上述多层级 VIF 代码的作用，并提供此方法的引用（如果有的话）来帮助我解释？]]></description>
      <guid>https://stats.stackexchange.com/questions/656610/how-to-compute-and-interpret-a-multilevel-variance-inflation-factor-in-r</guid>
      <pubDate>Fri, 01 Nov 2024 20:16:29 GMT</pubDate>
    </item>
    <item>
      <title>交叉验证子弹穿透松木的效果 [关闭]</title>
      <link>https://stats.stackexchange.com/questions/656609/cross-validate-the-penetration-of-a-bullet-into-pine-wood</link>
      <description><![CDATA[这是针对 Skeptics Stack Exchange 提出的一个问题，重点关注 9 毫米子弹穿透木材的情况：

问题：基于抗拉强度和动能，预测 9 毫米尖头子弹穿透木材的深度的理论模型有多准确？
在最近的一次讨论中，提出了一个理论模型来计算 9 毫米子弹穿透木材的深度，其中考虑了抗拉强度、动能、长径比 (L/D) 和弹丸形状。该模型表明，穿透深度可以通过以下过程确定：

抗拉强度：木材的抗拉强度约为 50 MJ/kg，考虑到木材密度（500 kg/m³），则为 25,000,000 J/m³。

动能计算：对于典型的 9 毫米子弹，其质量为 0.0075 kg，速度为 360 m/s，动能计算为大约 486 J。

初始穿透深度：使用每单位体积的动能与抗拉强度之比，初始穿透深度计算为大约 1.94 毫米。

长径比和形状的调整：考虑考虑到长径比为 2 和弹丸的形状（据报道，尖头弹丸的穿透效果是钝弹丸的两倍），最终调整后的穿透深度估计约为 7.76 毫米。


实际测量到的硬木穿透深度约为 3 英寸或 60 毫米，或三倍。额外的尖头调整，考虑木材和谷物的弹性区域，将穿透深度提高到 62.08 毫米或 2.5 英寸。
未成熟松木的抗拉强度为 20mpa，由于我们使用速度较低的子弹，实际穿透深度可能更高。互联网来源指出 9 毫米子弹可以穿透 9 英寸的松木板。
根据这些计算，这些理论模型在预测实验数据中观察到的实际穿透深度方面有多可靠？是否有具体研究或实证测试可以证实或反驳该模型对 9 毫米弹丸穿透木材的预测？

此问题征求专家意见并参考实证研究，适合 Skeptics Stack Exchange。如果您需要调整或附加详细信息，请告诉我！]]></description>
      <guid>https://stats.stackexchange.com/questions/656609/cross-validate-the-penetration-of-a-bullet-into-pine-wood</guid>
      <pubDate>Fri, 01 Nov 2024 19:42:20 GMT</pubDate>
    </item>
    <item>
      <title>统计学习要素公式 2.28</title>
      <link>https://stats.stackexchange.com/questions/656608/elements-of-statistical-learning-equation-2-28</link>
      <description><![CDATA[我正在阅读 T.Hastie 的《统计学习要素》。我对公式 2.28 感到困惑

我其实不是想推导这个公式，而是想通过实验来了解它。然而，我得到的结果总是方差项。我根本看不到 var*p/N 项。所以我认为我还没有完全理解这个设置。目前我有以下内容

一个函数 f(x)，它在输入 X 中是线性的，但包含一个噪声参数
 def f(X):
n,p = X.shape
beta = np.arange(p)/p
result = np.dot(X, beta)
noise = np.random.normal(0, 1, n)
return result + noise


X 是一个取自均匀分布 U[-1,1]^p 的 p 维数组

我有一个函数 fhat(x0) 来估计 f(x0) 的输出：

以 x0 作为参数。该函数将返回 yhat0。

生成 1000 个 X 样本

对每个样本调用 f(x) 以生成 1000 个 y（目标）样本

拟合用 X 和 y 参数化的线性回归

通过在模型上调用 predict(x0) 返回 y0 的估计值
 def fhat(x0, n_samples=1_000):
p= x0.shape[1]
X = X = np.random.uniform(-1, 1, (n_samples, p))
y = f(X)
model = LinearRegression(fit_intercept=False)
model.fit(X, y)
y_hat0 = model.predict(x0)
return y_hat0[0]




一次实验涉及以下步骤

从分布中提取一个 X 值并将其称为 x0
通过调用 f(x0) 1000 次生成 1000 个 y0 的向量
通过调用 fhat(x0) 1000 次生成 1000 个 yhat0 的向量
将 EPE 计算为 EPE = np.mean((y0 - y_hat)**2)
根据书中的公式 2.27 断言 EPE = var(y0) + var(noise)

def run_once(n_loops=1_000, n_samples=1_000):
x0 = np.random.uniform(-1, 1, (1,5))
y0 = f(x=np.repeat(x0, n_loops, axis=0))
yhat0 = np.zeros(n_loops)
for i in range(n_loops):
yhat0[i] = fhat(x0, n_samples=n_samples)
EPE = np.mean((y0 - y_hat)**2)
var = y_hat.var()
noise_var =1 # 噪声的方差为 1
assert np.isclose(EPE, var + noise_var, atol=0.01) # ESL 书中的方程 2.27
return EPE```



如果我运行上面的代码，我会看到我想要的结果从 ESL 方程 2.27 中得到期望。EPE 等于 var(noise) + var(y0)。所以我很有信心我做对了这一点

对于上述情况，x0 始终是相同的样本。据我了解，要看到 2.28 的结果，需要进行更改，我们需要用许多 x0 重复上述实验。即它是所有 x0 的期望。但是，当我多次运行上述操作时，我没有看到 EPE(所有 x0)=var(noise)*p/N + var(noise) 的预期结果。我只看到 EPE(所有 x0)=var(噪音)


def run_many_points(n, p):
results = np.zeros(n)
for i in range(n):
x0= np.random.uniform(-1, 1, (1,p))
EPE = run_once(x0, n=1000, n_samples=200)
print(f&quot;Processing {i+1}/10&quot;, end=&#39;\r&#39;)
return results.mean()
r20 = run_many_points(300, 20)
print(r20)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
1.002

有人能发现我做错了什么吗？等式中的 N 值是每次测试的样本数 T 吗？还是所有测试的数量？如果是所有测试的数量，那么在实验中可能很难证明这一点……]]></description>
      <guid>https://stats.stackexchange.com/questions/656608/elements-of-statistical-learning-equation-2-28</guid>
      <pubDate>Fri, 01 Nov 2024 18:32:52 GMT</pubDate>
    </item>
    <item>
      <title>估计 PyMC 中截断分布的参数</title>
      <link>https://stats.stackexchange.com/questions/656607/estimating-the-parameters-of-a-truncated-distribution-in-pymc</link>
      <description><![CDATA[我是 PyMC 的新手，我正在尝试估算我的数据集的广义极值分布的参数。我的数据已被人为截断，因此我想使用此分布的截断版本。我可以在不截断的情况下估计 GEV 分布的参数，但我在截断分布时遇到了麻烦。
下面的代码确实有效，无需截断：
data = read_in_data() # 一个 numpy 浮点数组
basic_model = pm.Model()
with basic_model: 
# Priors 
mu = pm.Uniform(&quot;mu&quot;, lower = 1300, upper = 1500)
sigma = pm.Uniform(&quot;sigma&quot;, lower = 90, upper = 150)
xi = pm.TruncatedNormal(&quot;chi&quot;, mu=0, sigma=0.4, lower=-0.7, upper=0.7) 
# 估计
gev = pmx.GenExtreme(&quot;gev&quot;, mu=mu, sigma=sigma, xi=xi, perceived=data)
gev_idata = pm.sample()

但是，我相信我的数据来自截断的 GEV 分布。在阅读此处的文档后，我尝试使用截断的 GEV 分布，如下所示：
data = read_in_data() # 一个 numpy 浮点数组
basic_model = pm.Model()
with basic_model: 
# Priors 
mu = pm.Uniform(&quot;mu&quot;, lower = 1300, upper = 1500)
sigma = pm.Uniform(&quot;sigma&quot;, lower = 90, upper = 150)
xi = pm.TruncatedNormal(&quot;chi&quot;, mu=0, sigma=0.4, lower=-0.7, upper=0.7) 
# 估计
gev_full = pmx.GenExtreme.dist(&quot;gev_full&quot;, mu=mu, sigma=sigma, xi=xi)
gev = pm.Truncated(&quot;gev&quot;, gev_full, upper=2000, lower = None, perceived=data)
gev_idata = pm.sample()

我收到错误：
TypeError: GenExtreme.dist() 获得了参数“mu”的多个值

我还尝试不为 mu、sigma 和 xi 定义先验，以防它不期望参数上的分布，但如果我省略这些行，我仍然会收到相同的错误。我在 Google 上搜索了一番，但还是无法找出导致此错误的原因。
如何实现截断的 GEV 分布？提前致谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/656607/estimating-the-parameters-of-a-truncated-distribution-in-pymc</guid>
      <pubDate>Fri, 01 Nov 2024 18:26:07 GMT</pubDate>
    </item>
    <item>
      <title>使用 k 倍交叉验证进行阈值移动</title>
      <link>https://stats.stackexchange.com/questions/656605/threshold-moving-with-k-fold-cross-validation</link>
      <description><![CDATA[我的数据存在类别不平衡问题（1:10 比例），因此我实施了一些策略，包括加权随机采样器、加权损失函数、阈值移动、数据增强（并非总是一起实施，只是观察了每种策略如何影响测试结果）。
我目前正在研究癌症数据集的二分类问题。我很好奇的是，如果我在流程中有一个 K 倍交叉验证工作流程，我将如何在没有保留测试样本的情况下选择最佳阈值？我在网上读到的是，您应该根据每个阈值收集所有感兴趣的指标（例如，F1 分数）值，并选择在交叉验证循环之外的不同折叠上产生最高平均 F1 分数的最佳阈值。有人可以分享他们对上述情况的知识吗？
另一个问题是，当我实施上述操作时，最佳阈值高于 0.5，这会将所有正样本归类为负样本……因为这会导致高精度值。显然，这不是我希望我的分类器做的事情。这是否意味着阈值移动技术不是最适合我的数据的方法？
谢谢，您能分享一下处理不平衡数据的经验吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/656605/threshold-moving-with-k-fold-cross-validation</guid>
      <pubDate>Fri, 01 Nov 2024 16:53:28 GMT</pubDate>
    </item>
    <item>
      <title>0 到 1 之间的多元分布，其总和不等于 1</title>
      <link>https://stats.stackexchange.com/questions/656604/multivariate-distribution-of-values-between-0-and-1-that-does-not-sum-up-to-1</link>
      <description><![CDATA[我想知道是否存在像狄利克雷分布（在 0 和 1 之间）这样的多元分布，其值的总和不等于 1。
我不希望它是 Beta 分布的乘积，因为我不想假设我的变量之间是独立的。
提前谢谢您]]></description>
      <guid>https://stats.stackexchange.com/questions/656604/multivariate-distribution-of-values-between-0-and-1-that-does-not-sum-up-to-1</guid>
      <pubDate>Fri, 01 Nov 2024 16:53:10 GMT</pubDate>
    </item>
    <item>
      <title>逻辑回归和多组研究设计</title>
      <link>https://stats.stackexchange.com/questions/656602/logistic-regression-and-study-design-with-multiple-groups</link>
      <description><![CDATA[我们正在进行一项回顾性研究，调查与术后并发症相关的因素。我们的患者分为三组：A) 无并发症、B) 仅有轻度并发症和 C) 严重并发症。
我们首先使用所有患者建立了一个逻辑回归模型，结果是“任何并发症”。我们现在正在考虑仅涉及 A 组和 C 组的第二个逻辑模型，结果是“仅有严重并发症”。我们希望第二个模型能够产生更显著的结果，并允许我们比较两种并发症的因素。
我想知道我们的建模方法是否有效。具体来说，由于我们将在第二个模型中完全删除 B 组，人们是否会认为这是在挑选我们的参与者并造成偏见？
谢谢。]]></description>
      <guid>https://stats.stackexchange.com/questions/656602/logistic-regression-and-study-design-with-multiple-groups</guid>
      <pubDate>Fri, 01 Nov 2024 16:25:23 GMT</pubDate>
    </item>
    <item>
      <title>大样本的小效应量产生显著的结果，如何理解</title>
      <link>https://stats.stackexchange.com/questions/656591/small-effect-size-with-large-sample-yields-significant-result-how-to-understand</link>
      <description><![CDATA[1.我无法理解小效应如何通过大样本产生显著结果？当我使用代码而不是抽象公式时，我发现它更清楚。
我创建了两个数组samples和samplesC（实验值）。
使用截断正态分布来生成正态分布。
这些值绘制在上图中。在下图中，从这些值中随机选择n个值，N是次数。值沿x轴绘制，概率沿y轴绘制。效果的功率和大小显示在屏幕上。 N，n 可以改变，图形会动态重绘。
如果我选择 N=1 并增加 n，我看不到功率变大。
2.我在网上找到的所有例子，在计算功率时，右边都有一个实验性的（红色）分布。左边可以有实验分布吗？那么功效是如何计算的？
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from scipy.stats import norm, truncnorm

N = 1000
mu, sigma = 80, 21
lower, upper = 30, 120
muC, sigmaC = 84, 21
lowerC, upperC = lower + 3, upper + 3

samples = np.sort(truncnorm.rvs(
(lower - mu) / sigma, (upper - mu) / sigma, loc=mu, scale=sigma, size=N, random_state=0))
samplesC = np.sort(truncnorm.rvs(
(lowerC-muC)/sigmaC,(upperC-muC)/sigmaC,loc=muC,scale=sigmaC,size=N, random_state=0))

pdf = norm.pdf(samples, np.mean(samples), np.std(samples))
pdfC = norm.pdf(samplesC, np.mean(samplesC), np.std(samplesC))

fig, ax = plt.subplots(2)
fig.subplots_adjust(bottom=0.25)

ax[0].plot(samples, pdf, lw=2, color=&quot;blue&quot;, label=&quot;H0&quot;)
ax[0].plot(samplesC, pdfC, lw=2, color=&quot;red&quot;, label=&quot;H1&quot;)
ax[0].legend()

ax_N = fig.add_axes([0.25, 0.1, 0.65, 0.03])
ax_n = fig.add_axes([0.25, 0.05, 0.65, 0.03])
s_N = Slider(ax_N, &quot;N&quot;, valmin=1, valmax=300,valinit=1, valstep=1)
s_n = Slider(ax_n, &quot;n&quot;, valmin=1, valmax=300,valinit=25, valstep=1)

def update(val):
N = s_N.val
n = s_n.val
generation = np.sort(np.array([np.random.choice(samples, n) for _ in range(N)]).ravel())
generationC = np.sort(np.array([np.random.choice(samplesC, n) for _ in range(N)]).ravel())
mu_samples, mu_samplesC = np.mean(generation), np.mean(generationC)
std_samples, std_samplesC = np.std(generation), np.std(generationC)
pdf = norm.pdf(generation, mu_samples, std_samples)
pdfC = norm.pdf(generationC, mu_samplesC, std_samplesC)

interval = norm.interval(confidence=0.95, loc=mu_samples, scale=std_samples)
cdf = norm.cdf(interval[1], mu_samplesC, std_samplesC)
x, y = mu_samples, (np.max(pdf) + np.min(pdf)) / 2

effect_size = (abs(mu_samples - mu_samplesC) /
np.sqrt((std_samples ** 2 + std_samplesC ** 2) / 2))

ax[1].clear()
ax[1].plot(generation, pdf, lw=2, color=&quot;blue&quot;, label=&quot;H0&quot;)
ax[1].plot(generationC, pdfC, lw=2, color=&quot;red&quot;, label=&quot;H1&quot;)
ax[1].axvline(x=interval[1], linestyle=&quot;--&quot;, color=&quot;red&quot;)
ax[1].text(x, y, &quot;power =&quot; + str(round(1 - cdf, 4)) +
&quot;\n&quot; + &quot;Cohen&#39;s d =&quot; + str(round(effect_size, 4)), fontsize=12)

s_n.on_changed(update)
s_N.on_changed(update)
update(0)

plt.show()
]]></description>
      <guid>https://stats.stackexchange.com/questions/656591/small-effect-size-with-large-sample-yields-significant-result-how-to-understand</guid>
      <pubDate>Fri, 01 Nov 2024 13:23:20 GMT</pubDate>
    </item>
    <item>
      <title>恒定均值过程的后验预测分布</title>
      <link>https://stats.stackexchange.com/questions/656574/posterior-predictive-distribution-for-constant-mean-process</link>
      <description><![CDATA[考虑一个恒定均值过程
$$y_i = \mu + \varepsilon_i,$$
其中误差项是独立同分布的高斯分布，方差相同$\sigma^2$。假设我们得到数据$ y = y_1, \ldots, y_t$。从贝叶斯的角度来看，我想获得总和 $z = \sum_{i=t+1}^{t+\tau} y_i$ 的后验预测分布的明确表达式，对于任何 $\tau \geq 1$。
现在后验预测分布如下
$$ p(z | y) = \int p(z | \mu, \sigma^2) p(\mu, \sigma^2 | y) \,d\mu \, d\sigma^2.$$
由于独立性假设，我们有
$$p(z | \mu, \sigma^2) = \mathrm{N}(\tau \mu, \tau\sigma^2).$$
此外，假设$\mu$和$\sigma$的标准不当先验，它们的后验分布为
$$p(\mu, \sigma^2 | y) \propto \sigma^{-t-2} \exp \Big( - \frac{1}{2 \sigma^2} [(t-1)s^2 + t(\bar{y} - \mu)^2] \Big),$$
其中$\bar{y} = \frac{1}{t}\sum_{i=1}^t y_i$是样本平均值，$s^2 = \frac{1}{t-1}\sum_{i=1}^t (y_i - \bar{y})^2$ 是样本方差。

当我尝试使用这些表达式来计算积分时，我陷入了困境。具体来说，我尝试将 $p(z | \mu, \sigma^2)$ 中的项 $(z - \tau \mu)^2$ 扩展为 $((z - \tau \bar{y}) + (\tau \bar{y} - \tau \mu))^2$，但我不确定如何处理“交叉项”。
对于 $\tau = 1$，$p(z | y)$ 是一个 $t$ 分布，位置为 $\bar{y}$，尺度为 $(1 + \frac{1}{t})^{\frac{1}{2}}s$，以及 $t - 1$ 自由度 (Gelman 等人，贝叶斯数据分析，第 66 页)。因此，我怀疑，一般来说，$p(z | y)$ 也是一个 $t$ 分布。位置将是 $\tau \bar{y}$，自由度将是相同的，尺度将是 $\tau$ 的某个函数。
]]></description>
      <guid>https://stats.stackexchange.com/questions/656574/posterior-predictive-distribution-for-constant-mean-process</guid>
      <pubDate>Fri, 01 Nov 2024 01:23:59 GMT</pubDate>
    </item>
    <item>
      <title>$R^2$ 与相互信息之间的联系</title>
      <link>https://stats.stackexchange.com/questions/656573/connection-between-r2-and-mutual-information</link>
      <description><![CDATA[将 MI 解释为“通过添加一些信息消除的不确定性量”，我希望与 $R^2$ 有某种联系，它是“通过添加一些信息解释的方差量”。
特别是，$I(X,Y) = H(Y)-H(Y|X)$，其表述不当，即“您对 $Y$ 一开始有多不确定” - “在了解 $X$ 之后，您对 $Y$ 有多不确定”
另一方面，$R^2 = 1-\frac{\sum (y_i - f(x_i))^2}{\sum (y_i - \bar{y})^2}$，对我来说，这可能是错误的，它有点假设 $p(Y|X) \sim N(0, \sigma_1^2)$ 其中 $\sigma_1^2 = N^{-1}\sum (y_i - f(x_i))^2$ 和 $p(Y)\sim N(0, \sigma_2^2)$ 其中 $\sigma_2^2 = N^{-1}\sum (y_i - \bar{y})^2$... 这给我们留下了 $R^2 = 1-E_x[Var[p(y|x)]]/Var[p(y)]$
现在，如果我们定义 $\hat{R^2} = \frac{Var[p(y)]}{E_x[Var[p(y|x)]]} \propto R^2$（以非线性方式成比例），我会说它看起来像这样：
$$
I(X,Y) \stackrel{?}{=} \alpha\ln \hat{R^2} = \alpha(\ln(Var[p(y)]) -\ln(E_x[Var[p(y|x)]])),\,\, \text{for some }\alpha \in \mathbb{R}^+
$$
事实上，高斯分布的熵是 $\ln c\sigma^2$
换句话说，如果我们假设 $p(y)$ 和 $R^2$（或者至少是其虚构的兄弟 $\hat{R^2}$）和相互信息之间似乎确实存在联系class=&quot;math-container&quot;&gt;$p(y|x)$ 为高斯
我做错了什么/说了什么编造的东西吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/656573/connection-between-r2-and-mutual-information</guid>
      <pubDate>Fri, 01 Nov 2024 01:00:27 GMT</pubDate>
    </item>
    <item>
      <title>累积发生率函数 - 比较达到特定累积发生率的时间</title>
      <link>https://stats.stackexchange.com/questions/656461/cumulative-incidence-function-compare-time-at-which-a-specific-cumulative-inci</link>
      <description><![CDATA[我有生存数据，并绘制了按治疗状态分层的累积发病率函数（以年龄为时间尺度）。我使用 Gray 检验来比较总体累积发病率函数，并比较了特定年龄/时间的累积发病率。我还想比较达到给定发病率的年龄。例如，我想估计两组达到 25% 累积发病率的年龄，并比较年龄以询问未治疗组是否比治疗组明显更早达到 25% 的累积发病率。我可以从累积发病率函数中确定每组达到 25% 累积发病率的年龄，但我不确定如何计算方差/进行假设检验。是否可以根据累积发病率函数计算出这个值？]]></description>
      <guid>https://stats.stackexchange.com/questions/656461/cumulative-incidence-function-compare-time-at-which-a-specific-cumulative-inci</guid>
      <pubDate>Tue, 29 Oct 2024 14:12:19 GMT</pubDate>
    </item>
    <item>
      <title>重现期与概率的关系</title>
      <link>https://stats.stackexchange.com/questions/656532/relationship-between-return-period-and-probability</link>
      <description><![CDATA[据我了解，事件（例如地震或洪水）的重现期是该事件连续两次发生之间的平均时间。重现期为 $r$ 的事件发生的概率为 $1/r$。例如，如果强烈地震的重现期为 $10$ 年，则每年发生地震的概率为 $1/10$。
我不太明白为什么发生概率与重现期成倒数。例如，如果某件事通常每 $10$ 年发生一次，为什么它在任何一年发生的概率是 $1/10$？]]></description>
      <guid>https://stats.stackexchange.com/questions/656532/relationship-between-return-period-and-probability</guid>
      <pubDate>Mon, 28 Oct 2024 16:05:02 GMT</pubDate>
    </item>
    <item>
      <title>如何模拟具有 L1 和 L2 方差分量的多层预测变量？</title>
      <link>https://stats.stackexchange.com/questions/656404/how-to-simulate-a-multilevel-predictor-variable-with-both-l1-and-l2-variance-com</link>
      <description><![CDATA[我正在模拟多级数据，其中我有一个在级别 1 (L1) 上测量的预测变量，它同时具有 L1 和 L2 方差分量。例如，我想模拟在学校班级内以个人级别测量的社会经济地位 (SES) 变量。在多级模型中，我通常使用组均值中心化来分离此预测变量的组内 (L1) 和组间 (L2) 方差。
具体来说，我感兴趣的是模拟 L1 预测变量（例如，个人 SES）及其以组均值为中心的对应变量，以捕获组级 (L2) 方差。我的目标是创建以下数据：
反映 SES 的组内和组间变异性。
允许我使用多级建模方法来解开这些方差分量，类似于组均值中心化在实际数据中的工作方式。
我的问题是：
我该如何模拟具有 L1 和 L2 方差的 L1 预测变量？
我应该遵循哪些步骤来生成 L2 上的组均值中心版本？
这里是一篇关于类似问题的精彩帖子。
模拟 L1 预测器然后在 L2 上创建它的中心版本并不难。但是，在这种方法中，L1 没有真正的 L2 方差：
# 定义模拟参数
n_groups &lt;- 50 # 组数（级别 2）
n_individuals &lt;- 10 # 每组个体数（级别 1）
total_n &lt;- n_groups * n_individuals

# 定义方差
between_var &lt;- 1 # 组间方差
within_var &lt;- 0.5 # 组内方差

# 模拟每个组的随机截距（级别 2 随机效应）
group_effect &lt;- rnorm(n_groups, mean = 0, sd = sqrt(between_var))

# 创建一个数据框来存储模拟数据
data &lt;- data.frame(
group_id = rep(1:n_groups, each = n_individuals),
individual_id = 1:total_n
)

# 生成具有组内和组间变异性的 1 级预测因子 `x1ij`
data$x1ij &lt;- group_effect[data$group_id] + rnorm(total_n, mean = 0, sd = sqrt(within_var))

# 计算 `x1ij` 的组均值（2 级组件）
data$x1j_mean &lt;- ave(data$x1ij, data$group_id, FUN = mean)

# 创建以组均值为中心的 `x1ij` 版本
data$x1ij_centered &lt;- data$x1ij - data$x1j_mean

# 显示数据集的前几行
head(data)
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/656404/how-to-simulate-a-multilevel-predictor-variable-with-both-l1-and-l2-variance-com</guid>
      <pubDate>Mon, 28 Oct 2024 10:00:42 GMT</pubDate>
    </item>
    </channel>
</rss>