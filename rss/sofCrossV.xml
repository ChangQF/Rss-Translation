<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Thu, 05 Sep 2024 01:11:13 GMT</lastBuildDate>
    <item>
      <title>多元回归 G*Power 中功效分析的预测变量与控制变量</title>
      <link>https://stats.stackexchange.com/questions/653879/predictor-variables-vs-control-variables-for-power-analyses-in-multiple-regressi</link>
      <description><![CDATA[我正在使用 GPower 来了解在分层多元回归模型的第二步和第三步中检测中等效应大小所需的样本量。为此，GPower 要求提供假设的相关矩阵。我的问题是相关矩阵是否应包括所有 5 个变量，还是仅包括两个理论上有趣的变量。任何帮助都将不胜感激！]]></description>
      <guid>https://stats.stackexchange.com/questions/653879/predictor-variables-vs-control-variables-for-power-analyses-in-multiple-regressi</guid>
      <pubDate>Thu, 05 Sep 2024 00:26:24 GMT</pubDate>
    </item>
    <item>
      <title>贝叶斯回归中是否允许强制参数值之间的相关性</title>
      <link>https://stats.stackexchange.com/questions/653877/is-forcing-correlation-between-parameter-values-allowed-in-bayesian-regression</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/653877/is-forcing-correlation-between-parameter-values-allowed-in-bayesian-regression</guid>
      <pubDate>Wed, 04 Sep 2024 23:24:30 GMT</pubDate>
    </item>
    <item>
      <title>适合我的实验的统计方法</title>
      <link>https://stats.stackexchange.com/questions/653871/appropriate-statistical-approach-for-my-experiment</link>
      <description><![CDATA[我需要一些关于我想运行哪种统计分析的建议。
我进行了一项实验，开始时有 20 种细菌菌株，数量相等。该实验有 4 种感兴趣的处理方法，每种处理方法重复 15 个种群。该实验进行了数月，种群数量增长相当大。最后，我从每个种群中分离出 3 个单独的细菌，并确定它们属于 20 种原始细菌菌株中的哪一种。每个处理方法有 15 个重复种群，因此每个处理方法识别出 45 种菌株，总共识别出 180 种菌株。
我想弄清楚的是如何确定这 4 种不同的处理方法最终是否在 20 种起始菌株中选择了不同的菌株。从定性上看，我可以看到存在差异；有些处理方法比其他处理方法多得多。但从统计学上看，我很难确定应该使用哪种方法。我觉得我应该使用某种二项式或卡方方法，因为它们实际上代表了从人群中随机抽取的结果。但由于有多种可能的菌株可供选择，我不知道该怎么做。]]></description>
      <guid>https://stats.stackexchange.com/questions/653871/appropriate-statistical-approach-for-my-experiment</guid>
      <pubDate>Wed, 04 Sep 2024 19:59:03 GMT</pubDate>
    </item>
    <item>
      <title>检查某个事件是否导致了语料库中某些单词的出现发生变化</title>
      <link>https://stats.stackexchange.com/questions/653869/check-whether-an-event-made-a-change-in-the-appearance-of-certain-words-in-a-cor</link>
      <description><![CDATA[场景
我正在研究 1980 年至 2000 年期间学生撰写的 100,000 篇学术论文。我认为 1999 年底的某个特定事件可能增加了某些特定主题术语的使用。我有一个包含 1000 个单词的列表 $A$，我认为它的使用量可能会增加；还有一个包含 1000 个单词的列表 $b_1, b_2, ..., b_{1000}$，是我从论文中随机抽取的。我确保所有 2000 个单词每年至少在一篇论文中出现一次，并且它们都是不同的，因此列表内没有重叠，列表之间也没有重叠。
理想情况下，我想检查 A 中的单词在 2000 年是否“比正常情况”增加。与 B 进行比较可以帮助我检查这种增加是否不是每个单词都如此，与 1999 年之前的年份进行比较可以让我检查这种波动是否不常见。但是，我受到所拥有的数据类型的限制。这种情况是相当人为的，所以请耐心等待。
现在，我无法直接访问这些论文，但我可以使用搜索引擎来扫描给定年份的论文中出现了多少个单词。每年的论文数量不同；我知道每年的数量。
示例
1980 年有 4567 篇论文。对于 $A$ 和 $B$ 中的每个单词，我都可以提取包含该单词的论文数量。将其除以 4567，我可以轻松计算出该单词出现的论文比例。因此，例如，我可以告诉您 $a_1$ 出现在 1980 年的 3456 篇论文中，比例为 3456/4567。比较$a_1$在一年中出现的论文数量意义不大，因为论文数量每年都在变化，但我可以计算出$a_1$在论文中的比例每年的绝对和相对增加/减少。
问题
现在，我可以对我拥有的$A$中单词的数据运行什么样的测试来检查我看到的这个统计数据的增长是否显著？我的怀疑，以及我想要测试的是，从 1999 年到 2000 年，A 中的单词的相对比例发生了变化，而我在 B 中或之前几年（即从 1998 年到 1999 年、从 1997 年到 1998 年等）没有看到这些单词。回顾一下，比例是论文中至少出现一次该单词的比例，这里的相对意味着我认为从 2% 到 4% 的增长比从 50% 到 55% 的增长要高得多。
附加信息：

年复一年，包含单词 $w$ 的论文百分比，无论 $w$ 是在 $A$ 中还是 $B$，增加。因此，任何类似列联表的东西实际上都不起作用：我从来不指望比例是稳定的。我或许可以使用 $B$ 中的数据来估计每年的随机增长是多少——单词比例的相对增长似乎是——但我知道如何正确地做到这一点。
我无法绘制任何其他数据。具体来说，我们无法获得单词的实际频率（单词出现的次数/文本的长度）。我知道这极大地限制了结果。
我完全可以接受逐年进行比较；我不想进行多年的比较。

我的想法
这是我能想到的最好的办法：我可以计算 1999-2000 年 2000 个单词中每个单词 $w$ 的论文比例的相对变化（例如，一个单词从 2% 变为 4%，则得分为 200% 的变化）。然后，我使用 Kolmogorov–Smirnov 检验比较 $A$ 中的单词和 $B$ 中的单词的结果：如果 1999 年的大事件有影响，我应该检测到两个不同的分布。相反，对 1999 年之前的每一年进行同样的操作应该会得到相反的结果（或者至少 p 值要低得多）。
这种方法合理吗？您有更好的解决方案吗？有没有办法运行不涉及 $B$ 的测试？]]></description>
      <guid>https://stats.stackexchange.com/questions/653869/check-whether-an-event-made-a-change-in-the-appearance-of-certain-words-in-a-cor</guid>
      <pubDate>Wed, 04 Sep 2024 18:51:48 GMT</pubDate>
    </item>
    <item>
      <title>绘制狄利克雷回归中的效应</title>
      <link>https://stats.stackexchange.com/questions/653868/plotting-effects-in-dirichlet-regression</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/653868/plotting-effects-in-dirichlet-regression</guid>
      <pubDate>Wed, 04 Sep 2024 18:28:03 GMT</pubDate>
    </item>
    <item>
      <title>假设检验。基于受限信息的决策 [关闭]</title>
      <link>https://stats.stackexchange.com/questions/653866/hypothesis-testing-decision-based-on-restricted-information</link>
      <description><![CDATA[基于关于假设检验的操纵软件输出（来自 R），我想了解如何回答以下问题：
(a) 这是什么类型的测试？假设是什么？
(b) 重要性水平是多少？测试决策是什么？
(c) alpha 位于哪个“区域”？
问题的作者（在原始问题中）用“？”替换了测试名称、p 值、假设和替代方案等重要信息。所以我复制了这样一个问题。
在下面，您可以找到包含所有信息的输出。当我创建这个模拟问题时，我们知道了整个过程。

?

数据：x
X 平方 = 93.177，df = 29，p 值 = ?
备选假设：真实方差为 ? 2.5
95% 置信区间：
5.09473 14.51621
样本估计值：
x 的方差 
8.032507 

我在回答 (a)-(c) 时所做的努力是：
(a&#39;) 根据“X 平方”、“方差”和“x”，我认为：一个样本方差卡方检验。除了将样本方差与总体方差进行比较之外，不可能进一步指定假设。$H_{0}$ 包括“等号”就像假设检验理论中总是做的那样。我无法说测试是单侧还是双侧。
(b&#39;)“95% 置信区间”表示 $\alpha = 0.05$。我无法争论测试决定。在我看来，我在这里缺少统计假设检验理论的一个基本部分。
(c&#39;) 参见 (b&#39;)。
任何关于如何进行的提示都非常感谢。

注意
(1) R 代码产生输出。
x = rnorm(30, mean = 1, sd = 3)
library(DescTools)
VarTest(x, sigma.squared = 2.5)

也就是说，$x$ 的生成来自 $X\sim\mathcal{N}(1,3)$，其中 $n=30$。
(2) 完整输出，其中 操纵 输出源于此。

方差单样本卡方检验

数据：x
X 平方 = 93.177，df = 29，p 值 = 1.28e-08
备选假设：真实方差不等于 2.5
95% 置信区间：
5.09473 14.51621
样本估计值：
x 方差
8.032507

(3) 软件说明。
DescTools::VarTest() 的默认值为双侧。 p 值明显低于 5%（默认值）。即检验拒绝了原假设。]]></description>
      <guid>https://stats.stackexchange.com/questions/653866/hypothesis-testing-decision-based-on-restricted-information</guid>
      <pubDate>Wed, 04 Sep 2024 18:14:05 GMT</pubDate>
    </item>
    <item>
      <title>无法绘制具有分层变量的 ggsurvplot 曲线[关闭]</title>
      <link>https://stats.stackexchange.com/questions/653865/unable-to-plot-ggsurvplot-curves-with-stratified-variables</link>
      <description><![CDATA[我试图创建一个分层了不同类型变量的 ggsurvplot 曲线，但一直出现错误。
这是代码：
# 定义用于 OS 分析的 Surv 对象
surv_object_os &lt;- Surv(time = target_time_series_os$tstart, time2 = target_time_series_os$tend, event = target_time_series_os$death_status)

# 步骤 4：拟合 Cox 比例风险模型
# 以治疗组为主要协变量并根据需要拟合其他协变量，拟合 Cox 模型
cox_model_os &lt;- coxph(surv_object_os ~ age_at_sample + strata(sex) + rt_dosage + chemo_dosage + stad_bin + ps_bin + rt_arm + library_prep_plate, 
data = target_time_series_os)

# 步骤 5：Cox 模型摘要
# 显示 Cox 模型摘要，包括系数、p 值等。
summary(cox_model_os)

# 根据 Cox 模型生成生存曲线
surv_fit_os &lt;- survminer::surv_fit(cox_model_os, data = target_time_series_os)

all: survfit(formula = cox_model_os, data = target_time_series_os)
records n.max n.start events median 0.95LCL 0.95UCL
0 127 31 27 35 1168 674 NA
1 164 38 33 40 1236 730 NA

survminer::ggsurvplot(fit=surv_fit_os, data = target_time_series_os,
pval = TRUE, conf.int = TRUE,
legend.title = &quot;生存曲线&quot;,
risk.table = TRUE,
xlab = &quot;时间（天）&quot;,
ylab = &quot;生存概率&quot;)

我不断收到：

在新窗口中显示
调用：
coxph(formula = surv_object_os ~ age_at_sample + strata(sex) + 
rt_dosage + chemo_dosage + stad_bin + ps_bin + rt_arm + library_prep_plate, 
data = target_time_series_os)

n= 291，数量事件= 75 

coef exp(coef) se(coef) z Pr(&gt;|z|)
age_at_sample 0.007480 1.007508 0.018403 0.406 0.684
rt_dosage -0.006263 0.993756 0.032314 -0.194 0.846
chemo_dosage -0.087179 0.916513 0.464639 -0.188 0.851
stad_bin 0.323840 1.382427 0.379841 0.853 0.394
ps_bin 0.352640 1.422819 0.373342 0.945 0.345
rt_arm60 Gy 0.020243 1.020449 0.483095 0.042 0.967
library_prep_plate 0.085032 1.088752 0.109380 0.777 0.437

exp(coef) exp(-coef) 下限 .95 上限 .95
age_at_sample 1.0075 0.9925 0.9718 1.045
rt_dosage 0.9938 1.0063 0.9328 1.059
chemo_dosage 0.9165 1.0911 0.3687 2.278
stad_bin 1.3824 0.7234 0.6566 2.910
ps_bin 1.4228 0.7028 0.6845 2.958
rt_arm60 Gy 1.0204 0.9800 0.3959 2.630
library_prep_plate 1.0888 0.9185 0.8787 1.349

一致性= 0.591 (se = 0.041 )
似然比检验= 7 df 上 4.42，p=0.7
Wald 检验 = 7 df 上 4.87，p=0.7
得分 (对数秩) 检验 = 7 df 上 5，p=0.7

在新窗口中显示
生存中的错误::survdiff(eval(fit$call$formula), data = data) : 
“formula”参数不是公式


并且
eval(predvars, data, env) 中的错误：未找到对象“sex”

如果我这样做：
ggsurvplot(surv_fit_os, data = target_time_series_os,
strata = &quot;sex&quot;, # 替换 &quot;other_variable&quot;替换为要使用的变量的实际名称
pval = TRUE, conf.int = TRUE,
legend.title = &quot;生存曲线&quot;,
risk.table = TRUE,
xlab = &quot;时间（天）&quot;,
ylab = &quot;生存概率&quot;,
facet.by = &quot;性别&quot;)


有人知道如何解决这个问题吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/653865/unable-to-plot-ggsurvplot-curves-with-stratified-variables</guid>
      <pubDate>Wed, 04 Sep 2024 16:44:43 GMT</pubDate>
    </item>
    <item>
      <title>当数据为观察数据时，如何解释不确定性</title>
      <link>https://stats.stackexchange.com/questions/653862/how-to-interpret-uncertainty-when-data-is-observational</link>
      <description><![CDATA[当数据是观察数据时，例如在行政环境中，我们如何解释频率统计不确定性度量，例如置信区间？
例如，在 2023 年一所拥有 500 名学生的学校中，我们测量所有 500 名学生的 GPA。平均 GPA 是这组特定学生的固定数量。
为了概念化频率不确定性，我们是否建议这 500 名学生是一个群体的成员？
例如，我们可能会说学生可能代表社区中更广泛的学生，或者每年都有新生，一年是所有可能学生年份的样本。另一个概念是，如果我们回溯时间，学生重温那一年，他们的学校经历会有所不同，GPA 也会有所不同。
我试图理解这种对人口定义的模糊性。我决定作为感兴趣的人口是否会为分析提供信息，例如如何计算置信区间？]]></description>
      <guid>https://stats.stackexchange.com/questions/653862/how-to-interpret-uncertainty-when-data-is-observational</guid>
      <pubDate>Wed, 04 Sep 2024 15:37:18 GMT</pubDate>
    </item>
    <item>
      <title>简单的卡方无法解决</title>
      <link>https://stats.stackexchange.com/questions/653861/simple-chi-squared-impossible-to-solve</link>
      <description><![CDATA[向两个独立的人群提出了一个“是/否”问题。
A 组：N=20，是=6，否=14。
B 组：“58% 回答是”。
我认为如果不知道（此处）B 组的总 N，就无法进行卡方检验——但我被告知可以这样做。我迷茫了，所以我去寻找信息的原始来源，发现
B 组：N=12，是=7（58%），否=5。
使用此信息，我使用方法（行 x 列）/总 N 生成了预期频率。 （在本例中为 20+12=32。）
我计算出的卡方值为 2.5。
但是，他们给出的答案是“(c^2 = 7.51; p=0.0058)”。
我绞尽脑汁试图理解这一点。不，我不认为答案是打字错误。
可能是我不知道正在执行哪种卡方。我不知道“c^2”是什么。可能是“B 组 58% 是”需要的 N 与 12 完全不同（即使它确实是之前未公开的 N），但是当我对这个 N 进行逆向工程时，代数很复杂，而且 N 似乎非常大。
我做错了什么吗？这太令人抓狂了。]]></description>
      <guid>https://stats.stackexchange.com/questions/653861/simple-chi-squared-impossible-to-solve</guid>
      <pubDate>Wed, 04 Sep 2024 15:27:19 GMT</pubDate>
    </item>
    <item>
      <title>双样本 Kolmogorov-Smirnov、双样本 Anderson-Darling 和（双样本）Wilcoxon 秩和检验的零假设</title>
      <link>https://stats.stackexchange.com/questions/653837/null-hypotheses-of-two-sample-kolmogorov-smirnov-two-sample-anderson-darling-a</link>
      <description><![CDATA[据我所知，双样本 Kolmogorov-Smirnov (KS) 检验和双样本 Anderson-Darling (AD) 检验的零假设 $H_0$ 是相同的，即两个样本来自同一分布/总体。
我们可以说（双样本）Wilcoxon 秩和 (WRS) 检验的零假设 $H_0$ 与 KS 和 AD 检验的零假设相同，只是“附加条件”是两个样本的中位数应该相同吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/653837/null-hypotheses-of-two-sample-kolmogorov-smirnov-two-sample-anderson-darling-a</guid>
      <pubDate>Wed, 04 Sep 2024 09:23:39 GMT</pubDate>
    </item>
    <item>
      <title>对框内的线段进行采样</title>
      <link>https://stats.stackexchange.com/questions/653827/sampling-line-segments-within-a-box</link>
      <description><![CDATA[我有点不知道从哪里开始解决我遇到的采样问题，所以任何方向都会有所帮助。我本质上想在一个边界正方形内采样长度相同的线段。想象一下把一根针扔进一个方形圆柱体，看看它是如何落地的（一遍又一遍）。
如果正方形的边小于线段的长度，你可以想象分布是X形的。我想了解随着正方形的增长，这种情况是如何变化的。卷积在这里是如何应用的？
编辑：随机/均匀，意思是任何有效的线段位置都有同等可能发生。有效意味着两个端点都在边界内。
可能相关：https://math.stackexchange.com/questions/4796686/probability-of-line-segments-intersecting-on-a-plane-a-generalization-to-buffo?rq=1]]></description>
      <guid>https://stats.stackexchange.com/questions/653827/sampling-line-segments-within-a-box</guid>
      <pubDate>Wed, 04 Sep 2024 04:29:24 GMT</pubDate>
    </item>
    <item>
      <title>在轮盘赌中，出现长红色序列的频率是否低于出现短红色序列的频率？</title>
      <link>https://stats.stackexchange.com/questions/653816/in-roulette-is-the-frequency-of-getting-long-sequences-of-reds-lower-than-that</link>
      <description><![CDATA[在一场无限期的轮盘游戏中，与连续 10 次出现红色相比，连续 100 次出现红色的概率（可能每百万次旋转才出现一次）要小得多，这样说对吗？
如果出现一长串红色的概率会随着序列变长而降低，那么为什么认为在一长串红色之后出现黑色的可能性更大会被视为赌徒谬误？如果 101 次出现红色的序列比 100 次出现红色的序列出现的可能性更小，那么为什么认为当前序列更有可能是 100 次出现红色并因此下一轮旋转将是黑色是错误的？
编辑：
我知道这些都是独立事件，概率没有记忆，因此必须保持不变。我在问，这一事实如何与较长序列出现频率较低的说法相一致。
此外，我并不是说根据大数定律，它应该平衡，因此下一次旋转更有可能是黑色。我是说，我们更有可能处于 100 个红色的序列而不是 101 个红色的序列，因为它发生的频率更高，并且如果更有可能假设现在是较短的序列而不是较长的序列，那么从逻辑上讲，下一次旋转更有可能是黑色不是吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/653816/in-roulette-is-the-frequency-of-getting-long-sequences-of-reds-lower-than-that</guid>
      <pubDate>Tue, 03 Sep 2024 23:44:05 GMT</pubDate>
    </item>
    <item>
      <title>为多元分布生成准随机数</title>
      <link>https://stats.stackexchange.com/questions/653814/generate-quasi-random-numbers-for-a-multivariate-distribution</link>
      <description><![CDATA[Sobol 或 Holton 等算法在超立方体 $[0,1]^d$ 中提供准随机数（即，这些数字在均匀分布的意义上“看起来”是随机的，但它们是确定性的）。让 $$x_1, x_2, ..., x_n$$ 成为此类伪随机数的序列。对于特定分布（例如正态分布）的任何分布函数 $F$，$$F^{-1}(x_1), F^{-1}(x_2), ..., F^{-1}(x_n)$$ 都是按照 $F$ 分布的准随机数。
如果 $F$ 是正态分布的分布函数，其均值为 $\mu$，方差-协方差矩阵为 $\Sigma$，则 $$F^{-1}(x_i) = C\Phi^{-1}(x_i) + \mu,$$，其中 $F$ class=&quot;math-container&quot;&gt;$\Phi^{-1}$ 是标准正态函数的分位数函数，该函数逐个分量应用于向量 $x_i$，而 $C$ 是 $\Sigma$ 的 Cholesky 分解。也就是说，我可以轻松生成具有多元正态分布的准随机向量。
现在我想生成具有多元 t 分布的准随机向量。可以通过 $$\sqrt{\frac{k}{\chi_i}}C\Phi^{-1}(x_i) + \mu,$$ 生成具有自由度为 $k$ 的多元 t 分布的随机向量，其中 $\chi_i$ 是自由度为 $k$ 的卡方分布随机变量。通过设置 $\chi_i = \mathcal X^{-1}_k(y_i)$，其中 $\mathcal X^{-1}_k$ 表示具有 $k$ 自由度的卡方分布的分位数函数。$y$ 是什么？好吧，这正是我的问题。问题是，如果我选择 $x_i$ 的第一个元素作为 $y_i$，那么 $y_i$ 和 $x_i$ 显然不再独立，这与生成具有多元 t 分布的随机数的算法相矛盾。当然，我可以随机选择一个 $i$ 并随机选择一个 $j$（组件），但这样我就可以首先生成随机数，而这并不是我想要的（这个问题是重要性抽样积分问题的一部分）。一个明显的解决方案是直接计算 $F^{-1}(x_i)$。然而，$F^{-1}$ 没有封闭形式，因此很难近似。
还有其他解决方案可以帮助我实现我想要的吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/653814/generate-quasi-random-numbers-for-a-multivariate-distribution</guid>
      <pubDate>Tue, 03 Sep 2024 22:36:46 GMT</pubDate>
    </item>
    <item>
      <title>季节性差分后 ADF/KPSS 检验的适用性</title>
      <link>https://stats.stackexchange.com/questions/653797/appropriateness-of-adf-kpss-tests-after-seasonal-differencing</link>
      <description><![CDATA[给定一个具有已知季节性的序列，我尝试在执行季节性差分后使用 ADF 和 KPSS 测试来验证平稳性。我正在使用这些测试的 statsmodels 实现。
import pandas as pd
from statsmodels.tsa.stattools import adfuller, kpss

def adf_test(timeseries, return=&#39;c&#39;):
test = adfuller(timeseries, return=regression, autolag=&#39;AIC&#39;)
output = pd.Series(
test[0:4],
index=[
&#39;测试统计量&#39;,
&#39;p 值&#39;,
&#39;使用的滞后数&#39;,
&#39;使用的观测值数量&#39;
]
)
for key, value in test[4].items():
output[f&#39;临界值 ({key})&#39;] = value
return output

def kpss_test(timeseries):
test = kpss(timeseries, return=&#39;c&#39;, nlags=&#39;auto&#39;)
output = pd.Series(
test[0:3], index=[&#39;测试统计量&#39;, &#39;p-value&#39;, &#39;# Lags Used&#39;]
)
for key, value in test[3].items():
output[f&#39;临界值 ({key})&#39;] = value
return output

可以使用以下方法重现原始数据：
data = {&#39;Value&#39;: {
&#39;2018-01-31&#39;: 104242, &#39;2018-02-28&#39;: 98662, &#39;2018-03-31&#39;: 105616, 
&#39;2018-04-30&#39;: 101179, &#39;2018-05-31&#39;: 98739, &#39;2018-06-30&#39;: 100133, &#39;2018-07-31&#39;: 107332, &#39;2018-08-31&#39;: 103455, &#39;2018-09-30&#39;: 81907, &#39;2018-10-31&#39;: 92845, &#39;2018-11-30&#39;: 83670, &#39;2018-1 2-31&#39;：84512，&#39;2019-01-31&#39;：108605，&#39;2019-02-28&#39;：97747，&#39;2019-03-31&#39;：101699，&#39;2019-04-30&#39;：103547，&#39;2019-05-31&#39;： 100278, &#39;2019-06-30&#39;: 98013, &#39;2019-07-31&#39;: 115181, &#39;2019-08-31&#39;: 110444, &#39;2019-09-30&#39;: 99455, &#39;2019-10-31&#39;: 100262, &#39;2019- 11-30&#39;: 88399, &#39;2019-12-31&#39;: 94493, &#39;2020-01-31&#39;: 109185, &#39;2020-02-29&#39;: 99482, &#39;2020-03-31&#39;: 108055, &#39;2020-04-30&#39;: 102379, &#39;2020-05-31&#39;: 115724, &#39;2020-06-30&#39;: 137875, &#39;2020-07-31&#39;: 136895, &#39;2020-08-31&#39;: 134005, &#39;2020-09-30&#39;: 123025, 0-10-31&#39;：155176，&#39;2020-11-30&#39;：116240，&#39;2020-12-31&#39;：117168，&#39;2021-01-31&#39;：136058，&#39;2021-02-28&#39;：122891，&#39;2021-03-31&#39;： 166424, &#39;2021-04-30&#39;: 152417, &#39;2021-05-31&#39;: 126856, &#39;2021-06-30&#39;: 173682, &#39;2021-07-31&#39;: 166529, &#39;2021-08-31&#39;: 147111, &#39;202 1-09-30&#39;：137624，&#39;2021-10-31&#39;：133565，&#39;2021-11-30&#39;：132117，&#39;2021-12-31&#39;：124160，&#39;2022-01-31&#39;：135815，&#39;2022-02-28&#39;： 127005, &#39;2022-03-31&#39;: 145378,
&#39;2022-04-30&#39;: 138972, &#39;2022-05-31&#39;: 140055, &#39;2022-06-30&#39;: 164881,
&#39;2022-07-31&#39;: 164568, &#39;2022-08-31&#39;: 178675, &#39;2022-09-30&#39;: 149753,
&#39;2022-10-31&#39;: 127887, &#39;2022-11-30&#39;: 114095, &#39;2022-12-31&#39;: 115408}}
df = pd.DataFrame(data)

其图表为：

我的测试为：
adf_test(df.diff(12).dropna())
kpss_test(df.diff(12).dropna())

ADF 测试返回临界值 -3.61 和 p 值 0.005。
KPSS 测试返回临界值 0.25 和 p 值 0.1，插值警告实际 p 值大于返回的 p 值。
这些表明季节性差分后不存在单位根和（水平）平稳性。但是，我收到反馈：

ADF 测试的 regression 参数应为 &#39;n&#39;。
KPSS 测试不合适，因为其回归参数只能是 &#39;c&#39; 或 &#39;ct&#39;，而不能是 &#39;n&#39;。
可视化的 12 个月差分序列似乎不是平稳的。

这些说法合适吗？尤其是，我从来没有听说过 KPSS 测试以这种方式不合适。]]></description>
      <guid>https://stats.stackexchange.com/questions/653797/appropriateness-of-adf-kpss-tests-after-seasonal-differencing</guid>
      <pubDate>Tue, 03 Sep 2024 16:01:06 GMT</pubDate>
    </item>
    <item>
      <title>具有幂律分布的自激马尔可夫过程的文献</title>
      <link>https://stats.stackexchange.com/questions/653740/literature-for-self-excited-markovian-processes-with-power-law-distributions</link>
      <description><![CDATA[我正在研究一个事件时间序列模型，该模型具有事件间隔的幂律分布。我选择了一个由随机微分方程控制的点过程
$$
d\lambda = -a \lambda^2 dt + b\eta,
$$
其中 $\lambda$ 是泊松过程的强度，$a$ 和 $b$ 是常数，$\eta \sim \text{Ber}(\lambda dt)$ 是事件变量，如果事件发生则等于 1，否则等于 0。这个方程式看起来很简单，一定有人研究过它或类似的方程式，但似乎找不到它。有什么建议应该在哪里寻找吗？
PS。我熟悉霍克斯过程、非线性霍克斯过程和二次霍克斯过程，但它们都是非时间局部的。此外，霍克斯过程根本不为事件间隔提供幂律分布，而其他模型似乎要复杂得多]]></description>
      <guid>https://stats.stackexchange.com/questions/653740/literature-for-self-excited-markovian-processes-with-power-law-distributions</guid>
      <pubDate>Mon, 02 Sep 2024 12:39:40 GMT</pubDate>
    </item>
    </channel>
</rss>