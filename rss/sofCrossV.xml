<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Sat, 28 Dec 2024 06:21:42 GMT</lastBuildDate>
    <item>
      <title>应用多元统计方法</title>
      <link>https://stats.stackexchange.com/questions/659289/applied-multivariate-statistical-methods</link>
      <description><![CDATA[我想在即将到来的考试中参考和练习应用多元统计方法的练习。请分享任何我可以参考并练习的好参考资料。我有理查德·约翰逊的书。
目前，我正在寻找一些东西来练习和数值，并尝试为该主题概述的所有方法。
主题包括：总体最小二乘法、主成分回归、偏最小二乘法、非负矩阵分解、方差分析、多元方差分析、函数式 PCA]]></description>
      <guid>https://stats.stackexchange.com/questions/659289/applied-multivariate-statistical-methods</guid>
      <pubDate>Sat, 28 Dec 2024 05:38:52 GMT</pubDate>
    </item>
    <item>
      <title>在对与输入数据集长度不同的序列进行测试时的位置编码</title>
      <link>https://stats.stackexchange.com/questions/659286/positional-encodings-when-testing-on-sequences-with-different-lengths-than-the-i</link>
      <description><![CDATA[我正在开发一个用于物理模拟的神经网络，它基本上可以归结为接收 3x3 矩阵序列（代表一些物理量）并输出另一个序列。目前，我正在使用正弦位置编码，然后是交替注意/MLP 层序列。
但是，我还需要我的模型能够对不同长度的序列（最多 324 个矩阵）进行推理，但我的数据集仅包含长度为 9 的输入/输出序列。
出于这个原因，我想知道正弦位置编码是否能够很好地推广到不同长度的序列，或者是否有更好的选择。我听说过各种其他方案（RoPE、学习嵌入等），但我对机器学习还不熟悉，所以我不确定哪种方案最适合我的具体用例，如果能就此事提出一些建议，我将不胜感激。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/659286/positional-encodings-when-testing-on-sequences-with-different-lengths-than-the-i</guid>
      <pubDate>Sat, 28 Dec 2024 05:02:47 GMT</pubDate>
    </item>
    <item>
      <title>关于原始样本矩的无偏性问题、奇怪的模拟结果</title>
      <link>https://stats.stackexchange.com/questions/659284/question-about-unbiasedness-of-raw-sample-moments-odd-simulation-results</link>
      <description><![CDATA[我正在执行蒙特卡洛模拟以确认$$m_k&#39;=\frac{1}{n}\sum_{i=1}^n X_i^k$$是$\text{E}[X^k]$的无偏估计量。如果$X\overset{iid}{\sim} \chi_1^2$，则我们有$\text{E}[X^k] = \prod_{j=0}^{k-1}(1+2j)$（来源）。为了验证 $m_k&#39;$ 的无偏性，我执行了以下模拟：
library(tidyverse)

kth_sample_raw_moment &lt;- function(x, k){
return(mean(x^k))
}

kth_raw_moment &lt;- function(k, df){
return(prod(df + 0:(k-1)*2))
}

draw_sample_moment &lt;- function(df, n, k, i){
set.seed(i)
x &lt;- rchisq(n, df = df)
output &lt;- tibble(
assess = kth_sample_raw_moment(x, k),
kth_moment = k,
df = df,
sample_size = n,
true_value = kth_raw_moment(k, df),
iter_num = i,
)
return(输出)
}

draw_N_sample_moments &lt;- function(N, df, n, k){
output &lt;- 1:N %&gt;% 
map_df(\(i) draw_sample_moment(df, n, k, i))
return(输出)
}

bias_of_estimator &lt;- function(N, df, n, k){
output &lt;- draw_N_sample_moments(N, df, n, k) %&gt;% 
summary(
bias = mean(estimate - true_value),
var_est = var(estimate)
) %&gt;% 
mutate(
df = df,
kth_moment = k, 
sample_size = n,
iterations = N
)
return(output)
}

结果 &lt;- map_df(1:10, \(k) bias_of_estimator(N = 1e4, 1, n = 1e3, k))

随着 $k$ 的增加，经验偏差的幅度开始膨胀。



第 K 阶矩
经验偏差
经验方差




1
0.0004955682
2.047726e-03


2
-0.0002376841
9.775483e-02


3
-0 .0208033800
1.005684e+01


4
-0.3669142243
1.902190e+03


5
-6.8067172462
5.670055e+05


6
-145.6305751734
2.343917e+08


7
-3520.6126356374
1.214408e+11


8
-93062.0716106473
7.307064e+13


9
-2627288.7106844918
4.840854e+16


10
-78133410.5134635270
3.410351e+19



什么是发生了什么？ 我的直觉是，随着 $m_k&#39;$ 方差的增加，经验偏差成为真实偏差的足够好估计所需的样本大小（迭代 N）也会增加（即与 LLN 相关的收敛速度取决于底层随机变量的方差）。但这不应该导致经验偏差在 $k$ 中单调，所以我不确定为什么会发生这种情况（如果不是偶然的话）。非常感谢您的任何建议！]]></description>
      <guid>https://stats.stackexchange.com/questions/659284/question-about-unbiasedness-of-raw-sample-moments-odd-simulation-results</guid>
      <pubDate>Sat, 28 Dec 2024 04:43:58 GMT</pubDate>
    </item>
    <item>
      <title>无意识统计学家的条件密度定律</title>
      <link>https://stats.stackexchange.com/questions/659281/law-of-the-unconscious-statistician-for-conditional-density</link>
      <description><![CDATA[根据这个答案，无意识统计学家定律意味着
$$E[h(X) \mid Z=z]=\int h(x) g(x\mid z) ~\mathrm{d}x.$$
但是
$$E[h(X \mid Y) \mid Z=z]呢？$$
这是真的吗
$$E[h(X \mid Y) \mid Z=z] = \int h(x \mid y) g(x\mid z) ~\mathrm{d}x?$$
我之所以问这个问题，是因为我目前正在研究条件得分函数，$\frac{\partial}{\partial \beta}\log h_{Y \mid X, \mathrm{B}}(y \mid x, \beta)$，当评估相关参数$\beta^*$的真实值时，该函数的均值应为零。]]></description>
      <guid>https://stats.stackexchange.com/questions/659281/law-of-the-unconscious-statistician-for-conditional-density</guid>
      <pubDate>Fri, 27 Dec 2024 23:25:10 GMT</pubDate>
    </item>
    <item>
      <title>“两阶段抽样”：合适的名称？</title>
      <link>https://stats.stackexchange.com/questions/659277/two-stage-sampling-appropriate-name</link>
      <description><![CDATA[假设需要基于二元观测估计给定人群中某些特征发生的概率 $p$。例如，通过选择人群样本，对每个人进行测试以检测该条件的存在与否，可以估计出某人患有某种遗传疾病的概率。
众所周知，获得 $p$ 可靠估计所需的样本量精确取决于 $p$（较小的 $p$ 需要较大的样本量）。考虑以下采样方案 (A)：

采集初始样本（使用预定义的大小或使用顺序停止规则），从中获得 $p$ 的粗略估计值。该估计值用于选择第二采样阶段的适当大小，由此获得$p$的最终估计值。

在我正在撰写的论文中，我想将（A）称为两阶段采样方案（它有两个阶段，我认为这个名字很清晰且具有描述性）。然而，“两阶段抽样”或“两阶段集群抽样”这一名称应用到一种集群抽样形式 (B):

给定一个集群群体，每个集群包含一定数量的个体，第一阶段选择集群的一个子集，第二阶段选择每个集群中的某些个体。

另一方面，我看到了限定词“两阶段”在其他情况下使用，而不仅仅是集群抽样，例如：&quot;自回归两阶段模型&quot;、&quot;两阶段最小二乘法&quot;、&quot;两阶段 PCA&quot;。
我的问题：

将 (A) 称为两阶段抽样是否可以接受？ （具体方法当然会在论文中描述）。或者，考虑到该名称适用于/可能适用于 (B)，这会引起混淆吗？
使用名称“两阶段抽样”来表示 (B) 有多普遍？(B) 最常被称为“两阶段集群抽样”吗？（这将为我打算使用该名称扫清障碍）
(A) 还有其他成熟的名称吗？
]]></description>
      <guid>https://stats.stackexchange.com/questions/659277/two-stage-sampling-appropriate-name</guid>
      <pubDate>Fri, 27 Dec 2024 21:49:27 GMT</pubDate>
    </item>
    <item>
      <title>U(0, θ) 中 $\dfrac{θ}{2}$ 的置信区间 [closed]</title>
      <link>https://stats.stackexchange.com/questions/659276/confidence-interval-for-dfrac%ce%b82-in-u0-%ce%b8</link>
      <description><![CDATA[我试图找到 $\dfrac{\theta}{ 2}$ 的置信区间，置信度为 $1-\alpha$，使用 $p_1 = \alpha$, $p_2 = 1$
因此，我采用 $\dfrac{\hat{\theta}}{2} = \dfrac{X_{(n)}}{2}$ 的无偏估计量
然后根据我们在课堂上学到的知识：$$P(\dfrac{cX_{(n)}}{2\theta}&lt;=q_{p_1})=P(\dfrac{X_{(n)}}{\theta}&lt;=\dfrac{2q_{p_1}}{c})=\alpha=(\dfrac{2q_{p_1}}{c})^n \rightarrow q_{p_1}=\dfrac{c}{2}\alpha^{\dfrac{1}{n}}$$ 而对于 $q_{p_2}$ 进行同样的处理将得到 $$q_{p_2} = \dfrac{c}{2}$$ 因此 $$P(\dfrac{c}{2}\alpha^{\dfrac{1}{n}}&lt;=\dfrac{cX_{(n)}}{\theta}&lt;=\dfrac{c}{2})=P(X_{(n)}&lt;=\dfrac{\theta}{2}&lt;=\dfrac{X_{(n)}}{\alpha^{\dfrac{1}{n}}})=1-\alpha$$ 因此 $$\dfrac{\theta}{2}\in[X_{(n)}, \dfrac{X_{(n)}}{\alpha^{\dfrac{1}{n}}}]$$
这看起来正确吗？还是我遗漏了什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/659276/confidence-interval-for-dfrac%ce%b82-in-u0-%ce%b8</guid>
      <pubDate>Fri, 27 Dec 2024 21:45:01 GMT</pubDate>
    </item>
    <item>
      <title>韦斯伯格的平方和性质</title>
      <link>https://stats.stackexchange.com/questions/659255/property-of-sums-of-squares-in-weisberg</link>
      <description><![CDATA[在 Weisberg 所著的《应用线性回归》第 23 页中，我看到了 $S_{xx}$ 的这种关系：
$$
\sum (x_i - \bar{x})^2 = \sum(x_i - \bar{x})x_i
$$
有人能解释一下为什么这个等式成立吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/659255/property-of-sums-of-squares-in-weisberg</guid>
      <pubDate>Fri, 27 Dec 2024 05:08:30 GMT</pubDate>
    </item>
    <item>
      <title>在解释结果时，我应该按原样报告回归中二次项的系数还是报告平方根？</title>
      <link>https://stats.stackexchange.com/questions/659248/when-interpreting-results-should-i-report-the-coefficient-for-the-quadratic-ter</link>
      <description><![CDATA[关于 CV 相关主题的问题有很多（例如这里），但我似乎找不到我的确切问题的答案。我以为我知道这一点，但最近我对我的知识产生了怀疑，想核实一下。
假设我对预测变量 X 进行标准高斯回归，其中线性和二次项。我们将结果称为 Y。线性系数为 4，二次系数为 -2。为简单起见，我省略了截距、方差等。我想用一个句子来解释结果。
这样说是否正确：“X 每增加 1 个单位，Y 估计就会增加 4 个单位，但 X 每增加 1 个单位，Y 的增长率就会降低 2 个单位。”
...或者我在解释二次方程时应该取二次系数的平方根（即“X 每增加 1 个单位，Y 的增长率就会降低 1.41 个单位”）？]]></description>
      <guid>https://stats.stackexchange.com/questions/659248/when-interpreting-results-should-i-report-the-coefficient-for-the-quadratic-ter</guid>
      <pubDate>Fri, 27 Dec 2024 00:19:47 GMT</pubDate>
    </item>
    <item>
      <title>根据一组百分位数和标准差估计概率密度函数 (PDF)</title>
      <link>https://stats.stackexchange.com/questions/659241/estimate-probability-density-function-pdf-from-a-set-of-percentiles-and-standa</link>
      <description><![CDATA[我有一个逆向工程问题：一个具有 7 个百分位数 (CDF_7) 的 CDF 作为纯文本，以及一个标准差。我使用 CDF_7 百分位数来计算 PDF。我计算的 PDF（左，绿色）（使用导出的数据 CDF_7，蓝色）与机器中的 PDF（右，红色）不同。理想情况下，PDF 应该相等。

我做错了什么？在下面的函数中，我在百分位数之间插入值。在解决这个问题时，涉及标准差是否有用？有没有想过标准偏差在这里如何有助于制作正确的 PDF？
我的 Python 代码：
 import numpy as np
import matplotlib.pyplot as plt

def epdf_hist(cdf_7pct, pct, bins_std):
&quot;&quot;&quot;基于累积分布函数 (CDF) 的 7 个百分位值制作直方图 - 经验概率密度函数 (PDF)

将 7 个百分位值插值到 100 个值，然后分箱
:parameter
cdf_7pct：包含 7 个值的 1 维数组，从高到低排序
pct：7 个百分位数，通常为 [1,5,10,50,90,95,99]
bins_std：包含箱的一维数组，宽度 = 0.2
:返回
100 个插值、分箱值的 pdf，
bins
100 个插值值
&quot;&quot;&quot;
d_pct = np.diff(pct)
cdf_100pct = [] # 生成 100 个值
# 在给定的百分位数值之间进行插值
for i in range(0, len(d_pct)):
arr = np.linspace(cdf_7pct[i], cdf_7pct[i + 1], num=d_pct[i], end=False) # 最后进行插值
cdf_100pct.extend(arr)
cdf_100pct.extend([cdf_7pct[-1]]) # 添加最后一个
cdf_100pct.extend([min(cdf_7pct)+(min(cdf_7pct) - min(arr))]) # 添加一个额外的
count, bins_count = np.histogram(cdf_100pct, bins=bins_std)
返回 count, bins_count, cdf_100pct

# 累积分布函数 (CDF_7) 导出数据
data = np.array([42.38, 42.31, 42.23, 42.03, 41.83,41.81,41.66])
perc = [1,5,10,50,90,95,99]
stdev = 0.15

# 来自机器的 CDF 值
targetbins = np.array([41.6,41.8, 42.0, 42.2,42.4])
c_targetperc = np.array([100,97,58,12,0])
# 来自机器的 PDF 值
p_targetperc = np.array([3,39,46,12,0])

# 计算
epdf_hist_count, epdf_hist_binscount, cdf_100pct = epdf_hist(data, perc, targetbins)
# 图
fig = plt.figure(figsize=(9, 4), layout=&quot;constrained&quot;)
axs = fig.subplots(1, 2, sharex=True, sharey=True)
axs[0].hist(cdf_100pct,bins=targetbins, density=False, color = &#39;green&#39;, alpha = 0.5, label=&quot;PDF i 计算自 CDF_7&quot;)
axs[1].bar(targetbins,p_targetperc, color=&#39;red&#39;, edgecolor=&#39;black&#39;, width=0.2, align=&#39;edge&#39;, alpha = 0.5，label=&quot;机器中的 PDF&quot;)
axs[1].plot(data,perc, &#39;bo--&#39;, label=&quot;从机器导出：CDF_7&quot;)
fig.suptitle(&quot;分布比较&quot;)
for ax in axs:
ax.grid(True)
ax.legend()
ax.set_xlabel(&quot;dB&quot;)
ax.set_ylabel(&quot;发生概率&quot;)
ax.label_outer()
plt.show()
]]></description>
      <guid>https://stats.stackexchange.com/questions/659241/estimate-probability-density-function-pdf-from-a-set-of-percentiles-and-standa</guid>
      <pubDate>Thu, 26 Dec 2024 19:50:59 GMT</pubDate>
    </item>
    <item>
      <title>R 中的固定效应 OLS 估计以及各种规范的含义</title>
      <link>https://stats.stackexchange.com/questions/659233/fixed-effects-ols-estimation-in-r-and-what-various-specifications-mean</link>
      <description><![CDATA[我对 R 中与 feols 相关的面板数据有疑问。
假设我有线性回归模型
y_{it}=a+x_{1it}+x_{2it}+error_{it}

其中 i=1,...,T 是国家指数，t=1,...,T 是时期。
在 R 中，我运行这些模型
 模型 A feols(y~ x1| Country[x2], data = mydata) 
模型 B feols(y~ x1+Country/x2, data = mydata) 
模型 C feols(y~ x1+i(Country,x2), data = mydata) 
模型 D feols(y~ x1+i(Country,x2)|Country, data = mydata)
模型 E feols(y~ x1 |Country^year, data = mydata) 
模型 F feols(y~ x1 |Country^year+c(Country,year), data = mydata) 
模型 G feols(y~ x1 |Country[year]+c(Country,year), data = mydata) 

其中我的数据包含“Country”和“year”列。
这些 R 模型对应的计量经济学规范是什么？
我的尝试：
模型 A：y_{it}=x_{1it}+a_i*x_{2it}+error_{it}，其中 a_i 是特定国家/地区的效应。

模型 B：我读到模型 B 得出的估计结果与模型 A 相同，但它的计量经济学规范是什么？

模型 C：y_{it}=x_{1it}+Country_1*x_{2it}+Country_2*x_{2it}+...+Country_N*x_{2it} +error_{it}

其中 Country_1、...、Country_N 为虚拟变量。

模型 D：y_{it}=a_i+x_{1it}+Country_1*x_{2it}+Country_2*x_{2it}+...+Country_N*x_{2it} +error_{it}

其中 Country_1、...、Country_N 为虚拟变量。

模型 E：y_{it}=a_i*lambda_t+x_{1it} +error_{it}，其中 lambda_t 为时间固定效应
]]></description>
      <guid>https://stats.stackexchange.com/questions/659233/fixed-effects-ols-estimation-in-r-and-what-various-specifications-mean</guid>
      <pubDate>Thu, 26 Dec 2024 16:31:23 GMT</pubDate>
    </item>
    <item>
      <title>如何修复 Lasso 回归的系数爆炸问题</title>
      <link>https://stats.stackexchange.com/questions/659287/how-to-fix-exploding-coefficients-for-lasso-regression</link>
      <description><![CDATA[我尝试按照这篇文章实现套索回归的坐标下降算法（在 R 中）。唯一的区别是根据我的教科书此处将成本函数缩放 1/n，但该教科书不是免费提供的。但我也尝试了非缩放版本，没有出现任何差异。
如果我有 N&gt;p，一切都会正常工作，但只要我的预测变量中有协方差（即 p&gt;N 或只是用协方差模拟多元正态数据），我的估计系数就会在几次迭代后爆炸，除非我取的 lambda 足够大，可以将所有系数推到 0。
我已经检查了我的代码几次，找不到我的错误。但由于 Lasso 是为这种情况而设计的，所以必须有一些错误。我尝试过不同的 lambda（书中给出了一系列合适的 lambda），beta 的结果相同 - 要么全部为 0，要么爆炸。
任何帮助我找出错误的方法都值得赞赏。
一个带有图表的最小示例来展示我的问题：
# 一些库可能有点过头了
library(dplyr)
library(glue)
library(tidyverse)
library(MASS)
library(rlist)

RSS &lt;- function(Y, X, beta){
n &lt;- length(Y)
return(sapply( 1:length(beta[,1]), function(x){1/n*sum((Y - beta[x,]%*%t(X))^2)} ))
}

set.seed(1234)
n &lt;- 5
p &lt;- 10
lam &lt;- 1
#获取协方差矩阵
Sigma &lt;- matrix(0.5, nrow = p, ncol = p)
diag(Sigma) &lt;- 1 
mu &lt;- rep(0, p)
X &lt;- mvrnorm(n, mu, Sigma)
# 缩放 X 以忽略 beta0
X &lt;- scale(X)
# 模拟数据 
beta_true &lt;- rep(c(1,-1,0), each = ceiling(p/3))[1:p]
Y &lt;- beta_true%*%t(X)
beta_est &lt;- Lasso(Y, X, rep(1, length(X[1,])))
rss &lt;- RSS(Y, X, beta_est)
penalty &lt;- lam * rowSums(abs(beta_est))

ggplot(mapping = aes(x = 1:length(rss))) +
geom_point(aes(y = rss + penalty, color = &quot;Penalty + RSS&quot;)) +
geom_point(aes(y = rss, color = &quot;RSS&quot;)) +
geom_point(aes(y = penalty, color = &quot;Penalty&quot;)) +
scale_color_manual(values = c(&quot;Penalty + RSS&quot; = &quot;black&quot;, &quot;RSS&quot; = &quot;red&quot;, &quot;Penalty&quot; = &quot;blue&quot;), 
name = &quot;Legend&quot;) + 
labs(y = NULL, x = &quot;Iteration&quot;)

我的 Lasso 回归函数如下。
soft_threshold &lt;- function(theta, lambda) {
return(sign(theta) * max(abs(theta) - lambda, 0))
}

Lasso &lt;- function(y, X, lam, Starting_coef){

p &lt;- length(starting_coef)
n &lt;- length(y)
coef &lt;- matrix(starting_coef, nrow = 1)
z_j &lt;- 1/n*colSums(X^2) # 可以在循环外计算

t &lt;- 1 # 设置时间步长
# 最大迭代次数
while(t&lt;=50){

new_coef &lt;- c() # 初始化新的 coefs

# 对所有 coefs 循环执行此操作 
for(j in 1:p){

roh_j &lt;- 1/n * ( y - coef[t,-j] %*% t(X[, -j])) %*% X[,j]
# roh_j 的计算拆分
#r_ij &lt;- y - coef[t, -j]%*%t(X[,-j])
#roh_j &lt;- 1/n * sum( r_ij * X[,j] )

new_beta &lt;- 1/z_j[j] * soft_threshold(roh_j, lam)
new_coef &lt;- c(new_coef, new_beta)

}

coef &lt;- rbind(coef, new_coef)
# 检查是否有显著变化
if(max(abs(coef[t+1,] - coef[t,])) &lt; 10^-4){
break
}
t &lt;- t+1

}

return(coef)

}
]]></description>
      <guid>https://stats.stackexchange.com/questions/659287/how-to-fix-exploding-coefficients-for-lasso-regression</guid>
      <pubDate>Wed, 25 Dec 2024 18:18:15 GMT</pubDate>
    </item>
    <item>
      <title>从指数函数分布获得幂律的必要充分条件？</title>
      <link>https://stats.stackexchange.com/questions/659182/necessary-and-sufficient-conditions-to-obtain-power-law-from-distribution-over-e</link>
      <description><![CDATA[分布 $p(x)$ 的哪些属性 (1) 是充分的且 (2) 是必要的，以使
$$-\log \Bigg(1 - \int_{x=0}^{x=1} p(x) \, (1-x)^k \, dx \Bigg)$$
导致幂律
$$\propto k^{-b}$$
对于某个常数 $b &gt; 0$？
我有一个隐含的假设，即分布 $p(x)$ &quot; n&quot;在某种意义上，但我不确定这个假设到底是什么。也许是平滑的、连续的，还是类似的东西？
我已经得出 Beta 分布和 Kumaraswamy 分布就足够了。从数值上讲，连续伯努利分布也同样有效。我正在寻找这些分布背后的一般“结构”。]]></description>
      <guid>https://stats.stackexchange.com/questions/659182/necessary-and-sufficient-conditions-to-obtain-power-law-from-distribution-over-e</guid>
      <pubDate>Tue, 24 Dec 2024 23:53:30 GMT</pubDate>
    </item>
    <item>
      <title>在回归中独立性是否意味着条件独立性？</title>
      <link>https://stats.stackexchange.com/questions/659012/does-independence-imply-conditional-independence-in-regression</link>
      <description><![CDATA[我正在阅读统计学习要素（第 44 页），并看到了这句话：

&quot;从统计学的角度来看，如果训练观测值$(x_i, y_i)$代表从其总体中独立随机抽取的样本，则该标准是合理的。即使 $x_i$ 不是随机抽取的，如果 $y_i$ 在给定输入 $x_i$ 的情况下是条件独立的，则该标准仍然有效。&quot;

为了探索这一点，我考虑了两种情况下的联合似然：

情况 1：$(x_i, y_i)$ 完全独立
如果 $(x_i, y_i)$ 对完全独立，则联合似然为：
$$
P(x_1, y_1, \dots, x_n, y_n \mid \theta) = \prod_{i=1}^n P(y_i \mid x_i, \theta) P(x_i \mid \theta)。
$$

案例 2：给定 $x_i$，$y_i$ 的条件独立性&gt;
如果给定 $x_i$，$y_i$ 是条件独立的，则联合似然为：
$$
P(x_1, y_1, \dots, x_n, y_n \mid \theta) = \left( \prod_{i=1}^n P(y_i \mid x_i, \theta) \right) P(x_1, x_2, \dots, x_n \mid \theta)。
$$



观察：

边际：
在情况 1中，由于独立性假设，输入的边际分布分解为$\prod_{i=1}^n P(x_i \mid \theta)$。
在情况 2中，输入的边际分布写为单个项$P(x_1, x_2, \dots, x_n \mid \theta)$，因为没有假设$x_i$。

条件：
在这两种情况下，除去边际，给定$x_i$的$y_i$的条件分布是相同的：
$$
\prod_{i=1}^n P(y_i \mid x_i, \theta)。
$$


这表明，尽管对边际的假设不同，但条件结构并没有不同。

问题：

两种情况下的联合似然方程是否准确，它们是否正确反映了各自的独立性或条件独立性假设？

如果是这样，那么假设$(x_i, y_i)$完全独立（情况 1）是否意味着在给定$x_i$的情况下，$y_i$具有条件独立性，如观察结果所示？

]]></description>
      <guid>https://stats.stackexchange.com/questions/659012/does-independence-imply-conditional-independence-in-regression</guid>
      <pubDate>Fri, 20 Dec 2024 13:04:15 GMT</pubDate>
    </item>
    <item>
      <title>高斯过程中未知点协方差矩阵导数的近似值</title>
      <link>https://stats.stackexchange.com/questions/658911/approximation-for-the-derivative-of-the-covariance-matrix-for-unknown-points-in</link>
      <description><![CDATA[我希望标题足够具有描述性，我现在感觉有点愚蠢。在我进行有关导数的推导时，出现了以下术语
$$
K_{x*,x}K^{-1}_{xx} \frac{\partial K_{xx}}{\partial q} K^{-1}_{xx} K_{x,x*}
$$
其中 $x$ 为训练点，$x*$ 为未知点，$q$ 为该点所依赖的坐标。$K$ 为协方差矩阵。我的直觉告诉我，这个表达式至少在最小二乘拟合意义上近似于
$$
\frac{\partial K_{x*x*}}{\partial q}
$$
但目前我无法证明这一点。也许我只是希望它是真的，因为它会简化我推导中的最终表达式。
欢迎提出任何想法。也许我走错了路。]]></description>
      <guid>https://stats.stackexchange.com/questions/658911/approximation-for-the-derivative-of-the-covariance-matrix-for-unknown-points-in</guid>
      <pubDate>Wed, 18 Dec 2024 10:30:09 GMT</pubDate>
    </item>
    <item>
      <title>有目的地将纵向数据建模为 iid？</title>
      <link>https://stats.stackexchange.com/questions/658882/purposefully-modelling-longitudinal-data-as-iid</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/658882/purposefully-modelling-longitudinal-data-as-iid</guid>
      <pubDate>Tue, 17 Dec 2024 15:38:22 GMT</pubDate>
    </item>
    </channel>
</rss>