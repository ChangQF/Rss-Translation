<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最近的问题 - 交叉验证</title>
    <link>https://stats.stackexchange.com/questions</link>
    <description>来自 stats.stackexchange.com 的最新 30 条</description>
    <lastBuildDate>Thu, 05 Dec 2024 09:19:31 GMT</lastBuildDate>
    <item>
      <title>我想比较我的数据，即方差分析中 3 组的“修剪均值”比较。这在 SPSS 中可以实现吗？</title>
      <link>https://stats.stackexchange.com/questions/658305/i-want-to-compare-my-data-which-are-comparisons-the-trimmed-means-of-3-groups</link>
      <description><![CDATA[在方差分析中比较 3 个组的“修剪均值”。这在 SPSS 中可以实现吗？如果不行，我该怎么做。在“R”中，代码​​非常混乱，而且不起作用]]></description>
      <guid>https://stats.stackexchange.com/questions/658305/i-want-to-compare-my-data-which-are-comparisons-the-trimmed-means-of-3-groups</guid>
      <pubDate>Thu, 05 Dec 2024 08:48:14 GMT</pubDate>
    </item>
    <item>
      <title>数据通过了除正态性之外的所有线性检验。我的下一步应该怎么做？</title>
      <link>https://stats.stackexchange.com/questions/658300/data-passing-all-linearity-checks-except-normality-what-should-my-next-steps-be</link>
      <description><![CDATA[我需要为一系列存在相同问题的数据集构建模型。

&quot;目测&quot; 让我相信数据最适合线性回归。我的数据似乎通过了同质性假设 (leveneTest pval &gt; 0.05) 和线性假设 (需要对独立性进行更多研究)。没有点的 cooks 距离 &gt; 0.5，这表明没有高度有影响力的异常值。但是，我的线性图表未通过正态性检验。
P-val 为 &lt; 0.05 用于 shapiro.test(residuals(model)) 检查。
qq 图的尾部下降：

我试过平方根 &amp; y 的 boxcox 变换，以及更稳健的建模，如 rlm 和 glm（针对转换和未转换的数据），但这些都产生了类似的结果。
我承认通常没有办法转换数据以使其正常化。
我所有的问题都围绕着同一个问题：我接下来该怎么做才能对这些数据进行建模？
我还能合理地使用线性回归来对这些数据进行建模吗？
由于我的大多数数据集都超过 500 分，我可以合理地声称 C.L.T 吗？
我可以使用其他建模方法吗？或者我完全错过了什么？]]></description>
      <guid>https://stats.stackexchange.com/questions/658300/data-passing-all-linearity-checks-except-normality-what-should-my-next-steps-be</guid>
      <pubDate>Thu, 05 Dec 2024 06:29:11 GMT</pubDate>
    </item>
    <item>
      <title>条件分位数期望的影响函数</title>
      <link>https://stats.stackexchange.com/questions/658299/influence-function-of-expectation-of-conditional-quantile</link>
      <description><![CDATA[我正在尝试推导估计量的影响函数。
$$Pr(Y&lt;m) = E(I(Y&lt;m)) = E(E(I(Y&lt;m)|X))$$
其中 Y 的分布取决于 X P(Y) = P(Y|X)P(X)
感谢您的帮助！]]></description>
      <guid>https://stats.stackexchange.com/questions/658299/influence-function-of-expectation-of-conditional-quantile</guid>
      <pubDate>Thu, 05 Dec 2024 04:39:36 GMT</pubDate>
    </item>
    <item>
      <title>产品的 SE</title>
      <link>https://stats.stackexchange.com/questions/658298/se-of-a-product</link>
      <description><![CDATA[如果每个变量$X_i$都是具有不同样本大小的样本的相关系数，那么如何根据以下公式计算标准误差。
$$\begin{align}
\operatorname{var}(X_1\cdots X_n) 
&amp;= E[(X_1\cdots X_n)^2]-\left(E[X_1\cdots X_n]\right)^2\\
&amp;= E[X_1^2\cdots X_n^2]-\left(E[X_1]\cdots E[X_n]\right)^2\\
&amp;= E[X_1^2]\cdots E[X_n^2] - (E[X_1])^2\cdots (E[X_n])^2\\
&amp;= \prod_{i=1}^n \left(\operatorname{var}(X_i)+(E[X_i])^2\right)
- \prod_{i=1}^n \left(E[X_i]\right)^2
\end{align}$$]]></description>
      <guid>https://stats.stackexchange.com/questions/658298/se-of-a-product</guid>
      <pubDate>Thu, 05 Dec 2024 04:24:23 GMT</pubDate>
    </item>
    <item>
      <title>是否有技术可以分析具有包含数字范围而不是单个值的预测变量的数据？</title>
      <link>https://stats.stackexchange.com/questions/658293/are-there-techniques-for-analyzing-data-that-have-predictor-variables-that-conta</link>
      <description><![CDATA[是否有分析数据的技术，其中预测变量包含数字范围而不是单个值？例如，可以从 0 至 5 厘米深度、5 至 10 厘米深度和 10 至 20 厘米深度获取土壤样本（请注意这些范围的宽度也不一致）。我可以将这些组视为类别，但这样我就会丢失有关它们位置的信息；我可以对它们进行排名，但在我的示例中，排名不会考虑范围宽度的差异。
谢谢！]]></description>
      <guid>https://stats.stackexchange.com/questions/658293/are-there-techniques-for-analyzing-data-that-have-predictor-variables-that-conta</guid>
      <pubDate>Thu, 05 Dec 2024 01:15:37 GMT</pubDate>
    </item>
    <item>
      <title>如何计算这个替代方案的密度？</title>
      <link>https://stats.stackexchange.com/questions/658289/how-to-compute-the-density-of-this-alternate-proposal</link>
      <description><![CDATA[简介
在我的粒子过滤应用中，我有一个替代方案（重要性函数），它似乎可以提高性能，以估计状态的后验概率来衡量。但我不确定重要性密度的正确表达式，它在顺序重要性重采样 (SIR) 算法中划分粒子权重。
状态空间和先验
时间 $k$ 的状态是 $\mathbf{x}_k$。它是一个包含一些连续变量（未描述）的元组，以及$j_k$，一个二进制指示器，表示我们是否会在时间$k$开始一个新段。
先验由两个分布组成，$p_I(\mathbf{x})$表示初始状态或新段，$p_C(\mathbf{x}_{k} \mid \mathbf{x}_{k-1})$表示连续段。
为了从先验中抽样，我们从伯努利变量中抽取$j_k$（概率为$p_J$），并从中抽取其余部分要么是 $p_I$，要么是 $p_C$，具体取决于其结果。
替代建议：从哪里开始？
引导过滤器使用默认建议 $p(\mathbf{x}_k \mid \mathbf{x}_{k-1})$，但消息来源表明我们可以做得更好。
一个常见的建议是使用似然函数 $p(\mathbf{y}_k \mid \mathbf{x}_k)$，但我们希望保持之前的分割行为。在这里，我们尝试将可能性信息纳入与之前类似的提案中。
提案：智能细分
我们不是盲目地以固定概率$p_J$对细分变量进行采样，而是从$p_I$和$p_C$中采样候选，并评估它们的可能性，以尝试获得更智能的细分概率。
也就是说，我们采样：$\mathbf{x}_I \sim p_I(\mathbf{x})$，
和$\mathbf{x}_C \sim p_C(\mathbf{x}_k \mid \mathbf{x}_{k-1})$。
然后，我们得分：$s_I := p(\mathbf{y}_k \mid \mathbf{x}_I) \cdot p_J$，
和$s_C := p(\mathbf{y}_k \mid \mathbf{x}_C) \cdot (1 - p_J)$。
这给了我们一个新的伯努利概率：$p_S := \frac{s_I}{s_I + s_C}$。
最后，我们从具有参数的伯努利中抽取$j_k$ $p_S$ 并设置 $\mathbf{x}_k$ 的其余组件，从 $x_I$ 或 $x_C$ 中选择，具体取决于 $j_k$。
尝试计算密度
SIR 需要我们计算 $\pi(\mathbf{x}_k \mid \mathbf{x}_{k-1}, \mathbf{y}_k)$ 来划分我们的权重。
我们可以尝试类似
$\hat{\pi}(\mathbf{x}_k \mid \mathbf{x}_{k-1}, \mathbf{y}_k) :=
\开始{案例}
p_S \cdot p_I(\mathbf{x}_k), &amp; \text{如果 } j_k = 1, \\
(1 - p_S) \cdot p_C(\mathbf{x}_k \mid \mathbf{x}_{k-1}), &amp; \text{otherwise.}
\end{cases}$
但是，$p_S$ 不是状态 $\mathbf{x}_k$ 的一部分，也不是重要性函数 $\pi$ 的参数。它是通过中间变量 $x_I$ 和 $x_C$ 生成的，表明存在多条通向 $\mathbf{x}_k$ 的路径，需要进行一些积分。
问题

实际密度 $\pi$ 是多少？
我可以做什么来用数字方式检查我的估计？
如果这很糟糕，是否有一些低复杂度的更好的估计？
]]></description>
      <guid>https://stats.stackexchange.com/questions/658289/how-to-compute-the-density-of-this-alternate-proposal</guid>
      <pubDate>Thu, 05 Dec 2024 00:15:38 GMT</pubDate>
    </item>
    <item>
      <title>日期应该是混合模型中的随机变量，还是应该作为与我的分类变量交互的项包含在内？</title>
      <link>https://stats.stackexchange.com/questions/658288/should-date-be-a-random-variable-in-a-mixed-model-or-included-as-an-interactive</link>
      <description><![CDATA[我关心除草剂对杂草覆盖率的影响。我在下面提供了一小组数据集。最初，我想使用混合模型：
mixed_model_1 &lt;- lmer(Percent_Coverage ~ Herbicide * Date + (1|Location), data = data)

但是，经过一番讨论，我现在不确定是否应该像上面一样包含 Date，或者使用模型：
mixed_model_2 &lt;- lmer(Percent_Coverage ~ Herbicide + (1|Location) + (1|Date), data = data)

我倾向于认为模型 1 更适合重复测量，但我现在不确定。我对日期相互作用并不是那么感兴趣——我希望日期会产生影响，因为除草剂的效果会随着时间的推移变得更加突出（它们需要一段时间才能显示出全部效果）。完全透明（如果您还没搞清楚的话），我不是统计专家。
我使用的是 R.4.4.2
以下是数据以及我在其上运行的内容：
data &lt;- structure(list(Location = c(&quot;Low Arm&quot;, &quot;Low Arm&quot;, &quot;Low Arm&quot;, 
&quot;Low Arm&quot;, &quot;Low Arm&quot;, &quot;Low Arm&quot;, &quot;Low Arm&quot;, &quot;Low Arm&quot;, &quot;Low Arm&quot;, 
&quot;Masonic&quot;, &quot;Masonic&quot;, &quot;Masonic&quot;, &quot;Masonic&quot;, &quot;Masonic&quot;, 
“共济会”，“共济会”，“共济会”，“举起手臂”，“举起手臂”，“举起手臂”，
“举起手臂”，“举起手臂”，“举起手臂”，“举起手臂”，“举起手臂”，“举起手臂”，“举起手臂”，
日期 = c(“7/1/2024”，“7/1/2024”，“7/1/2024”，“7/22/2024”，
“7/22/2024”，“7/22/2024”，“8/5/2024”，“8/5/2024”， “2024 年 8 月 5 日”，
“2024 年 7 月 1 日”，“2024 年 7 月 1 日”，“2024 年 7 月 1 日”，“2024 年 7 月 22 日”，“2024 年 7 月 22 日”，
“2024 年 7 月 22 日”，“2024 年 8 月 5 日”，“2024 年 8 月 5 日”，“2024 年 8 月 5 日”，“2024 年 7 月 1 日”，
“2024 年 7 月 1 日”，“2024 年 7 月 1 日”，“2024 年 7 月 22 日”，“2024 年 7 月 22 日”， &quot;7/22/2024&quot;, 
&quot;8/5/2024&quot;, &quot;8/5/2024&quot;, &quot;8/5/2024&quot;), 
除草剂 = c(&quot;Firehawk&quot;, &quot;无需治疗&quot;, &quot;除草大师&quot;, &quot;Firehawk&quot;, &quot;无需治疗&quot;, 
&quot;除草大师&quot;, &quot;Firehawk&quot;, &quot;无需治疗&quot;, &quot;除草大师&quot;, &quot;Firehawk&quot;, &quot;无需治疗&quot;, &quot;除草大师&quot;, &quot;Firehawk&quot;, &quot;无需治疗&quot;, 
&quot;除草大师&quot;, &quot;Firehawk&quot;, &quot;无需治疗&quot;, &quot;除草Master&quot;, 
“Firehawk”, “无治疗”, “除草大师”, “Firehawk”, “无治疗”, 
“除草大师”, “Firehawk”, “无治疗”, “除草大师”), 
Percent_Coverage = c(15L, 80L, 75L, 10L, 60L, 10L, 0L, 5L, 
2L, 70L, 95L, 80L, 15L, 80L, 35L, 0L, 60L, 5L, 30L, 90L, 
45L, 5L, 55L, 5L, 1L, 0L, 0L)), class = c(&quot;tbl_df&quot;, &quot;tbl&quot;, 
&quot;data.frame&quot;), row.names = c(NA, -27L))

mixed_model_1 &lt;- lmer(Percent_Coverage ~ Herbicide * Date + (1|Location), data = data)

anova(mixed_model_1)

输出：
使用 Satterthwaite 方法的 III 型方差分析表
Sum Sq Mean Sq NumDF DenDF F 值 Pr(&gt;F) 
Herbicide 8436.5 4218.3 2 16 24.8729 1.230e-05 ***
Date 14477.0 7238.5 2 16 42.6816 3.854e-07 ***
除草剂：日期 1574.1 393.5 4 16 2.3205 0.1013 
---
意义代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

mixed_model_2 &lt;- lmer(Percent_Coverage ~ Herbicide + (1|Location) + (1|Date), data = data)

anova(mixed_model_2)

输出：
采用 Satterthwaite 方法的 III 型方差分析表
Sum Sq Mean Sq NumDF DenDF F 值 Pr(&gt;F) 
Herbicide 8436.5 4218.3 2 20 19.676 1.887e-05 ***
---
Signif.代码：0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
```
]]></description>
      <guid>https://stats.stackexchange.com/questions/658288/should-date-be-a-random-variable-in-a-mixed-model-or-included-as-an-interactive</guid>
      <pubDate>Thu, 05 Dec 2024 00:07:07 GMT</pubDate>
    </item>
    <item>
      <title>我应该如何平衡具有两组条件的实验，并且对于这些条件的每种组合都没有足够的试验？</title>
      <link>https://stats.stackexchange.com/questions/658287/how-should-i-balance-an-experiment-with-two-sets-of-conditions-and-not-enough-tr</link>
      <description><![CDATA[我有一个测试参与者记忆力的受试者内实验。有 80 次试验，每次试验中，参与者阅读 20 个句子中的 1 个。然后，他们必须以 4 种方式中的 1 种（A1、A2、A3、A4）来操纵句子。他们回答 1 个问题，B1 或 B2。我最感兴趣的是 B2 上 A 条件之间的得分差异。我对 A1 与其他条件尤其感兴趣，但所有条件都很重要。这将用作操纵检查，因为我预计 A1 的得分会高于其他条件。
这样做会更好吗：
a) 在所有 4 次试验中，每个句子有 1 个 B 问题，这样我就可以比较包含 B2 问题的 10 个句子的所有 A 条件？
b) 每个句子有 2 次 B1 试验和 2 次 B2 试验，所以我可以比较所有 20 个句子的 2 个 A 条件？
有一些限制：
我不能对每个句子重复 8 次，只能重复 4 次。
B1 和 B2 必须具有同等可能性。]]></description>
      <guid>https://stats.stackexchange.com/questions/658287/how-should-i-balance-an-experiment-with-two-sets-of-conditions-and-not-enough-tr</guid>
      <pubDate>Thu, 05 Dec 2024 00:05:14 GMT</pubDate>
    </item>
    <item>
      <title>单调变换保留概率直觉</title>
      <link>https://stats.stackexchange.com/questions/658283/monotonic-transformation-preserving-probabilities-intuition</link>
      <description><![CDATA[我正在努力对为什么单调变换在连续情况下保留相对概率形成深刻的直觉。虽然我从表面上理解这个想法，特别是对于离散情况（在这种情况下更容易用计数来思考），但当我试图将其扩展到连续分布时，我失去了直觉。
我认为到目前为止我理解了以下内容：

单调变换$f(x)$（例如，$f(x) = x^2$ on $x \geq 0$）保留了结果的顺序。如果$x_1 &lt; x_2$，则$f(x_1) &lt; f(x_2)$。
在离散情况下，这种顺序保持与映射的一对一性质相结合，帮助我理解了为什么相对概率不会改变——即使值被转换，计数仍然保持成比例。
在连续情况下，概率密度函数 (PDF) 根据变换的导数而变化：
$$p_Y(y) = p_X(f^{-1}(y)) \cdot \left| \frac{d}{dy} f^{-1}(y) \right|,$$
其中 $f^{-1}(y)$ 是 $f(x)$ 的倒数。但是我很难将此公式与直观/视觉理解联系起来，以了解为什么区间内的相对概率保持不变。

我遇到的问题：

对于像$f(x) = x^2$这样的变换，它会非均匀地拉伸输入空间（例如，$1 \to 1, 2 \to 4, 10 \to 100$），感觉较大的值可能会不成比例地主导概率。例如，区间 $[10, 11]$ 映射到 $[100, 121]$，这比 $[1, 2] \to [1, 4]$ 大得多。
我的直觉失败了，因为我很难理解如何通过导数 $\frac{1}{f&#39;(x)}$ (或 $\frac{1}{2\sqrt{y}}$ for $f(x) = x^2$) 进行调整来“平衡”这种拉伸效应。在离散情况下，我可以想象一对一映射就像简单的重新标记一样，其中相对计数保持不变。但对于连续情况，我无法找到相同的满足感。

我想了解：

变量变化公式如何确保相对概率（例如，$P(Y \in [a, b]) / P(Y \in [c, d])$）在单调变换下得以保留？除了信任公式之外，还有其他方法可以建立直觉吗？
我应该如何从几何角度思考这种转变？将概率视为“密度质量”有帮助吗？重新分配，如果是这样，为什么这种重新分配不会扭曲相对大小？
是否有具体示例或可视化可以帮助弥补我的直觉差距，特别是对于连续分布？

感谢您的任何见解！]]></description>
      <guid>https://stats.stackexchange.com/questions/658283/monotonic-transformation-preserving-probabilities-intuition</guid>
      <pubDate>Wed, 04 Dec 2024 21:19:40 GMT</pubDate>
    </item>
    <item>
      <title>估计一对内具有相同响应值但不同协变量值的混合模型</title>
      <link>https://stats.stackexchange.com/questions/658265/estimating-mixed-model-with-identical-response-value-but-different-covariate-val</link>
      <description><![CDATA[假设我们有一个包含个人的数据集。每个个人单独或与另一个人一起执行一项任务（变量 condition），我们测量整个群体的表现，即个人或配对（变量 score）。
换句话说，我们为单独个体设置一个分数值，为配对个体设置两倍相同的分数值。
我们认为单独个体自己形成一对，从而产生变量 pair。
条件（单独 vs 配对）是受试者之间的，因此一个人单独或与另一个人一起执行任务，从而为每个个体产生一个分数（该分数在配对个体之间共享）。
我们还单独测量了一个协变量，即我们为每个个体设置一个 cov 值。
数据框如下所示：
&gt; head(df, 12)
id 对 得分 cov 条件
1 对1 3 6 solo
2 对2 6 4 对
3 对2 6 3 对
4 对3 3 3 solo
5 对4 5 3 对
6 对4 5 4 对
7 对5 3 5 solo
8 对6 5 5 对
9 对6 5 3 对
10 对7 4 3 solo
11 对8 4 5 对
12 对8 4 4 对

虽然 score 没有重复，但我想知道，考虑到一对中的个体具有不同的 cov 值，拟合混合模型是否有意义。
但是，估计如下模型：
lme4::lmer(score ~ condition * cov + (1 | pair))
导致无法收敛。
我觉得这是可以预料到的，因为 score 变量中存在冗余。话虽如此，我还是不太明白原因。
我读到过残差方差可能与随机效应方差混淆。但残差方差不应该不同于随机方差来解释 cov 中观察到的差异吗？]]></description>
      <guid>https://stats.stackexchange.com/questions/658265/estimating-mixed-model-with-identical-response-value-but-different-covariate-val</guid>
      <pubDate>Wed, 04 Dec 2024 11:49:19 GMT</pubDate>
    </item>
    <item>
      <title>横截面数据中条件独立与边际依赖的真实示例</title>
      <link>https://stats.stackexchange.com/questions/658255/real-world-examples-of-conditional-independence-with-marginal-dependence-in-cros</link>
      <description><![CDATA[在之前的问题中，我探索了仅使用条件独立性假设来推导联合似然 - 仅使用条件独立性假设（无边际独立性）推导联合似然 。
现在，我有兴趣了解现实世界中的应用或数据集，其中观察到边际依赖性的条件独立性。
问题：

是否存在众所周知的现实世界用例或数据集，其中出现这种类型的关系？
哪些类型的统计模型或领域（例如经济学、医学、社会科学）通常会遇到这种关系？

我希望得到示例、参考资料，或有关该主题的任何相关讨论，以便更好地理解其在实践中的含义。]]></description>
      <guid>https://stats.stackexchange.com/questions/658255/real-world-examples-of-conditional-independence-with-marginal-dependence-in-cros</guid>
      <pubDate>Wed, 04 Dec 2024 09:33:06 GMT</pubDate>
    </item>
    <item>
      <title>减少线性指数衰减混合函数中的极端行为</title>
      <link>https://stats.stackexchange.com/questions/658227/reducing-extreme-behavior-in-linear-exponential-decay-hybrid-function</link>
      <description><![CDATA[]]></description>
      <guid>https://stats.stackexchange.com/questions/658227/reducing-extreme-behavior-in-linear-exponential-decay-hybrid-function</guid>
      <pubDate>Tue, 03 Dec 2024 19:48:05 GMT</pubDate>
    </item>
    <item>
      <title>给定许多图游走的总成本，如何估算每条边的成本？</title>
      <link>https://stats.stackexchange.com/questions/658217/given-the-total-cost-of-many-graph-walks-how-to-estimate-the-cost-of-each-edge</link>
      <description><![CDATA[我有一个实际问题，其中我有一个节点及其边的集合。这个集合由数百个节点和数千个连接组成。然后我有大约 10 K 个数据点，每个数据点代表此图中采用的一条路径和每条路径的总成本（每条路径中经过的边的成本总和）。我正在寻找一个函数，给定路径，估算每条边的成本。
现实世界的情况有点复杂，因为模型需要考虑其他特征，例如一天中的时间，以及每个节点的输入/输出，所以我猜它需要一些强化学习管道，但任何时候的任务主要取决于我上面定义的算法，而且它看起来相当简单。
这个问题容易解决吗？文献中是否有任何算法可以解决它？因为我在整整一天的研究中都没有找到一个。]]></description>
      <guid>https://stats.stackexchange.com/questions/658217/given-the-total-cost-of-many-graph-walks-how-to-estimate-the-cost-of-each-edge</guid>
      <pubDate>Tue, 03 Dec 2024 15:58:08 GMT</pubDate>
    </item>
    <item>
      <title>如何手动计算自相关</title>
      <link>https://stats.stackexchange.com/questions/658213/how-to-calculate-autocorrelation-manually</link>
      <description><![CDATA[我学过滞后 $k$ 的时间序列中的自相关是所有以此滞后为间隔的值对之间的相关性。
假设我想试一试，并手动计算滞后 1。
模拟一些白噪声
set.seed(123)
TS &lt;- ts(rnorm(1e3))

然后手动计算自相关并使用内置函数。
calc_autocorrelation_manually &lt;- function(x) { cor(x[-1], x[-length(x)]) }

&gt; calc_autocorrelation_manually(TS)
[1] -0.02741628
&gt; 
&gt; acf(TS, lag = 1, plot = F)

序列‘TS’的自相关，按滞后

0 1 
1.000 -0.027

两者给出相同或几乎相同的结果（我知道 acf() 中的计算并不完全相同，因为它不使用偏差调整。不过，我认为这不会产生实质性差异）。
但是，如果我对模拟 AR(1) 过程执行此操作，结果就不一样了！例如，使用没有噪音的“理想”AR(1)：
&gt; TS &lt;- ts(99999) # 初始值
&gt; for (i in 1:350) { TS &lt;- c(TS, TS[i] * 0.3) }
&gt; 
&gt; calc_autocorrelation_manually(TS)
[1] 1
&gt; 
&gt; acf(TS, lag = 1, plot = F)

序列‘TS’的自相关，按滞后

0 1 
1.0 0.3 

我认为手动计算自相关是不正确的，但正确的方法是什么？为什么在第一个例子中它仍然运行良好？]]></description>
      <guid>https://stats.stackexchange.com/questions/658213/how-to-calculate-autocorrelation-manually</guid>
      <pubDate>Tue, 03 Dec 2024 15:05:35 GMT</pubDate>
    </item>
    <item>
      <title>从 R 中的多个 ROC 曲线中选择最佳预测因子</title>
      <link>https://stats.stackexchange.com/questions/658159/select-best-predictor-from-multiple-roc-curves-in-r</link>
      <description><![CDATA[软件包
library(ggplot2)
library(dplyr)
library(caret)
library(plotROC)
library(pROC)
library(ROCR)

3 个回归模型
modele1 &lt;- glm(USI3 ~ SBEcl3 + AGE3 + SEXE3 + RL3 + ATB3 + 
OXYGENE3 + NEW3 , data = data3, family = binomial)
modele2 &lt;- glm(USI3 ~ LACTATES3 + AGE3 + SEXE3 + RL3 + ATB3 + 
OXYGENE3 + NEW3 , data = data3, family = binomial)
modele3 &lt;- glm(USI3 ~ SOFA3 + AGE3 + SEXE3 + RL3 + ATB3 + 
OXYGENE3 + NEW3 , data = data3, family = binomial)

(data3 在文章末尾定义)
预测模型
predict(modele1)
predict(modele2)
predict(modele3)

3 ROC 曲线
rocs &lt;- list()
rocs[[&quot;modele1&quot;]] &lt;- roc(data3$USI3, predict(modele1))
rocs[[&quot;modele2&quot;]] &lt;- roc(data3$USI3, predict(modele2))
rocs[[&quot;modele3&quot;]] &lt;- roc(data3$USI3, predict(modele3))
ggroc (rocs, legacy.axes = TRUE)

结果

我想确定预测 USI 入院风险（USI3）的最佳判别分数（SBE3、LACT3、SOF3）。我将这些连续变量转化为定性变量，并将它们纳入我的模型中。我根据我的回归模型做出预测，这些预测非常差（AUC1 = 0.74，AUC2 = 0.72，AUC3 = 0.79）。
这种方法对您来说合适吗？如何做出更好的预测？您还有其他方法可以推荐给我吗？如何利用ROC曲线分析提前选定ICU入院不同预测因素的阈值？
这是我的数据
structure(list(USI3 = structure(c(2L, 1L, 2L, 2L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 1L, 2L, 1L, 2L, 1L, 1L), levels = c(&quot;non&quot;, 
&quot;oui&quot;), class = &quot;factor&quot;), SBEcl3 = structure(c(4L, 3L, 3L, 1L, 
3L, 4L, 4L, 1L, 2L, 4L, 4L, 2L, 1L, 4L, 2L, 2L, 3L, 2L, 4L, 4L
), 水平 = c(&quot;Q3&quot;, &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q4&quot;), 类 = &quot;因素&quot;, VBEcl3 = 结构(c(3L, 
2L, 1L, 3L, 1L, 3L, 3L, 1L, 2L, 3L, 3L, 2L, 1L, 3L, 2L, 2L, 1L, 
2L, 3L, 3L), 水平 = c(&quot;Q2&quot;, &quot;Q1&quot;, &quot;Q3&quot;), 类 = &quot;因素&quot;, 
SOFA3 = 结构(c(1L, 2L, 3L, 3L, 1L, 3L, 2L, 3L, 3L, 1L, 
2L, 2L, 2L, 1L, 2L, 3L, 1L, 2L, 2L, 2L), 水平 = c(&quot;Q1&quot;, 
&quot;Q2&quot;, &quot;Q3&quot;), 类 = &quot;因子&quot;), LACTATES3 = 结构(c(2L, 
3L, 1L, 1L, 2L, 3L, 1L, 2L, 3L, 2L, 1L, 1L, 3L, 
3L, 3L, 1L, 1L), 水平 = c(&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;), 类 = &quot;因子&quot;), 
SBE3 = c(5.88755625371722, -5.83367949101861, -5.16855590395164, 
1.94584567145157, -4.46237190410756, 2.92799867956303, 6.99250801087927, 
0.414319711015225, -16.1438604651896, 5.80900771418004, 5.08271450621078, 
-7.1973116153256, -1.30327738092311, 4.05722685252242, -15.2431163349488, 
-18.1380051674948, -4.84876594310452, -11.5092300657808, 
9.46936571654563, 16.4607368929384), VBE3 = c(4.83306549999999, 
-5.17690968000001, -3.96411408000001, 4.33224666999999, -3.45727284, 
1.7549679999999, 7.36360999999999, 0.618853640000002, -17.29309464, 
    5.33871410999998、6.48677951999998、-4.91616858000001、-0.740172520000016、 
    6.13709857999999、-15.35942096、-18.24841597、-3.61614233000002、 
    -12.1641, 10.34413375, 19.15572), SOF3 = c(2, 5, 6, 6, 2, 
6, 4, 8, 14, 1, 3, 5, 3, 2, 4, 11, 2, 5, 4, 4), LACT3 = c(1.9, 
3.4, 1.4, 0.8, 1.9, 18.4, 0.5, 2.2, 10.8, 0.8, 2.4, 7.1, 
1.9, 1.5, 1.1, 19, 3.1, 4.7, 1.1, 1), RL3 = 结构(c(2L, 
2L, 2L, 1L, 1L, 2L, 1L, 2L, 2L, 1L, 2L, 1L, 1L, 2L, 
1L, 2L, 1L, 1L),水平 = c(&quot;非&quot;, &quot;有&quot;), 类 = &quot;因子&quot;), 
OXYGENE3 = 结构(c(2L, 2L, 2L, 2L, 1L, 2L, 2L, 2L, 1L, 
2L, 2L, 2L, 2L, 1L, 1L, 2L, 1L, 2L, 2L, 2L), 水平 = c(&quot;非&quot;, 
&quot;有&quot;), 类 = &quot;因子&quot;), NEW3 = c(5, 6, 8, 6, 2, 11, 6, 
7, 6, 7, 12, 5, 10, 2, 1, 10, 5, 4, 4, 8), AGE3 = c(88, 53, 
71, 73, 58, 71, 83, 77, 58, 77, 35, 75, 57, 64, 68, 52, 58, 
81, 78, 77), ATB3 = 结构(c(2L, 2L, 1L, 2L, 2L, 2L, 2L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L, 2L, 1L), 水平 = c(&quot;非&quot;, 
&quot;是&quot;), 类别 = &quot;因素&quot;), SEXE3 = 结构(c(1L, 1L, 2L, 
2L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 1L, 2L, 1L, 2L, 2L, 2L, 
1L, 1L), levels = c(&quot;Femme&quot;, &quot;Homme&quot;), class = &quot;factor&quot;)), row.names = c(NA, 
20L), class = &quot;data.frame&quot;)
]]></description>
      <guid>https://stats.stackexchange.com/questions/658159/select-best-predictor-from-multiple-roc-curves-in-r</guid>
      <pubDate>Mon, 02 Dec 2024 16:54:32 GMT</pubDate>
    </item>
    </channel>
</rss>