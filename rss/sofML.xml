<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - 堆栈内存溢出</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 条</description>
    <lastBuildDate>Tue, 15 Oct 2024 15:18:47 GMT</lastBuildDate>
    <item>
      <title>Numpy 中的感知器简单实现与其列表实现截然不同</title>
      <link>https://stackoverflow.com/questions/79090615/perceptron-naive-implementation-in-numpy-drastically-diverges-from-its-list-impl</link>
      <description><![CDATA[在制作一个简单的机器学习项目时，我决定使用 numpy 数组重新设计一段列表逻辑。只需将循环中的数值增量更改为 numpy 算法。但是，numpy 实现给出的决策边界与循环实现的决策边界相差甚远，行为混乱，并且不会收敛。
完整的工作示例可以在 Google Colab 中找到：https://colab.research.google.com/drive/1zLy0oTidhm2lrwkASgT1lpsI9yfrBPvx?usp=sharing
这真的让我很困扰。如果是 numpy 精度错误，在较大的项目中可能不那么明显，并会阻碍结果。如果是概念错误，我看不到。这个问题很可能看起来很幼稚，但我真的想知道出了什么问题。
考虑以下感知器训练的列表实现。其背后的逻辑将在下文中进一步解释，但最重要的是，看看 W 和 b 的循环 num 值增量如何没有什么特别的。
def perceptronStep(X, y, W, b, learn_rate = 0.01):
diff = []
for i in range(len(X)):
y_hat = prediction(X[i],W,b)[0]
# diff=0 表示预测正确
# diff=1 或 diff=-1 表示 W 和 b 变化的方向
diff.append(y[i] - y_hat)
dif = diff[i]
W[0] += dif * X[i][0]*learn_rate
W[1] += dif * X[i][1]*learn_rate
b += dif * learn_rate
return W, b, diff

在我看来，以下numpy 实现应该可以完美地重现 perceptronStep 的行为方式。
def np_perceptronStep(X, y, W, b, learn_rate = 0.01):
Y_hat = np.squeeze(prediction(X, W, b))
diff = y - Y_hat
sumX = np.sum(X * diff[..., np.newaxis], axis=0, keepdims=True)
W += learn_rate * sumX.T # W_np
b += learn_rate * np.sum(diff) # b_np
return W, b, diff

但事实并非如此。 W_np 和 b_np 与 W 和 b 有所不同，从第 0 纪元开始相差 1.0e-16 秒，在训练结束时相差 10 秒。b_np 到处跳跃，而 b 表明它应该很快稳定下来。混乱。

通过阶跃函数获得预测。
def prediction(X, W, b):
Y_hat = np.matmul(X,W)+b
# 阶跃函数
Y_hat[Y_hat &gt;= 0] = 1
Y_hat[Y_hat &lt; 0] = 0
返回 Y_hat

上下文
我学习了Udacity 上的 PyTorch 机器学习入门。在教授梯度下降之前，介绍了一个粗略的技巧。考虑一个感知器，它有一个线性分类器 Wx+b，在本例中为 w1x1 + w2x2 + b，其中两个可能的类是 0 和 1。将点 x&#39; 的真实类别与预测类别之间的差异设为 c，感知器将按如下方式更新：W + acx&#39; 和 b + ac，其中 a 是学习率。非常简单。
我尝试在 np_perceptronStep 中手动从循环过渡到 np，希望一件事会导致问题。我尝试了确定 diff、W 和 b 的不同组合 - 无论是在循环中还是使用 np。我跟踪了两个实现的 W 和 b 之间的差异如何变化。它们发生了变化，但 np_perceptronStep 从未接近 perceptronStep 结果。]]></description>
      <guid>https://stackoverflow.com/questions/79090615/perceptron-naive-implementation-in-numpy-drastically-diverges-from-its-list-impl</guid>
      <pubDate>Tue, 15 Oct 2024 15:14:59 GMT</pubDate>
    </item>
    <item>
      <title>多类 SVM 中的一个类别几乎所有数据点都作为支持向量（scikit-learn）是正常的吗？</title>
      <link>https://stackoverflow.com/questions/79090407/is-it-normal-for-a-class-in-multiclass-svm-to-have-nearly-all-data-points-as-sup</link>
      <description><![CDATA[我正在使用 scikit-learn 的 SVC 对鸢尾花数据集进行多类分类，其中一个类几乎所有数据点都作为支持向量。这是预期的结果吗，还是我的实现或参数设置存在问题？
import pandas as pd
import numpy as np
from sklearn.svm import SVC
from sklearn.multiclass import OneVsRestClassifier

# 读取 Excel 文件
df = pd.read_excel(&quot;Classification iris.xlsx&quot;, index_col=&quot;instance_id&quot;)

# 将数据拆分为训练数据和测试数据
train_data = pd.concat([
df.loc[1:35],
df.loc[51:85],
df.loc[101:135]
])

test_data = pd.concat([
df.loc[36:50],
df.loc[86:100],
df.loc[136:150]
])

# 分离特征和目标变量
train_features = train_data.drop(columns=[&#39;class&#39;])
train_target = train_data[&#39;class&#39;]
test_features = test_data.drop(columns=[&#39;class&#39;])
test_target = test_data[&#39;class&#39;]

# 使用 One-vs-Rest 策略构建支持向量机
svm = OneVsRestClassifier(SVC(kernel=&#39;linear&#39;, C=1e5))
svm.fit(train_features, train_target)

# 进行预测
targets_train_pred = svm.predict(train_features)
targets_test_pred = svm.predict(test_features)

# 计算总误差
total_training_error = sum(targets_train_pred != train_target) / len(train_data)
total_testing_error = sum(targets_test_pred != test_target) / len(test_data)

# 打印总训练和测试错误
print(f&quot;Q2.2.2 使用标准 SVM 模型计算:\ntotal training error: {total_training_error:.10f}, total testing error: {total_testing_error:.10f}&quot;)

# 初始化列表以存储结果
classes = [&#39;setosa&#39;, &#39;versicolor&#39;, &#39;virginica&#39;]
linear_separable = []

for i, class_name in enumerate(classes):
# 获取当前类的二分类器
classifier = svm.estimators_[i]

# 计算每个类的错误
train_class_error = sum((targets_train_pred == class_name) != (train_target == class_name)) / len(train_data)
test_class_error = sum((targets_test_pred == class_name) != (test_target == class_name)) / len(test_data)

# 获取权重向量 w 和偏差 b
w = classifier.coef_[0]
b = classifier.intercept_[0]
support_vector_indices = classifier.support_

# 以正确的格式打印每个类的结果
print(f&quot;\nclass {class_name}:&quot;)
print(f&quot;training error: {train_class_error:.10f}, testing error: {test_class_error:.10f}&quot;)
print(f&quot;w: [{&#39;, &#39;.join([f&#39;{x:.10f}&#39; for x in w])}]&quot;)
print(f&quot;b: {b:.10f}&quot;)
print(f&quot;support vector indices: {support_vector_indices.tolist()}&quot;)

# 检查类是否线性可分
if train_class_error == 0:
linear_separable.append(class_name)

print(f&quot;\nLinear separable classes: {&#39;, &#39;.join(linear_separable)}&quot;)

这是输出：
Q2.2.2 使用标准 SVM 模型进行计算：
总训练误差：0.0571428571，总测试误差：0.0888888889

class setosa：
训练误差：0.0000000000，测试误差：0.0000000000
w：[0.0097327108， 0.5377790363, -0.8273513712, -0.3820427629]
b: 0.7734548984
支持向量索引：[42, 23, 24]

类 versicolor:
训练错误：0.0000000000，测试错误：0.0000000000
w：[1.8485997715, -4.5023738999, -1.1043393026, 0.3212849949]
b：5.6773042297
支持向量索引：[1, 2, 8, 9, 13, 25, 27, 34, 71, 72, 73, 77, 78, 80, 81, 86, 88, 89, 90, 91, 92, 93, 96, 99, 100, 102, 103, 104, 35, 36, 37, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 52, 55, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69]

class virginica:
训练错误：0.0000000000，测试错误：0.0000000000
w：[-3.6465034341， -5.1763639697, 7.4285254512, 11.0024158268]
b：-17.5703922240
支持向量索引：[55, 57, 62, 68, 96, 97, 99, 103]

线性可分类别：setosa、versicolor、virginica

由于 Versicolor 只有 35 个训练数据点，因此根据我对 SVM 的理论理解，我并不认为它们都是支持向量。此外，现在各个类别的训练误差对我来说似乎有点奇怪。
非常感谢您的帮助！]]></description>
      <guid>https://stackoverflow.com/questions/79090407/is-it-normal-for-a-class-in-multiclass-svm-to-have-nearly-all-data-points-as-sup</guid>
      <pubDate>Tue, 15 Oct 2024 14:28:31 GMT</pubDate>
    </item>
    <item>
      <title>Unet 或者如何创建幽灵模特效果？</title>
      <link>https://stackoverflow.com/questions/79090398/unet-or-how-do-i-create-a-ghost-mannequin-effect</link>
      <description><![CDATA[**我很好奇如何才能只提取衣服而不是手或其他部分，只提取衣服的全貌？
我们可以使用 U-net 等。它就像幽灵模特效果或半身像`**
``import sys
sys.path.append(&#39;/content/clothes-extractor&#39;)
from dataset import ClothesDataset, ClothesDataLoader
from config import Config

cfg = Config()
cfg.dataset_dir = &quot;/content/clothes-extractor/data/train&quot; 
cfg.load_height = 224
cfg.load_width = 224
cfg.batch_size = 1

clothes_dataset = ClothesDataset(cfg, dataset_mode=&quot;train&quot;, device=&quot;cpu&quot;)
clothes_loader = ClothesDataLoader(dataset=clothes_dataset, batch_size=cfg.batch_size)

for idx in range(len(clothes_loader)):
result = clothes_loader[idx]
img_name = result[&quot;img_name&quot;]

print(f&quot;Extracted clothing from {img_name}&quot;)

result = clothes_dataset[2] # 大小：已验证 2 个字符

image_keys = [&quot;centered_mask_body&quot;, &quot;cloth_mask&quot;, &quot;target&quot;]
fig,axes=plt.subplots(1,len(image_keys),figsize=(20,20))`
]]></description>
      <guid>https://stackoverflow.com/questions/79090398/unet-or-how-do-i-create-a-ghost-mannequin-effect</guid>
      <pubDate>Tue, 15 Oct 2024 14:27:04 GMT</pubDate>
    </item>
    <item>
      <title>没有传感器数据，预测模型还能有效吗？[关闭]</title>
      <link>https://stackoverflow.com/questions/79089664/can-predictive-models-be-effective-without-sensor-data</link>
      <description><![CDATA[我有纠正和预防性维护数据。对于纠正性维护，我有两台机器及其问题（只有一句话，没有数值）、日期、解决方案和停机时间。对于预防性维护，我有对同一两台机器进行季度、年度还是每月维护的数据。
如果我依靠这些值来创建机器学习模型来预测下一次故障，我的目标是回答这个问题——预防性任务完成后停机频率是增加还是减少，我的模型是否可靠并提供良好的预测，或者由于缺乏传感器数据，结果是否不准确？
我正在尝试清理数据并获取停机原因等特征，但我迷路了。我考虑过使用随机森林，但我不确定我的数据是否足够。]]></description>
      <guid>https://stackoverflow.com/questions/79089664/can-predictive-models-be-effective-without-sensor-data</guid>
      <pubDate>Tue, 15 Oct 2024 11:09:03 GMT</pubDate>
    </item>
    <item>
      <title>使用 AI 进行图像重叠检测</title>
      <link>https://stackoverflow.com/questions/79089453/image-overlap-detection-with-ai</link>
      <description><![CDATA[我正在研究一个项目，需要检测图像或图形是否重叠。我一直在研究 AWS Rekognition，因为它们可以进行一些图像分析并提供边界框，我可以通过这些边界框计算它们是否重叠。但是，我正在寻找其他想法的指针，这些想法可能更强大、更可扩展。
我遇到过 openCV，但从未听说过，也没有尝试过。这可能是一个负责任的解决方案，有人可以提供一些见解吗？
我有很多可以提供监督学习的图像，因此我可以使用我已经拥有的数据来训练模型也可能是一个有效的选择。
有任何意见、想法或指向我可以进行更多研究的地方的指针吗？
]]></description>
      <guid>https://stackoverflow.com/questions/79089453/image-overlap-detection-with-ai</guid>
      <pubDate>Tue, 15 Oct 2024 10:07:25 GMT</pubDate>
    </item>
    <item>
      <title>训练T5时如何添加EOS？</title>
      <link>https://stackoverflow.com/questions/79088393/how-to-add-eos-when-training-t5</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79088393/how-to-add-eos-when-training-t5</guid>
      <pubDate>Tue, 15 Oct 2024 04:22:59 GMT</pubDate>
    </item>
    <item>
      <title>如何向强化学习模型添加命令？</title>
      <link>https://stackoverflow.com/questions/79088319/how-to-add-commands-to-a-reinforcement-learning-model</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79088319/how-to-add-commands-to-a-reinforcement-learning-model</guid>
      <pubDate>Tue, 15 Oct 2024 03:27:53 GMT</pubDate>
    </item>
    <item>
      <title>当数据集包含一些文本字符串和数字数据时，如何继续拟合模型</title>
      <link>https://stackoverflow.com/questions/79088309/how-to-proceed-to-fit-in-a-model-when-dataset-has-some-text-strings-and-numeric</link>
      <description><![CDATA[我正在尝试将数据集放入模型中。缩放、删除不必要的数据后，数据集看起来如下所示；



seconds_log
minutes_log
country_enc
changing
description
Other feature variable




14.0058
0.693147
1
False
红色闪烁...
数字数据


3.401197
3.401197
0
True
白色旋转..
数字数据



因此，所有特征都具有数值，最后一个特征“描述”是长文本。请注意，我的目标变量是“country_enc”，其余所有列都是特征变量。描述值不能忽略。因此我使用&quot;TfidfVectorizer&quot;对数据进行矢量化。
我的问题是，在矢量化描述列之后，无论我得到什么，如何与数据集的其余部分相结合，然后将其拆分为测试和训练模型？
我看到一些谷歌示例，他们说；
combined_data = np.hstack((desc_tfidf.toarray(), original_dataframe_without_description))
print (combined_data)

如果我查看这个组合数据，它是一个numpy.ndarray。在分类模型中提供这些信息没有多大帮助。
基于将 Sklearn TFIDF 与附加数据相结合，如果我将稀疏矩阵转换为数组并与其余数据框（具有所有数值）连接，我会看到生成了几个 NaN 数据，这是预期的。我已经完成了数据预处理，所以再次执行 - 这是不对的。
我敢肯定，这不是正确的方法。有人可以在这里给出一些如何继续的指示吗？]]></description>
      <guid>https://stackoverflow.com/questions/79088309/how-to-proceed-to-fit-in-a-model-when-dataset-has-some-text-strings-and-numeric</guid>
      <pubDate>Tue, 15 Oct 2024 03:21:28 GMT</pubDate>
    </item>
    <item>
      <title>具有离散变量的线性回归问题，略有不同[关闭]</title>
      <link>https://stackoverflow.com/questions/79087896/linear-regression-problem-with-discrete-variables-with-a-twist</link>
      <description><![CDATA[我正在尝试开发一种 ML 算法来预测从更大的群体中选出的团队的表现。该组有 G 名成员，每个成员都用他们的名字来标识，并且通过从该组中选择 T 名成员来组建团队。数字 G 和 T 永远不会改变，组中每个成员的身份也不会改变。唯一改变的是我们选择哪个 T。这是监督学习，所以我有一组训练数据，每个数据都包含一个特定的团队选择及其获得的分数。成本函数试图最大化所有游戏的总分。从质量上讲，我知道不仅仅是某些团队成员的得分始终优于其他成员，而且某些成员组合的表现也优于其他组合。
我如何构建模型和算法来解决这个问题？我考虑过为每个团队成员或组中的每个人（在团队中或不在团队中）进行独热编码，但这并不能正确捕获所有约束（例如，成员在团队中出现的次数不应超过一次）。]]></description>
      <guid>https://stackoverflow.com/questions/79087896/linear-regression-problem-with-discrete-variables-with-a-twist</guid>
      <pubDate>Mon, 14 Oct 2024 22:42:45 GMT</pubDate>
    </item>
    <item>
      <title>使用 YoloV5 减慢相机速度</title>
      <link>https://stackoverflow.com/questions/79076547/slow-camera-with-yolov5</link>
      <description><![CDATA[我正在使用 Jetson Orin Nano 和 Raspberry Pi Camera Module V2，旨在运行 YOLOv5 进行实时图像处理。我尝试使用以下代码，但相机反馈非常缓慢且滞后，这是我没有想到的。如何改进？
这是我的代码：
import cv2
import torch
import numpy as np 

# 加载 YOLOv5 模型
model = torch.hub.load(&#39;ultralytics/yolov5&#39;, &#39;yolov5s&#39;)

# 用于 CSI 摄像头的 GStreamer 管道
def gstreamer_pipeline(
capture_width=1920, 
capture_height=1080,
display_width=960,
display_height=540,
framerate=30,
flip_method=2,
):
return (
&quot;nvarguscamerasrc ! &quot;
&quot;video/x-raw(memory:NVMM), &quot;
&quot;width=(int)%d, height=(int)%d, framerate=(fraction)%d/1 ! &quot;
&quot;nvvidconv flip-method=%d ! &quot;
&quot;video/x-raw, width=(int)%d, height=(int)%d, format=(string)BGRx ! &quot;
&quot;videoconvert ! &quot;
&quot;video/x-raw, format=(string)BGR ! appsink drop=True&quot;
% (
capture_width,
capture_height,
framerate,
flip_method,
display_width,
display_height,
)
)

# 实时视频捕获
cap = cv2.VideoCapture(gstreamer_pipeline(), cv2.CAP_GSTREAMER)

if not cap.isOpened():
print(&quot;无法打开摄像头。请检查连接。&quot;)
exit()

while cap.isOpened():
cv2.namedWindow(&quot;Detect&quot;, cv2.WINDOW_AUTOSIZE)

ret, frame = cap.read()

if not ret:
print(&quot;无法检索帧。&quot;)
break

# 使用 YOLOv5 进行预测
results = model(frame)
cv2.imshow(&#39;YOLO&#39;, np.squeeze(results.render())) 

if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):
break

cap.release()
cv2.destroyAllWindows()

有趣的是，当我使用以下管道时，相机运行速度要快得多：
import cv2
gst_str = &quot;nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM), width=1920, height=1080, framerate=30/1 ! nvvidconv flip-method=2 ! video/x-raw, format=BGRx ! videoconvert ! video/x-raw, format=BGR ! appsink&quot;

cap = cv2.VideoCapture(gst_str, cv2.CAP_GSTREAMER)

if not cap.isOpened():
print(&quot;无法打开摄像头&quot;)
else:
print(&quot;摄像头已打开&quot;)

while True:
ret, frame = cap.read()
if not ret:
print(&quot;无法检索帧&quot;)
break

cv2.imshow(&quot;CSI 摄像头&quot;, frame)

if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):
break

cap.release()
cv2.destroyAllWindows()

我想使用 YOLO 进行实时图像处理并最终构建一个训练算法。我愿意接受有关优化当前设置或切换到其他 YOLO 变体或任何其他适合 Jetson Orin Nano 的方法的建议。]]></description>
      <guid>https://stackoverflow.com/questions/79076547/slow-camera-with-yolov5</guid>
      <pubDate>Fri, 11 Oct 2024 01:17:56 GMT</pubDate>
    </item>
    <item>
      <title>RNN 中多对一预测的损失计算</title>
      <link>https://stackoverflow.com/questions/79074702/loss-calculation-for-many-to-one-prediction-in-rnn</link>
      <description><![CDATA[我正在尝试在 PyTorch 中实现一个简单的 RNN 模型，用于多对一时间序列预测。
假设我记录了 1-7 的观察结果，设计矩阵的结构如下：
[1,2,3,4]
[2,3,4,5]
[3,4,5,6]
[4,5,6,7]
这个想法是基于之前的四个观察结果做出一个预测，即多对一预测。
[1,2,3,4] - [5]
[2,3,4,5] - [6]
[3,4,5,6] - [7]
[4,5,6,7] - [8]
并且 [5,6,7,8] 构成了我的预测序列值。
我理解，每个数据点通过 RNN 模型时，都会生成一个预测。我的问题涉及每个时间步骤的损失计算。
具体来说，在第一个数据点 1 传入模型并产生预测后，会产生 1&#39;。

然后模型是否会查看预测 1&#39; 和目标 5，然后计算 1&#39; 和 5 之间的损失，并将预测 2&#39; 与 5 进行比较，依此类推。

所以基本上第一个序列是 [1,2,3,4]，相应的目标是 [5,5,5,5]。该模型总共计算损失 4 次，每对一次。

或者它是否让所有四个时间步骤（对应于数据点 1-4）通过并识别出这 4 个数据点的序列应该产生一个预测。因此，模型处理所有前三个数据点 1、2、3，并在不考虑目标的情况下产生预测 1&#39;、2&#39;、3&#39;。它计算损失直到第四次预测 4&#39; 之后，这个损失 L(4&#39;, 5) 以某种方式代表了该序列的总损失，然后向后传播。

在阅读了大量教程和我的课程文本后，我倾向于相信，对于一系列数据点 [1,2,3,4]，我们仍然必须为该模型提供一个目标 [2,3,4,5]，这样模型就会学习到 1&#39; 是 2 的预测（向前迈出一步），2&#39; 是 3 的预测，并相应地适应模式。
在这种情况下，多对一预测与一对一预测的不同之处仅在于我们只是提取最后一个预测，并且 RNN 模型在参数更新方面的内部工作原理与代码中具体呈现的内容相同（输入形状等）。]]></description>
      <guid>https://stackoverflow.com/questions/79074702/loss-calculation-for-many-to-one-prediction-in-rnn</guid>
      <pubDate>Thu, 10 Oct 2024 13:44:29 GMT</pubDate>
    </item>
    <item>
      <title>GNU Octave 是多线程的吗？</title>
      <link>https://stackoverflow.com/questions/79050512/is-gnu-octave-multi-threaded</link>
      <description><![CDATA[根据这个老问题的答案，GNU Octave 似乎是一个单线程应用程序。
但是，我正在试验一个名为nnet的旧 Octave 神经网络包，并惊讶地发现我的 Octave 程序使用了笔记本电脑的所有 4 个核心。自从我链接的问题提出以来，情况有变化吗？GNU Octave 现在是多线程的吗？据我所知，我没有看到 nnet 内部有任何并行实现。
有关我的安装的一些信息：

我的操作系统是 Linux Mint 20
我的机器有 4 个处理单元（这是 nproc 在我的终端中显示的内容）
我的 Octave 版本是 5.2.0（如果这有区别的话，我正在使用 GUI）

我的代码相当简单，只导入了 nnet 包，没有其他内容。当我查看运行程序时的资源时，我看到所有核心都已使用（下面是 htop 屏幕截图）

这是我正在做的事情：
pkg load nnet

starttime = clock();

# 取自 http://matlab.izmiran.ru/help/toolbox/nnet/newff.html
Pr = -1:0.00005:1;
Tr = 3*sin(pi*Pr)-cos(pi*Pr);
Prmin = min(Pr);
Prmax = max(Pr);
net = newff([Prmin Prmax],[3 2 1],{&#39;tansig&#39;,&#39;logsig&#39;,&#39;purelin&#39;},&#39;trainlm&#39;);
[net] = train(net,Pr,Tr,[],[],[]);
[netoutput] = sim(net,Pr);

etime(clock(),starttime)

% 测试结果 
plot(Pr,Tr,&#39;b+&#39;);
hold on; 
plot(Pr,netoutput,&#39;r-&#39;);
hold off;

编辑
按照评论中的 @JérômeRichard 提示和 @NickJ 建议，我通过在终端中执行 export OMP_NUM_THREADS=1 并启动 Octave 来启动 Octave，只为 BLAS 分配 1 个线程。该脚本的速度是原始设置的两倍（根据上面发布的 htop 屏幕截图，默认设置是 4）。我确保我的程序只使用一个核心和 htop。]]></description>
      <guid>https://stackoverflow.com/questions/79050512/is-gnu-octave-multi-threaded</guid>
      <pubDate>Thu, 03 Oct 2024 12:19:13 GMT</pubDate>
    </item>
    <item>
      <title>YOLOv5 类别不平衡和过度拟合问题</title>
      <link>https://stackoverflow.com/questions/78985031/yolov5-class-imbalance-and-overfitting-issues</link>
      <description><![CDATA[我正在开发一个安全带和手机检测系统，使用 YOLOv5s 来检测挡风玻璃、驾驶员、乘客、安全带和手机。我的数据集存在类别不平衡问题，因为并非每张图片都包含安全带或手机，而手机类别尤其代表性不足。
此外，手机很小，很难在图像中检测到。我注意到验证损失有一些波动，特别是在第 20 次之后开始增加，这让我怀疑是过度拟合。
yolov5s 的结果
pr 曲线
混淆矩阵
混淆矩阵 1
这是我的代码，我使用的是预训练模型来自 Ultralytics：
# 使用您的数据集训练模型
model.train(
data=&quot;full_dataset/data/data.yml&quot;,
imgsz=640,
epochs=100,
batch=16,
worker=4,
project=&quot;SeatBeltMobileDetection&quot;,
name=&quot;YOLOv5s_640_epochs100&quot;,
device=0
)

问题：

考虑到类别不平衡（尤其是手机检测），验证损失的波动和 DFL 损失的增加是否意味着过度拟合？

在这种类别不平衡的情况下，对 YOLOv5 进行微调的最佳实践是什么？调整类别权重等技术是否有帮助（我之前做过过采样和增强）？

我是否应该考虑对 YOLOv5 训练超参数进行任何特定调整，以提高手机等小物体的性能？

]]></description>
      <guid>https://stackoverflow.com/questions/78985031/yolov5-class-imbalance-and-overfitting-issues</guid>
      <pubDate>Sat, 14 Sep 2024 11:42:24 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 OpenCV 改进这种图像自然背景扩展方法？</title>
      <link>https://stackoverflow.com/questions/78969286/how-can-i-improve-this-approach-for-natural-background-extension-in-an-image-usi</link>
      <description><![CDATA[我正在使用 Python 中的 OpenCV 扩展图像的背景。我目前的方法是复制边框并对扩展区域应用高斯模糊以将它们混合到原始图像中。目标是使背景扩展看起来更自然，尤其是对于具有一致纹理的图像。
这是我当前使用的代码：
import cv2
import numpy as np

def expand_image_with_smart_blend(image_path, top=50, bottom=50, left=50, right=50):
img = cv2.imread(image_path)
original_h, original_w = img.shape[:2]

expanded_img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_REPLICATE)

blured_img = expand_img.copy()

if top &gt; 0:
blured_img[0:top, :] = cv2.GaussianBlur(expanded_img[0:top, :], (51, 51), 0)

如果底部 &gt; 0:
blured_img[original_h + top:original_h + top + bottom, :] = cv2.GaussianBlur(expanded_img[original_h + top:original_h + top + bottom, :], (51, 51), 0)

如果左侧 &gt; 0:
blured_img[:, 0:left] = cv2.GaussianBlur(expanded_img[:, 0:left], (51, 51), 0)

如果右侧 &gt; 0:
blured_img[:, original_w + left:original_w + left + right] = cv2.GaussianBlur(expanded_img[:, original_w + left:original_w + left + right], (51, 51), 0)

cv2.namedWindow(&quot;智能混合扩展图像&quot;, cv2.WINDOW_NORMAL)
cv2.namedWindow(&quot;原始图像&quot;, cv2.WINDOW_NORMAL)
cv2.imwrite(&#39;expanded_smart_blended_image.jpg&#39;, blured_img)
cv2.imshow(&#39;智能混合扩展图像&#39;, blured_img)
cv2.imshow(&quot;原始图像&quot;, img)
cv2.waitKey(0)
cv2.destroyAllWindows()

expand_image_with_smart_blend(&#39;test_img.jpg&#39;, top=100, bottom=100, left=100, right=100)

我尝试过的方法：
cv2.BORDER_REPLICATE：我使用它将原始图像的边缘复制到新扩展的区域中。
高斯模糊：应用于扩展区域以柔化原始图像和新区域之间的过渡。
问题：
结果在某种程度上是可以接受的，但过渡仍然看起来不像我想要的那样自然。特别是：
某些区域的过度模糊使背景看起来不真实。
对于纹理更复杂的图像，边缘复制并不总是有效。
原始图像 结果图像
问题：
在 OpenCV 或其他库中，是否有更复杂的方法来扩展图像的背景，从而产生更自然、无缝的结果？我愿意接受涉及高级图像处理技术或机器学习的方法。任何使用扩散模型的方法都可以。]]></description>
      <guid>https://stackoverflow.com/questions/78969286/how-can-i-improve-this-approach-for-natural-background-extension-in-an-image-usi</guid>
      <pubDate>Tue, 10 Sep 2024 11:32:09 GMT</pubDate>
    </item>
    <item>
      <title>保留 TFIDF 结果以预测新内容</title>
      <link>https://stackoverflow.com/questions/29788047/keep-tfidf-result-for-predicting-new-content</link>
      <description><![CDATA[我正在使用 Python 上的 sklearn 进行一些聚类。我已经训练了 200,000 个数据，下面的代码运行良好。
corpus = open(&quot;token_from_xml.txt&quot;)
vectorizer = CountVectorizer(decode_error=&quot;replace&quot;)
transformer = TfidfTransformer()
tfidf = transformer.fit_transform(vectorizer.fit_transform(corpus))
km = KMeans(30)
kmresult = km.fit(tfidf).predict(tfidf)

但是当我有新的测试内容时，我想将其聚类到我训练过的现有聚类中。所以我想知道如何保存IDF结果，以便我可以对新的测试内容进行TFIDF，并确保新测试内容的结果具有相同的数组长度。
提前致谢。
更新
如果其中一个包含经过训练的IDF结果，我可能需要将“transformer”或“tfidf”变量保存到文件（txt或其他文件）。
更新
例如。我有训练数据：
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]

然后执行 TFIDF，结果将包含 4 个特征（a、b、c、d）
当我测试时：
[&quot;a&quot;, &quot;c&quot;, &quot;d&quot;]

查看它属于哪个聚类（已由 k-means 生成）。TFIDF 只会给出具有 3 个特征（a、c、d）的结果，因此 k-means 中的聚类将下降。 （如果我测试 [&quot;a&quot;, &quot;b&quot;, &quot;e&quot;]，可能会有其他问题。）
那么如何存储测试数据的特征列表（甚至将其存储在文件中）？]]></description>
      <guid>https://stackoverflow.com/questions/29788047/keep-tfidf-result-for-predicting-new-content</guid>
      <pubDate>Wed, 22 Apr 2015 04:55:06 GMT</pubDate>
    </item>
    </channel>
</rss>