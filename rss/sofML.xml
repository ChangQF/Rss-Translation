<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>主动问题标记的机器学习 - 堆栈溢出</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>最近的30个来自stackoverflow.com</description>
    <lastBuildDate>Wed, 26 Mar 2025 06:25:40 GMT</lastBuildDate>
    <item>
      <title>如何在没有自动差异的神经网络的情况下实施反向传播？</title>
      <link>https://stackoverflow.com/questions/79535519/how-to-implement-backpropagation-without-auto-differentiation-for-a-feedforward</link>
      <description><![CDATA[我正在研究一个深度学习任务，该任务需要使用仅使用 numpy （没有Tensorflow，Pytorch或其他自动分辨率工具）实现 feedforward神经网络（FNN）。该网络具有三层（2048、512、10个神经元），使用 relu和SoftMax激活，并用 mini-Batch随机渐变（SGD）进行了优化。
分配需要手动实施向前传播，反向传播和重量更新，以确保我使用 BackPropagation AlgorithM  确保我正确计算每个层的梯度。。
但是，我正在努力正确地计算每个层的梯度，尤其是当处理 relu激活的衍生物和 softmax 时。我想确认我的梯度计算和重量更新是正确的。
 导入numpy作为NP

def relu（x）：
    返回np.maximum（0，x）

def relu_derivative（x）：
    返回（x＆gt; 0）.astype（float）＃relu derivative（1如果x＆gt; 0，else 0）

def softmax（x）：
    exp_x = np.exp（x -np.max（x，axis = 1，keepdims = true））＃稳定技巧
    返回exp_x / np.sum（exp_x，axis = 1，keepdims = true）

def cross_entropy_loss（y_pred，y_true）：
    返回-np.mean（np.sum（y_true * np.log（y_pred + 1e -9），轴= 1））＃防止log（0）

def softmax_cross_entropy_grad（y_pred，y_true）：
    返回y_pred -y_true＃softmax +跨渗透衍生物

def gradient_check（）：
    np.random.seed（42）＃确保可重复性
    
    ＃假输入（batch_size = 3，input_dim = 5）
    x = np.random.randn（3，5）
    w1 = np.random.randn（5，4）
    b1 = np.zeros（（1，4））

    ＃假式单壁编码标签（batch_size = 3，num_classes = 4）
    y = np.Array（[[[0，1，0，0]， 
                  [1，0，0，0]， 
                  [0，0，1，0]]）

    z1 = np.dot（x，w1） + b1
    a1 = relu（z1）
    y_pred = softmax（a1）
    损失= cross_entropy_loss（y_pred，y）

    dl_da1 = softmax_cross_entropy_grad（y_pred，y）＃渐变W.R.T. SoftMax输出
    dl_dz1 = dl_da1 * relu_derivative（z1）＃与relu的链条规则

    打印（y_pred（SoftMax输出）：\ n＆quort y_pred）
    打印（“损失：; quot”损失）
    打印（&#39;梯度W.R.T. SoftMax输出（DL/DA1）：\ n＆quort; dl_da1）
    打印（``relu derivative&#39;&#39;之后的渐变（dl/dz1）：\ n＆quort; dl_dz1）

gradient_check（）
 
我仅使用 numpy 并手动计算的反向传播实现了 feedforward神经网络（FNN）。我期望损失会降低和的准确性，但相反，损失波动，准确性保持 low ，有时梯度 爆炸或成为nan 。我怀疑 relu的导数和 softmax +交叉渗透梯度计算的问题，需要验证我的反向传播是否正确。]]></description>
      <guid>https://stackoverflow.com/questions/79535519/how-to-implement-backpropagation-without-auto-differentiation-for-a-feedforward</guid>
      <pubDate>Wed, 26 Mar 2025 05:59:43 GMT</pubDate>
    </item>
    <item>
      <title>我使用densenet-169创建了使用组织病理学图像预测结肠癌的模型，我该怎么做才能将F1分数从75％提高。</title>
      <link>https://stackoverflow.com/questions/79535469/i-used-densenet-169-in-creating-a-model-for-predicting-colon-cancer-using-histop</link>
      <description><![CDATA[我使用Python在10,000张图像的数据集上使用Densenet169创建了一个模型，以预测结肠癌，两个子文件夹有5000张图像，每张图像5000张图像用于良性和癌组织。训练持续了8小时，训练后的F1分数为0.75，这是不可取的。我试图查看我可以做出的更改以改善指标，但是我没有任何更改的方法，并且需要帮助确定可以在哪里进行更改以提高F1分数。这是我第一次从事这样的事情，我发现没有在线材料进行深度学习可以帮助我解决这个问题
 将TensorFlow导入为TF
来自Tensorflow.keras.applications导入Densenet169
来自tensorflow.keras.layers导入密集，globalaveration -pooling2d，Randomflip，RandomRotation，辍学
来自Tensorflow.keras.models导入模型，顺序
来自Tensorflow.keras.optimizer导入Adam
从tensorflow.keras.regulinizer导入l2
来自tensorflow.keras.applications.densenet导入preprocess_input
来自sklearn.metrics导入混淆_matrix，f1_score
导入numpy作为NP
进口海洋作为SNS
导入matplotlib.pyplot作为PLT
导入操作系统

＃定义常数
img_size =（224，224）＃匹配densenet169输入大小
batch_size = 32
时代= 15
data_dir =＆quot; colon_images＆quot;
class_names = [＆quast; cancyous&#39;&#39;正常＆quot;]
split_ratio = 0.2

＃直接加载数据集在224x224
def create_dataset（子集）：
    返回tf.keras.utils.image_dataset_from_directory（
        data_dir，
        验证_split = split_ratio，
        子集=子集
        种子= 42，
        image_size = img_size，＃直接以目标大小加载
        batch_size = batch_size，
        label_mode =&#39;binary&#39;
    ）

train_ds = create_dataset（“训练”）
val_ds = create_dataset（&#39;验证＆quot;）

＃通过增强进行预处理（仅在培训期间活跃）
预处理=顺序（[
    Randomflip（“水平”，“），
    随机旋转（0.1），
    tf.keras.layers.lambda（preprocess_input）＃正确归一化
）））

＃构建模型
base_model = densenet169（
    权重=&#39;Imagenet&#39;，
    include_top = false，
    input_shape = img_size +（3，）
）

输入= tf.keras.input（shape = img_size +（3，））
X =预处理（输入）
x = base_model（x）
x = globalaveragepooling2d（）（x）
x =密集（512，激活=&#39;relu&#39;，kernel_regularizer = l2（0.01））（x）
x =辍学（0.5）（x）＃正则化
输出=密集（1，激活=&#39;Sigmoid&#39;）（x）
模型=模型（输入，输出）

＃阶段1：火车顶层
base_model.trainable = false
model.compile（
    优化器= ADAM（1E-3），
    损失=&#39;binary_crossentropy&#39;，
    量表= [&#39;fecycy&#39;，tf.keras.metrics.auc（name =&#39;auc&#39;），
             tf.keras.metrics.precision（name =&#39;precision&#39;），
             tf.keras.metrics.Recall（name =&#39;recember&#39;）]
）

＃用回调监视AUC的火车
早期_stop = tf.keras.callbacks.earlystopping（
    Monitor =&#39;Val_auc&#39;，耐心= 3，模式=&#39;max&#39;，详细= 1
）
检查点= tf.keras.callbacks.modelcheckpoint（
    &#39;best_model.h5&#39;，save_best_only = true，monitor =&#39;val_auc&#39;，mode =&#39;max&#39;
）

历史= model.fit（
    train_ds，
    验证_data = val_ds，
    时代= epochs，
    回调= [早期_STOP，检查点]
）

＃阶段2：微调整个模型
base_model.trainable = true
model.compile（
    优化器= ADAM（1E-5），＃非常低的学习率
    损失=&#39;binary_crossentropy&#39;，
    量表= [&#39;facer&#39;，tf.keras.metrics.auc（name =&#39;auc&#39;）]
）

history_fine = model.fit（fit）（
    train_ds，
    验证_data = val_ds，
    时代= epochs，
    onirome_epoch = history.epoch [-1]，
    回调= [早期_STOP，检查点]
）

＃ 评估
y_pred =（model.predict（val_ds）＆gt; 0.5）.astype（int）
y_true = np.concatenate（[y for _，y in val_ds]，axis = 0）

打印（f＆quot f1分数：{f1_score（y_true，y_pred）：。3f}＆quot;）
 ]]></description>
      <guid>https://stackoverflow.com/questions/79535469/i-used-densenet-169-in-creating-a-model-for-predicting-colon-cancer-using-histop</guid>
      <pubDate>Wed, 26 Mar 2025 05:27:58 GMT</pubDate>
    </item>
    <item>
      <title>我的加权动态时间扭曲算法中是否存在错误</title>
      <link>https://stackoverflow.com/questions/79535435/is-there-an-error-in-my-weighted-dynamic-time-warping-algorithm</link>
      <description><![CDATA[使用平均归一化，并为算法中的输入进行修改的逻辑权重函数。不确定我的代码或我的数据是否弄乱了，使用了两个不同人的步态数据数据集，而我的距离最终是：0.06495056266749273 
我将以下公式用于WDTW和修改后的逻辑权重函数：
      def stripfunction（i_j，g，w_max）：#calculates修改后的逻辑权重函数
  尺寸= len（x）
  m_c = size // 2

  返回w_max /（1 + np.exp（-g*（i_j -m_c）））

def euclidean_distances（x，y）：
      返回np.sqrt（np.sum（（（x -y）** 2）））

def witeeddtw（x，y，vector = true）：
  w_max = 3

  n，m = X.Shape [0]，y.Shape [0]
  成本= np r.zeros（（（n，m））

  成本[0,0] = euclidean_distances（x [0]，y [0]）

  对于我在范围（1，n）中：
    成本[i，0] =成本[I-1，0] + Euclidean_distances（x [i]，y [0]）

  对于J范围（1，m）的J：
    成本[0，j] =成本[0，j-1] + euclidean_distances（x [0]，y [j]）


  对于我在范围（1，n）中：
    对于J范围（1，m）的J：
      i_j = euclidean_distances（x [i]，y [j]）
      w =重量函数（I_J，0.4，W_MAX）
      min_value = min（[成本[I-1，J-1]，成本[I-1，J]，成本[I，J-1]]）
      成本[i，j] = w * i_j + min_value

    max_dist = w_max *（n + m -2）
    norm_dist = cop [n-1，m-1] / max_dist


  退货成本[N-1，M-1]，NORM_DIST

x_norm =（x -np.mean（x，axis = 0）） /（np.max（x，axis = 0）-np.min（x，axis = 0））

y_norm =（y -np.mean（y，axis = 0）） /（np.max（y，axis = 0）-np.min（y，axis = 0））


＃计算WDTW
距离，归一化=加权dtw（x_norm [：，0]，y_norm [：，0]）

打印（f＆quot&#39;wdtw距离：{demand}＆quot;）
打印（f＆quot“归一化wdtw距离：{normolized_distance}＆quort”）
 ]]></description>
      <guid>https://stackoverflow.com/questions/79535435/is-there-an-error-in-my-weighted-dynamic-time-warping-algorithm</guid>
      <pubDate>Wed, 26 Mar 2025 04:58:34 GMT</pubDate>
    </item>
    <item>
      <title>训练量：“包装”和“ group_by_length”相互抵消？</title>
      <link>https://stackoverflow.com/questions/79533473/trainingarguments-do-packing-and-group-by-length-counteract-each-other</link>
      <description><![CDATA[在huggingface的 sftConfig （从 trieb&gt; triagn&gt; triagn&gt; triebs triaght&gt; triaghtarguments ）中，有两个参与priaged ）


  group_by_length ：是否将训练数据集中大致相同长度的样本组合在一起（以最大程度地减少应用的填充并更有效）。仅在应用动态填充时有用。
 包装：是否将多个序列打包到固定长度格式中。使用 max_length 定义序列长度。


  config = sftConfig（...，，， 
                   group_by_length = true， 
                   包装= true，...）
 
这些论点的目的是减少填充桨的努力。但是，当 packing = true 时，使用 使用 group_by_length = true 。我们是否可以两者都提高训练表现？他们互相抵消吗？]]></description>
      <guid>https://stackoverflow.com/questions/79533473/trainingarguments-do-packing-and-group-by-length-counteract-each-other</guid>
      <pubDate>Tue, 25 Mar 2025 11:13:20 GMT</pubDate>
    </item>
    <item>
      <title>GOCV和Python OpenCV之间的推断结果不同</title>
      <link>https://stackoverflow.com/questions/79533406/different-inference-results-between-gocv-and-python-opencv</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79533406/different-inference-results-between-gocv-and-python-opencv</guid>
      <pubDate>Tue, 25 Mar 2025 10:48:10 GMT</pubDate>
    </item>
    <item>
      <title>在HuggingFace Seq2Seqtrainer中使用培训，验证和测试集[闭合]</title>
      <link>https://stackoverflow.com/questions/79532570/use-of-training-validation-and-test-set-in-huggingface-seq2seqtrainer</link>
      <description><![CDATA[ i具有以下数据集，该数据集具有3个拆分（ Train ，验证和 test ）。数据是2种语言的平行语料库。
  datasetDict（{{
    火车：数据集（{
        功能：[&#39;translation&#39;]，
        num_rows：109942
    }））
    验证：数据集（{
        功能：[&#39;translation&#39;]，
        num_rows：6545
    }））
    测试：数据集（{
        功能：[&#39;translation&#39;]，
        num_rows：13743
    }））
}））
 
对于我的 seq2seqtrainer ，我提供数据集如下：
  trainer = seq2seqtrainer（
    模型=模型，
    args =训练_args，
    train_dataset = tokenized_dataset [&#39;train&#39;]，
    eval_dataset = tokenized_dataset [&#39;验证&#39;]，
    tokenizer = tokenizer，
    data_collat​​or = data_collat​​or，
    compute_metrics = compute_metrics，
）
 
将验证拆分 ever_dataset 中的拆分是正确的吗？在 documentation&gt; documentation 

用于评估的数据集。如果是数据集，则自动删除 model.forward（）方法未接受的列。如果是字典，它将在每个数据集上进行评估。

或者我应该将测试分配在 eval_dataset 中？无论哪种方式，都没有使用其中一个分裂？]]></description>
      <guid>https://stackoverflow.com/questions/79532570/use-of-training-validation-and-test-set-in-huggingface-seq2seqtrainer</guid>
      <pubDate>Tue, 25 Mar 2025 02:22:21 GMT</pubDate>
    </item>
    <item>
      <title>Lora Fineted Llama 8b的自定义前往前方法 - 使用Unsploth</title>
      <link>https://stackoverflow.com/questions/79531231/custom-forward-method-for-lora-finetuned-llama-8b-using-unsloth</link>
      <description><![CDATA[我正在尝试对我的固定模型进行一些消融研究。试图超载前向方法
 类GROK_CUSTOMPEFTCAUSALLM（TORCH.NN.MODULE）：
def __init __（自我，模型）：
    super（）.__ init __（）
    self.model =型号＃原始fastlanguagemodel

    ＃修补内部模型的前进
    orig_forward = self.model.model.forward

    def new_forward（inned_self，input_ids，activation_mask = none，num_logits_to_keep = none，** kwargs）：
        打印（&#39;🔹自定义前进被调用！＆quot; flush = true）

        ＃嵌入
        hidden_​​states = inner_self.model.embed_tokens（input_ids）
        打印（嵌入后隐藏状态：{hidden_​​states.shape}＆quot; flush = true）

        ＃注意面具
        如果active_mask无：
            activation_mask = torch.ones（input_ids.shape，dtype = type = turch.bfloat16，device = input_ids.device）.bool（）
        别的：
            ##强制入bool
            activation_mask = activation_mask.bool（）

        ＃层
        past_key_values =无
        对于i，在枚举中层（inner_self.model.layers）：
            打印（f＆quot&#39;layer {i}＆quot＆quot＆clush = true）
            layer_output = layer（hidden_​​states，activation_mask = activation_mask）
            print（f&#39;layer {i} output：{type（layer_output）}，len：{len（layer_output）如果isInstance（layer_output，tuple，tuple）else 1}＆quot;，\ \
                                                                                              冲洗= true）
            hidden_​​states = layer_output [0]如果isInstance（layer_output，tuple）else layer_output
            如果len（layer_output）＆gt; 1：
                past_key_values = layer_output [1]＃更新kv缓存
            print（f＆quot&#39;efter layer {i}：{hidden_​​states.shape}＆quort＆quort＆quort; flush = true）

        ＃规范
        hidden_​​states = inner_self.model.norm（hidden_​​states）
        print（f＆quot&#39;norm：{hidden_​​states.shape}＆quort＆quot; flush = true）

        ＃logits
        logits = inner_self.lm_head（hidden_​​states）
        print（f＆quot“ logits：{logits.shape}＆quort”，flush = true）

        ＃返回完整输出
        返回causallMoutputwithpast（logits = logits，past_key_values = past_key_values）
    ＃覆盖内部模型的前进
    导入类型
    self.model.model.forward = types.methodtype（new_forward，self.model.model）

def生成（self， *args，** kwargs）：
    打印（&#39;🔹自定义生成调用！＆quot; flush = true）
    ＃过滤num_logits_to_keep

    if&#39;num_logits_to_keep＆quot在夸尔格斯：
        del Kwargs [＆quot; num_logits_to_keep;]
    返回self.model.generate（*args，** kwargs）
 
我像这样调用了
 模型，tokenizer = fastlanguagemodel.from_pretrateing（
        model_name = inf_model_，
        max_seq_length = 3072，
        dtype = none，
        load_in_4bit = true
）

eos_token = tokenizer.eos_token

模型= fastlanguagemodel.for_inference（模型）

＃补丁传递通行证
模型= grok_custompeftcausallm（模型）
print（type（model.model））＃确保它是您的“ SkippableModel”
输入= tokenizer（
[
    data_prompt.format（
        语境_，
        “”
    ）
]，return_tensors =; pt; quot。


print（data_prompt.format（上下文_，; quord;））
启动器_ = time.time（）
输出=型号。generate（**输入，max_new_tokens = 800，温度= 0.1）
打印（&#39;take out ::&#39;，time.time（） - 启动_）

答案= tokenizer.batch_decode（输出）
 
它只是生成gibberish（在没有此超载的情况下，它的性能绝对是预期的 - 良好的代码生成）。现在的问题是，我可以使用的层次结构的唯一部分是Model.Model，它指向基本Meta Llama上的Casualllama包装器。我有一种不好的感觉，这不是正确的前进，不塞在引擎盖下发生了其他事情。我在这里缺少什么？]]></description>
      <guid>https://stackoverflow.com/questions/79531231/custom-forward-method-for-lora-finetuned-llama-8b-using-unsloth</guid>
      <pubDate>Mon, 24 Mar 2025 13:38:48 GMT</pubDate>
    </item>
    <item>
      <title>为什么我的代码不导致张量的错误“元素0”不需要毕业，也不需要grad_fn'</title>
      <link>https://stackoverflow.com/questions/79524465/why-does-not-my-code-cause-the-error-element-0-of-tensors-does-not-require-grad</link>
      <description><![CDATA[给定下面的代码片段，我使用 model.fc1.requires_grad_（false） and  model.fc2.requires_grad_（false）冻结神经网络的权重。
如果我使用损失=标准（输出，y_batch）来计算损失，则训练很好。为什么它不会导致错误 RuntimeError：张量的元素0不需要grad，也不需要Grad_fn ？
我认为这应该导致错误，因为神经网络的所有层都已冻结。
 导入火炬
导入Torch.nn作为nn
导入Torch.optim作为最佳
来自Torch.utils.data导入数据载体，TensordataSet

＃定义一个简单的神经网络
类SimpleNet（nn.Module）：
    def __init __（self，input_size，hidden_​​size，output_size）：
        超级（SimpleNet，Self）.__ INIT __（）
        self.fc1 = nn.linear（input_size，hidden_​​size）
        self.fc2 = nn.linear（hidden_​​size，output_size）

    def向前（self，x）：
        x = self.fc1（x）
        x = self.fc2（x）
        返回x

input_size = 3
hidden_​​size = 3
output_size = 3
batch_size = 16
num_epochs = 1
Learning_rate = 0.01
num_samples = 1000 
x_train = torch.randn（num_samples，input_size，quirenes_grad = true）  
y_train = torch.ones（（num_samples，output_size））
dataset = tensordataset（x_train，y_train）
dataloader = dataloader（数据集，batch_size = batch_size，shuffle = true）

model = simpleNet（input_size，hidden_​​size，output_size）


标准= nn.Crossentropyloss（）
优化器= Optim.SGD（model.parameters（），lr = Learning_rate）

对于范围（num_epochs）的时代：
    total_loss = 0
    对于emumerate（dataloader）中的batch_idx（x_batch，y_batch）：
        优化器.zero_grad（）
        输出=模型（x_batch）
        损失=标准（输出，y_batch）
        打印（损失。_grad_fn）
        loss.backward（） 
        优化器.step（） 
                
        if（batch_idx + 1）％10 == 0：
            print（f&#39;batch [{batch_idx + 1}/{len（dataloader）}]，损失：{loss.item（）：。4f}&#39;）
            model.fc1.requires_grad_（false）
            model.fc2.requires_grad_（false）
                        
打印（“训练完成！”）
 ]]></description>
      <guid>https://stackoverflow.com/questions/79524465/why-does-not-my-code-cause-the-error-element-0-of-tensors-does-not-require-grad</guid>
      <pubDate>Fri, 21 Mar 2025 02:40:41 GMT</pubDate>
    </item>
    <item>
      <title>DL4J自动编码器用于异常检测：意外结果[封闭]</title>
      <link>https://stackoverflow.com/questions/79523631/dl4j-autoencoder-for-anomaly-detection-unexpected-results</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79523631/dl4j-autoencoder-for-anomaly-detection-unexpected-results</guid>
      <pubDate>Thu, 20 Mar 2025 16:59:01 GMT</pubDate>
    </item>
    <item>
      <title>节点/边缘归因的有向图嵌入</title>
      <link>https://stackoverflow.com/questions/79508535/node-edge-attributed-directed-graph-embedding</link>
      <description><![CDATA[  graph2vec  gl2vec  in  karateclub 需要什么？它确实提到应该没有字符串功能，但是无论有没有它，我都会遇到以下代码的错误：
 导入NetworkX为Nx
导入Karateclub为KC
导入matplotlib.pyplot作为PLT

g = nx.digraph（）

g.add_node（0，label =; a;
g.add_node（1，label =; b＆quot; feature = [1.2]）
g.add_node（2，label =; c＆quot;特征= [0.8]）

g.add_edge（0，1）
g.add_edge（0，2）
g.add_edge（1，2）

nx.draw_networkx（g，with_labels = true）
plt.show（）

图= [g]

型号= kc.graph_embedding.graph2vec（）
型号（图）
嵌入= model.get_embedding（）
打印（嵌入）
 
错误： RuntimeError：您必须在训练模型之前先构建词汇 
我在 word2vec 中看到了一个选项，但是如何为 graph2vec ？执行此操作。
是否有任何替代软件包，最好使用 KarateClub 等更简单的实现，我可以用来生成定向节点/edge属性列表 network&gt; networkx  Graphs 图形而无需定义训练/测试集吗？]]></description>
      <guid>https://stackoverflow.com/questions/79508535/node-edge-attributed-directed-graph-embedding</guid>
      <pubDate>Fri, 14 Mar 2025 08:52:01 GMT</pubDate>
    </item>
    <item>
      <title>高效NETB3模型的准确性非常低，并且在识别脑肿瘤问题方面学习高原[封闭]</title>
      <link>https://stackoverflow.com/questions/79390644/very-low-accuracy-of-efficientnetb3-model-and-learning-plateau-on-identifying-br</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79390644/very-low-accuracy-of-efficientnetb3-model-and-learning-plateau-on-identifying-br</guid>
      <pubDate>Mon, 27 Jan 2025 11:58:17 GMT</pubDate>
    </item>
    <item>
      <title>神经网络精确度低</title>
      <link>https://stackoverflow.com/questions/73780627/neural-network-low-accuracy</link>
      <description><![CDATA[该模型的精度确实很低。这是我第一次写神经网络，所以我真的不知道如何使它变得更好
 将TensorFlow导入为TF
导入matplotlib.pyplot作为PLT
    
#data设置
data = tf.keras.datasets.cifar10


（x_train，y_train），（x_test，y_test）= data.load_data（）
plt.imshow（x_train [0]，cmap = plt.cm.binary）

#normalize数据
x_train = tf.keras.utils.normalize（x_train，axis = 1）
x_test = tf.keras.utils.normalize（x_test，axis = 1）

#building AI模型

型号= tf.keras.models.sequeential（）
Model.Add（tf.keras.layers.flatten（））
model.Add（tf.keras.layers.dense（128，激活= tf.nn.relu））
model.Add（tf.keras.layers.dense（128，激活= tf.nn.relu））
model.Add（tf.keras.layers.dense（10，激活= tf.nn.softmax）））



#compile模型
model.compile（优化器=&#39;adam&#39;，
             损失=&#39;Sparse_categorical_crossentropy&#39;，
             指标= [&#39;准确性&#39;]）

plt.show（）
#Train AI模型
model.fit（x_train，y_train，epochs = 3）
 ]]></description>
      <guid>https://stackoverflow.com/questions/73780627/neural-network-low-accuracy</guid>
      <pubDate>Tue, 20 Sep 2022 00:59:44 GMT</pubDate>
    </item>
    <item>
      <title>神经网络的精度非常低</title>
      <link>https://stackoverflow.com/questions/65777704/getting-a-very-low-accuracy-with-neural-network</link>
      <description><![CDATA[我正在尝试使用keras在CIFAR-10数据集上实现ANN
但是由于某种原因，我不知道我只能获得10％的准确性？
我分别使用了5个隐藏层IWTH 8,16,32,64,128神经元。
 这是jupyter笔记本 的链接
  model = sequention（）
model.Add（密集（单位= 8，activation =&#39;sigmoid&#39;，input_dim = x.shape [1]）））））
model.Add（密集（单位= 16，activation =&#39;Sigmoid&#39;））））
model.Add（密集（单位= 32，activation =&#39;Sigmoid&#39;））
model.Add（密集（单位= 64，activation =&#39;sigmoid&#39;））
model.Add（密集（单位= 128，activation =&#39;Sigmoid&#39;））
model.Add（密度（单位= 10，activation =&#39;softmax&#39;））

model.compile（loss =&#39;accorical_crossentropy&#39;，importizer =&#39;adam&#39;，量表= [&#39;fecicy&#39;]）

model.fit（x_train，y_train，epochs = 1000，batch_size = 500）
 ]]></description>
      <guid>https://stackoverflow.com/questions/65777704/getting-a-very-low-accuracy-with-neural-network</guid>
      <pubDate>Mon, 18 Jan 2021 15:44:46 GMT</pubDate>
    </item>
    <item>
      <title>Pytorch中的数据增强</title>
      <link>https://stackoverflow.com/questions/51677788/data-augmentation-in-pytorch</link>
      <description><![CDATA[我对Pytorch中执行的数据增加有些困惑。现在，据我所知，当我们执行数据增强时，我们将保留原始数据集，然后添加其他版本（翻转，裁剪等）。但这似乎并没有发生在Pytorch中。据我从参考文献中理解时，当我们在pytorch中使用 data.transforms 时，它将它们一一应用它们。因此：
  data_transforms = {
    &#39;train&#39;：transforms.compose（[
        transforms.randomresizedcrop（224），
        transforms.randomhorizo​​ntalflip（），
        transforms.totensor（），
        transforms.normize（[0.485，0.456，0.406]，[0.229，0.224，0.225]）
    ]），，
    &#39;val&#39;：transforms.compose（[
        转换式Resize（256），
        transforms.centercrop（224），
        transforms.totensor（），
        transforms.normize（[0.485，0.456，0.406]，[0.229，0.224，0.225]）
    ]），，
}
 
在这里，对于培训，我们首先是随机裁剪图像并将其调整为Shape （224,224）。然后，我们将这些（224,224）图像进行水平翻转。因此，我们的数据集现在仅包含水平翻转的图像，因此在这种情况下，我们的原始图像丢失了。
我对吗？这理解是正确的吗？如果不是，那么我们在上面的此代码中（取自官方文档）将Pytorch告诉原始图像并将其调整到预期形状（224,224）？]]></description>
      <guid>https://stackoverflow.com/questions/51677788/data-augmentation-in-pytorch</guid>
      <pubDate>Fri, 03 Aug 2018 17:51:49 GMT</pubDate>
    </item>
    <item>
      <title>在GridSearchCV中得分XGBoost</title>
      <link>https://stackoverflow.com/questions/50296817/scoring-in-gridsearchcv-for-xgboost</link>
      <description><![CDATA[我正在尝试使用XGBoost首次分析数据。我想使用GridSearchCV找到最佳参数。我想最大程度地减少均方根错误，为此，我使用了“ rmse”。作为eval_metric。但是，网格搜索的评分没有这样的度量。我在此网站上发现“ neg_mean_squared_error”这样做一样，但是我发现这给我与RMSE不同的结果。当我计算“ neg_mean_squared_error”的绝对值的根目录时，我的值约为8.9，而不同的功能使我的RMSE约为4.4。
我不知道怎么了，或者如何获得这两个功能同意/给出相同的值？
由于这个问题，我遇到了错误的值，因为 best_params _ ，它比我最初开始调音的某些值更高的RMSE。
如何在网格搜索中获得RMSE的分数以及为什么我的代码给出不同的值？
  def modelfit（alg，trainx，trainy，usetraincv = true，cv_folds = 10，armond_stopping_rounds = 50）：
    如果用UsetrainCV：
        xgb_param = alg.get_xgb_params（）
        xgtrain = xgb.dmatrix（trainx，label = Trainy）
        cvresult = xgb.cv（xgb_param，xgtrain，num_boost_round = alg.get_params（）[&#39;n_estimators&#39;]，nfold = cv_folds，
                          指标=&#39;rmse&#39;，ropard_stopping_rounds = armon_stopping_rounds）
        alg.set_params（n_estimators = cvresult.shape [0]）

    ＃将算法适合数据
    alg.fit（Trainx，Trainy，eval_metric =&#39;rmse&#39;）

    ＃预测训练集：
    dtrain_predictions = alg.predict（trainx）
    ＃dtrain_predprob = alg.predict_proba（Trainy）[：，1]
    打印（dtrain_predictions）
    print（np.sqrt（mean_squared_error（trainy，dtrain_predictions））））））））

    ＃打印模型报告：
    打印（“ \ nmodel报告”）
    打印（&#39;rmse：％.4G;％np.sqrt（量学

 param_test2 = {
 &#39;max_depth&#39;：[6,7,8]，
 &#39;min_child_weight&#39;：[2,3,4]
}

grid2 = gridSearchCV（估算= xgb.xgb.xgbregressor（Learning_rate = 0.1，n_estimators = 2000，max_depth = 5，
 min_child_weight = 2，gamma = 0，subsampe = 0.8，colsample_bytree = 0.8，
 objective =&#39;reg：linear&#39;，nthread = 4，scale_pos_weight = 1，andury_state = 4），
 param_grid = param_test2，评分=&#39;neg_mean_squared_error&#39;，n_jobs = 4，iid = false，cv = 10，冗长= 20）
grid2.fit（x_train，y_train）
＃best_estimator的平均交叉验证得分
print（grid2.best_params_，np.sqrt（np.abs（grid2.best_score_）））），print（np.sqrt（np.abs（grid2.score2.score（x_train，y_train，y_train））））
modelfit（grid2.best_estimator_，x_train，y_train）
print（np.sqrt（np.abs（grid2.score）（x_train，y_train）））））））））））
 ]]></description>
      <guid>https://stackoverflow.com/questions/50296817/scoring-in-gridsearchcv-for-xgboost</guid>
      <pubDate>Fri, 11 May 2018 16:46:16 GMT</pubDate>
    </item>
    </channel>
</rss>