<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - 堆栈内存溢出</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 条</description>
    <lastBuildDate>Thu, 19 Dec 2024 01:20:07 GMT</lastBuildDate>
    <item>
      <title>如何使用神经网络为二元分类器绘制平滑的决策边界？</title>
      <link>https://stackoverflow.com/questions/79292743/how-to-plot-a-smooth-decision-boundary-for-a-binary-classifier-using-a-neural-ne</link>
      <description><![CDATA[我正在尝试实现一个简单的神经网络来对圆形数据集进行分类并绘制一个平滑的决策边界。但是，我的决策边界不平滑或不正确。我希望它看起来像此示例中显示的边界：
像这样 
当我运行代码时，决策边界是锯齿状的，或者与我的数据集的形状不匹配。我希望内部类周围有一条平滑的曲线。
这是我的代码：
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_circles

# 生成数据集
X, y = make_circles(n_samples=100, noise=0.1, factor=0.3, random_state=0)
X = X.T # 转置 X
y = y.reshape((1, y.shape[0])) # 将 y 重塑为行向量

# 数据集可视化
plt.scatter(X[0, :], X[1, :], c=y.flatten())
plt.title(&#39;Dataset&#39;)
plt.xlabel(&#39;Feature 1&#39;)
plt.ylabel(&#39;Feature 2&#39;)
plt.show()

def paramètres(n0=2, n1=2, n2=1):
W1 = np.random.randn(n1, n0)
b1 = np.zeros((n1, 1))
W2 = np.random.randn(n2, n1)
b2 = np.zeros((n2, 1))
参数 = {
&#39;W1&#39;: W1,
&#39;b1&#39;: b1,
&#39;W2&#39;: W2,
&#39;b2&#39;: b2
}
返回参数

def G(X, theta, b):
Z = theta.dot(X) + b
返回 Z, 1/(1+np.exp(-Z))

def forwardPropagation(X, 参数):
W1 = 参数[&#39;W1&#39;]
b1 = 参数[&#39;b1&#39;]
W2 = 参数[&#39;W2&#39;]
b2 =参数[&#39;b2&#39;]

Z1, A1 = G(X, W1, b1)
Z2, A2 = G(A1, W2, b2) 

激活 = {
&#39;A1&#39;: A1,
&#39;A2&#39;: A2
}
返回激活

def backPropagation(X, y, 参数, 激活):
A1 = 激活[&#39;A1&#39;]
A2 = 激活[&#39;A2&#39;]
W2 = 参数[&#39;W2&#39;]

m = y.shape[1]

dZ2 = A2 - y
dW2 = 1 / m * dZ2.dot(A1.T)
db2 = 1 / m * np.sum(dZ2, axis=1, keepdims=True)

dZ1 = np.dot(W2.T, dZ2) * A1 * (1 - A1)
dW1 = 1 / m * dZ1.dot(X.T)
db1 = 1 / m * np.sum(dZ1, axis=1, keepdims=True)

gradients = {
&#39;dW1&#39;: dW1,
&#39;db1&#39;: db1,
&#39;dW2&#39;: dW2,
&#39;db2&#39;: db2
}

return gradients

def update(gradients, parametres, learning_rate):
W1 = parametres[&#39;W1&#39;]
b1 = parametres[&#39;b1&#39;]
W2 = parametres[&#39;W2&#39;]
b2 = parametres[&#39;b2&#39;]

dW1 = gradients[&#39;dW1&#39;]
db1 = gradients[&#39;db1&#39;]
dW2 = gradients[&#39;dW2&#39;]
db2 = gradients[&#39;db2&#39;]

W1 = W1 - 学习率 * dW1
b1 = b1 - 学习率 * db1
W2 = W2 - 学习率 * dW2
b2 = b2 - 学习率 * db2

参数 = {
&#39;W1&#39;: W1,
&#39;b1&#39;: b1,
&#39;W2&#39;: W2,
&#39;b2&#39;: b2
}

返回参数

def predict(X, 参数):
激活 = forwardPropagation(X, 参数)
返回激活[&#39;A2&#39;]

def neuro_network(X, y, n1=2, learning_rate=0.1, n_iter=1000):
n0 = X.shape[0] 
n2 = y.shape[0] 
np.random.seed(0)
参数 = paramètres(n0, n1, n2)

for i in range(n_iter):
activations = forwardPropagation(X, parametres)
gradients = backPropagation(X, y, parametres,activations)
parametres = update(gradients, parametres, learning_rate)

return parametres,activations

# 训练模型
parametres,activations = neuro_network(X, y, n1=2, learning_rate=0.1, n_iter=1000)

# 绘制决策边界
x_min, x_max = X[0, :].min() - 1, X[0, :].max() + 1
y_min, y_max = X[1, :].min() - 1, X[1, :].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),
np.arange(y_min, y_max, 0.02))

Z = predict(np.c_[xx.ravel(), yy.ravel()].T, parametres)

Z = Z.reshape(xx.shape)

plt.figure()
plt.contourf(xx, yy, Z, levels=[0, 0.5, 1], alpha=0.8, cmap=plt.cm.RdYlBu)
plt.scatter(X[0, :], X[1, :], c=y.flatten(), cmap=plt.cm.RdYlBu)
plt.title(&#39;决策边界&#39;)
plt.xlabel(&#39;特征 1&#39;)
plt.ylabel(&#39;特征 2&#39;)
plt.show()
]]></description>
      <guid>https://stackoverflow.com/questions/79292743/how-to-plot-a-smooth-decision-boundary-for-a-binary-classifier-using-a-neural-ne</guid>
      <pubDate>Wed, 18 Dec 2024 23:11:54 GMT</pubDate>
    </item>
    <item>
      <title>Keras 模型：调试维度后输入形状不匹配问题</title>
      <link>https://stackoverflow.com/questions/79292676/keras-model-input-shape-mismatch-issue-after-debugging-dimensions</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79292676/keras-model-input-shape-mismatch-issue-after-debugging-dimensions</guid>
      <pubDate>Wed, 18 Dec 2024 22:34:35 GMT</pubDate>
    </item>
    <item>
      <title>如何以与“https://www.tensorflow.org/tfmodels/vision/object_detection”中类似的方式修改配置文件？</title>
      <link>https://stackoverflow.com/questions/79292447/how-can-i-modify-the-config-file-in-a-similar-way-used-in-https-www-tensorflo</link>
      <description><![CDATA[我是这个领域的新手，我正在寻找有关如何修改现有脚本以使用 EfficientDet D1 模型的指导。我按照教程操作，并使用默认脚本成功训练了一个自定义数据集。该脚本使用以下行来配置模型：
exp_config = exp_factory.get_exp_config(&#39;retinanet_resnetfpn_coco&#39;)

这对于默认的 RetinaNet 模型来说很好。但是，我想改用 EfficientDet D1 模型。我已经下载了 EfficientDet D1 配置文件，但不确定如何在脚本中引用它。
我尝试过的方法

检查了配置文件：我检查了 EfficientDet D1 配置文件中的参数，看它是否有任何明确的引用名称，可以与 exp_factory.get_exp_config() 一起使用。
检查了替代配置方法：我寻找了加载自定义模型配置的其他方法，但找不到任何明确的说明。

我正在寻找什么

如何修改 exp_factory.get_exp_config() 行以引用 EfficientDet D1 配置文件？
如果这种方法不可行，如何手动加载和引用配置文件？
配置文件本身是否需要进行任何特定更改才能使其工作？

如果需要，我愿意手动修改配置文件参数。并尝试通过此方法运行训练
!python model_main_tf2.py \
--model_dir=/content/trainingdemo/models/my_efficientDet_d0 \
--pipeline_config_path=/content/trainingdemo/models/my_efficientDet_d0/pipeline.config

&quot;但结果是`
2024-12-18 23:14:43.163543: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] 无法注册 cuFFT 工厂：尝试注册插件 cuFFT 工厂，但已注册一个
警告：调用 absl::InitializeLog() 之前的所有日志消息都写入 STDERR
E0000 00:00:1734563683.182126 16153 cuda_dnn.cc:8310] 无法注册 cuDNN 工厂：尝试注册插件 cuDNN 工厂，但已注册一个
E0000 00:00:1734563683.187813 16153 cuda_blas.cc:1418] 无法注册 cuBLAS 工厂：尝试注册插件 cuBLAS 的工厂，但已注册一个工厂
回溯（最近一次调用）：
文件 &quot;/content/trainingdemo/model_main_tf2.py&quot;，第 32 行，位于 &lt;module&gt;
来自 object_detection 导入 model_lib_v2
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/model_lib_v2.py&quot;，第 29 行，位于 &lt;module&gt;
来自 object_detection 导入 eval_util
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/eval_util.py&quot;，第 35 行，位于 &lt;module&gt;
从 object_detection.metrics 导入 coco_evaluation
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/metrics/coco_evaluation.py&quot;，第 28 行，位于 &lt;module&gt;
从 object_detection.utils 导入 o​​bject_detection_evaluation
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/utils/object_detection_evaluation.py&quot;，第 46 行，位于 &lt;module&gt;
从 object_detection.utils 导入 label_map_util
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/utils/label_map_util.py&quot;，第 29 行，位于 &lt;module&gt;
从 object_detection.protos 导入 string_int_label_map_pb2
文件 &quot;/usr/local/lib/python3.10/dist-packages/object_detection/protos/string_int_label_map_pb2.py&quot;，第 33 行，位于 &lt;module&gt;
_descriptor.EnumValueDescriptor(
文件 &quot;/usr/local/lib/python3.10/dist-packages/google/protobuf/descriptor.py&quot;，第 789 行，位于 __new__
_message.Message._CheckCalledFromGeneratedFile()
TypeError：无法直接创建描述符。
如果此调用来自 _pb2.py 文件，则您生成的代码已过时，必须使用 protoc &gt;= 3.19.0 重新生成。
如果您无法立即重新生成您的原型，其他一些可能的解决方法是：
1. 将 protobuf 包降级到 3.20.x 或更低版本。
2. 设置 PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python（但这将使用纯 Python 解析，速度会慢得多）。

`
任何指导或代码示例将不胜感激。提前致谢！]]></description>
      <guid>https://stackoverflow.com/questions/79292447/how-can-i-modify-the-config-file-in-a-similar-way-used-in-https-www-tensorflo</guid>
      <pubDate>Wed, 18 Dec 2024 20:49:15 GMT</pubDate>
    </item>
    <item>
      <title>这种模式有哪些可能的增强？</title>
      <link>https://stackoverflow.com/questions/79292370/what-is-the-possible-enhancement-for-this-mode</link>
      <description><![CDATA[我使用 LSTM 对多标签电影类型进行分类，并使用 Word2Vec 作为特征提取；如图所示，该模型得出的指标为测试损失：0.3067，测试准确率：0.5144。

这个模型可能有哪些改进？ 
我使用下面的代码：
# 标记文本
tokenizer = Tokenizer()
tokenizer.fit_on_texts(merged_df[&#39;clean&#39;])

sequences = tokenizer.texts_to_sequences(merged_df[&#39;clean&#39;])
X = pad_sequences(sequences, maxlen=max_len, padding=&#39;post&#39;, truncating=&#39;post&#39;) # 将序列填充到最大长度

# 词汇表大小
vocab_size = len(tokenizer.word_index) + 1 # 包含 0 作为填充
print(f&quot;词汇表大小： {vocab_size}&quot;)

#vocab_size=37696
embedding_dim=300
max_len=1000

embedding_matrix = np.zeros((vocab_size, embedding_dim))

# 将单词映射到向量
for word, i in tokenizer.word_index.items():
if word in word2vec:
embedding_matrix[i] = word2vec[word]
else:
# 使用随机值初始化不在 Word2Vec 中的单词
embedding_matrix[i] = np.random.uniform(-0.25, 0.25, embedding_dim)

print(f&quot;Embedding Matrix Shape: {embedding_matrix.shape}&quot;)

from keras.layers import Input, Embedding, Bidirectional, LSTM, Attention, BatchNormalization、Dropout、Dense
来自 keras.models 导入模型

# 定义输入层 (shape = (None, max_len))
input_layer = Input(shape=(max_len,))
embedded_input = Embedding(input_dim=vocab_size, 
output_dim=embedding_dim, 
weights=[embedding_matrix], 
input_length=max_len, 
trainable=False)(input_layer)
query = Bidirectional(LSTM(128,activation=&#39;tanh&#39;, return_sequences=True))(embedded_input)
attention_output = Attention()([query, query]) # 自注意力机制
attention_output = BatchNormalization()(attention_output)
attention_output = Dropout(0.5)(attention_output)
lstm_output = Bidirectional(LSTM(64,激活=&#39;tanh&#39;，return_sequences=True))(attention_output)
lstm_output = Dropout(0.5)(lstm_output)
lstm_output2 = Bidirectional(LSTM(32，激活=&#39;tanh&#39;，return_sequences=False))(lstm_output)
lstm_output2 = Dropout(0.5)(lstm_output2)
output_layer = Dense(y.shape[1]，激活=&#39;sigmoid&#39;)(lstm_output2)
model = Model(输入=input_layer，输出=output_layer)
model.compile(优化器=&#39;adam&#39;，损失=&#39;binary_crossentropy&#39;，指标=[&#39;accuracy&#39;])

X_train，X_test，y_train，y_test = train_test_split(X，y，test_size=0.2，random_state=42)

early_stop = EarlyStopping(monitor=&#39;val_loss&#39;, waiting=5, restore_best_weights=True,mode=&#39;auto&#39;)
lr_scheduler = Red**strong text**uceLROnPlateau(monitor=&#39;val_loss&#39;, factor=0.5, waiting=3, verbose=1)

history =model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=50, batch_size=32, callbacks=[early_stop, lr_scheduler])
]]></description>
      <guid>https://stackoverflow.com/questions/79292370/what-is-the-possible-enhancement-for-this-mode</guid>
      <pubDate>Wed, 18 Dec 2024 20:11:43 GMT</pubDate>
    </item>
    <item>
      <title>使用 ssd 和 mobilenetv2 进行对象检测时“目标”和“输出形状”不匹配</title>
      <link>https://stackoverflow.com/questions/79292180/mismatch-target-and-output-shape-on-object-detection-using-ssd-and-mobilenet</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79292180/mismatch-target-and-output-shape-on-object-detection-using-ssd-and-mobilenet</guid>
      <pubDate>Wed, 18 Dec 2024 18:50:54 GMT</pubDate>
    </item>
    <item>
      <title>“使用 YOLO 和 EasyOCR 进行车牌识别时遇到的文本识别问题”</title>
      <link>https://stackoverflow.com/questions/79291987/text-recognition-issues-in-license-plate-recognition-using-yolo-and-easyocr</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79291987/text-recognition-issues-in-license-plate-recognition-using-yolo-and-easyocr</guid>
      <pubDate>Wed, 18 Dec 2024 17:26:40 GMT</pubDate>
    </item>
    <item>
      <title>为什么我的 OLS 和梯度下降结果对于线性回归有显著差异？[关闭]</title>
      <link>https://stackoverflow.com/questions/79291892/why-do-my-ols-and-gradient-descent-results-differ-significantly-for-linear-regre</link>
      <description><![CDATA[我正在写一篇论文，比较普通最小二乘法 (OLS) 与传统梯度下降法 (CGD) 在线性回归中的性能。虽然我使用 SciPy 的 OLS 实现符合预期结果（例如，statsmodels），但我的 CGD 实现产生了截然不同的参数估计，即使在标准化数据、使用低学习率并运行许多个时期之后也是如此。
以下是我所做的：
A. 使用 SciPy 的 OLS：
我使用闭式正则方程和伪逆计算系数。我使用的正态方程与往常一样：

结果与 statsmodels 相符：
beta_encoding_scipy = pinv(X_with_intercept.T @ X_with_intercept) @ X_with_intercept.T @ y

OLS 结果：

截距 -22.507045
学习时间 2.852729
之前的分数 1.018319
睡眠时间 0.480321
练习的样题 0.193910
课外活动_否-11.561869
课外活动_是 -10.945176
dtype: float64

B.梯度下降实现：
我标准化了训练数据并使用以下设置实现了梯度下降：


学习率：0.001
迭代次数：5000
初始值：所有系数均设置为 0

我的实现：
def gradient_descent(features, label, learning_rate, epochs, precision):
# 初始化
X_augmented = np.hstack((np.ones((features.shape[0], 1)), features))
beta = np.zeros(X_augmented.shape[1]) # 初始化系数

for epoch in range(epochs):
predictions = X_augmented @ beta
residuals = predictions - label
gradient = (2 / len(label)) * X_augmented.T @ residuals
beta = beta - learning_rate * gradient
return beta

CGD 结果:

截距 55.142748
学习时长 7.392875
之前的分数 17.722890
睡眠时间 0.819071
练习过的样题 0.531543
课外活动_否 -0.149439
课外活动_是 0.149439
dtype: float64

观察到的差异：
CGD 的结果与 OLS 的结果相差甚远，我不确定原因。我怀疑这可能是由于数据分割过程（应用 StandardScaler 进行训练/测试分割）造成的。
问题：

如果经过适当训练，CGD 不应该产生与 OLS 类似的结果吗？
训练测试分割或缩放过程是否会影响 CGD 性能？
我的 CGD 实现或参数初始化有什么问题吗？
]]></description>
      <guid>https://stackoverflow.com/questions/79291892/why-do-my-ols-and-gradient-descent-results-differ-significantly-for-linear-regre</guid>
      <pubDate>Wed, 18 Dec 2024 16:52:02 GMT</pubDate>
    </item>
    <item>
      <title>我如何识别该图像上的物体？</title>
      <link>https://stackoverflow.com/questions/79291781/how-can-i-recognize-objects-on-this-image</link>
      <description><![CDATA[我有这样的图片：
示例
但所有图片都调整为 120x80。
我需要识别图片上的内容，数字（从 1 到 9）还是字母（完整英文字母）。
但是我的模型：
(block1): CNNBlock(
(conv): Conv2d(1, 32, kernel_size=(5, 5), stride=(1, 1), padding=same)
(act): ReLU()
(maxpool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
(block2): CNNBlock(
(conv): Conv2d(32, 64, kernel_size=(5, 5), stride=(1, 1), padding=same)
(act): ReLU()
(maxpool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
(block3): CNNBlock(
(conv): Conv2d(64, 128, kernel_size=(5, 5), stride=(1, 1), padding=same)
(act): ReLU()
(maxpool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
(block4): CNNBlock(
(conv): Conv2d(128, 256, kernel_size=(5, 5), stride=(1, 1), padding=same)
(act): ReLU()
(maxpool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
(conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1))
(act1): ReLU()
(conv2): Conv2d(512, 1024，kernel_size=(3, 3)，stride=(1, 1))
(act2): ReLU()
(globalmaxpool): AdaptiveMaxPool2d(output_size=1)
(linear1): 线性(in_features=1024，out_features=512，bias=True)
(act3): LeakyReLU(negative_slope=0.01)
(linear2): 线性(in_features=512，out_features=256，bias=True)
(act4): LeakyReLU(negative_slope=0.01)
(linear3): 线性(in_features=256，out_features=128，bias=True)
(act5): LeakyReLU(negative_slope=0.01)
(linear4): 线性(in_features=128， out_features=64, bias=True)
(act6): LeakyReLU(negative_slope=0.01)
(linear5): Linear(in_features=64, out_features=35, bias=True)
(act7): Softmax(dim=None)
)

未学习。它只是堆叠在 ~3.6 损失（CrossEntropy 损失，35 个类）上。
然后，我尝试查看每层之后的图像，它们都相同。我的对象无法进入下一层。我尝试增加 Conv2d 的内核大小，减少过滤器数量，但不起作用。]]></description>
      <guid>https://stackoverflow.com/questions/79291781/how-can-i-recognize-objects-on-this-image</guid>
      <pubDate>Wed, 18 Dec 2024 16:20:26 GMT</pubDate>
    </item>
    <item>
      <title>训练期间更高的验证准确率</title>
      <link>https://stackoverflow.com/questions/79291675/greater-validation-accuracy-during-training</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79291675/greater-validation-accuracy-during-training</guid>
      <pubDate>Wed, 18 Dec 2024 15:37:11 GMT</pubDate>
    </item>
    <item>
      <title>Yolov5 模型捕获除预期或期望对象之外的其他对象</title>
      <link>https://stackoverflow.com/questions/79291357/yolov5-model-capturing-other-objects-other-than-the-intended-or-desired-object</link>
      <description><![CDATA[我有一个用于数据集的 YOLO V5 m 模型，用于检测特定产品，但在对不同情况和场景以及各种光照条件下的产品图片数据集进行训练后，在 50 个 epoch 和 Yolo v5 中等架构以及批处理大小为 16 的情况下，情况没有重复。
我注意到，该模型依赖于颜色特征，这意味着检测到的对象具有黄色及其阴影。我使用了 yolo github 克隆附带的 train.py。我应该怎么做才能解决这个问题？
用于训练的数据集（大约 450 张图片）在谷歌驱动器中。
需要检测的产品：


检测到的其他产品：
]]></description>
      <guid>https://stackoverflow.com/questions/79291357/yolov5-model-capturing-other-objects-other-than-the-intended-or-desired-object</guid>
      <pubDate>Wed, 18 Dec 2024 14:01:11 GMT</pubDate>
    </item>
    <item>
      <title>随机森林分类器的修改[关闭]</title>
      <link>https://stackoverflow.com/questions/79290974/modification-of-random-forest-classifier</link>
      <description><![CDATA[我正在尝试更改随机森林分类器的功能。虽然通常每次分割都会随机选择特征，但我希望每次分割时都评估一个特定特征。我知道这会影响性能，但我想尝试一下这在非常具体的用例中是否是个好主意。因此，调整的结果应为：用于分割的特征是随机选择的（与往常一样），但始终会考虑一个特定特征（例如索引 15）（不一定使用）。据我所知，没有函数允许我指定这一点（如果有，请告诉我），所以我正在尝试更改分类器函数的源代码。
我选择使用 R 中的 randomForest 包。我创建了一个本地版本（通过从 cran 下载 .tar.gz）并更改了 c 脚本中的某些内容（特别是“findbestsplit”函数中的以下部分：
for (i = 0, i &lt; mtry; ++i) {
/* 样本 mtry 变量 w/o 替换。 */
j = (int) (unif_rand() * (last + 1));
mvar = mIndex[j];
swapInt(mIndex[j], mIndex[last]);
la​​st--;

if (i == mtry - 1) { /* 在最后一次迭代中更改某些内容 */
mvar = additionalVarIndex; 
/* 专门设置mvars 最后一个值到所需特征 */
}

此处 additionalVarIndex 是我通过 C 脚本中的函数传递给 findbestsplit 函数（似乎有效）的索引。我对 C 的了解非常有限，所以我认为这还不够，但我也无法测试它，因为我的更改似乎不会影响 R 应用程序。当我加载调整后的包（通过以下方式将其转回 .tar.gz）时
&amp; &quot;C:\Program Files\R\R-4.4.1\bin\x64\R.exe&quot; CMD build .

通过
install.packages(&quot;C:/Users/niklas.jacobs/AppData/Local/R/win- 
library/randomForest/randomForest_4.7-1.2.tar.gz&quot;, repos = NULL, type = &quot;source&quot;)

randomForest R 函数的行为没有发生任何变化（即使我删除了 C 代码的随机部分，我这样做只是为了了解我是否可以更改内容）。我仍然确信我的更改会产生一些影响，因为如果我删除大部分 C 代码，该函数将停止工作。我目前的我怀疑 C 脚本的 Fortran 调用以某种方式绕过了我的更改（据我所知，使用“findbestsplit”的“buildtree”函数不是在 C 脚本中定义的，而是在 Fortran 中定义的），但我不知道如何访问 Fortran。
有人对我接下来的行动有什么建议吗，或者您有更好的想法来实现我的目标吗？]]></description>
      <guid>https://stackoverflow.com/questions/79290974/modification-of-random-forest-classifier</guid>
      <pubDate>Wed, 18 Dec 2024 11:48:27 GMT</pubDate>
    </item>
    <item>
      <title>‘super’ 对象没有属性‘__sklearn_tags__’</title>
      <link>https://stackoverflow.com/questions/79290968/super-object-has-no-attribute-sklearn-tags</link>
      <description><![CDATA[我在使用 Scikit-learn 中的 RandomizedSearchCV 拟合 XGBRegressor 时遇到了 AttributeError。错误消息指出：
&#39;super&#39; 对象没有属性 &#39;\_\_sklearn_tags__&#39;。

当我在 RandomizedSearchCV 对象上调用 fit 方法时会发生这种情况。我怀疑它可能与 Scikit-learn 和 XGBoost 或 Python 版本之间的兼容性问题有关。我使用的是 Python 3.12，并且 Scikit-learn 和 XGBoost 都安装了最新版本。
我尝试使用 Scikit-learn 中的 RandomizedSearchCV 调整 XGBRegressor 的超参数。我希望模型能够毫无问题地拟合训练数据，并在交叉验证后提供最佳参数。
我还检查了兼容性问题，确保库是最新的，并重新安装了 Scikit-learn 和 XGBoost，但错误仍然存​​在。]]></description>
      <guid>https://stackoverflow.com/questions/79290968/super-object-has-no-attribute-sklearn-tags</guid>
      <pubDate>Wed, 18 Dec 2024 11:45:52 GMT</pubDate>
    </item>
    <item>
      <title>ADTK 模型消耗大量 CPU</title>
      <link>https://stackoverflow.com/questions/79290008/adtk-model-consuming-high-cpu</link>
      <description><![CDATA[我们从去年开始在 Python 应用程序中使用 ADTK 模型来检测异常。
自上周以来，我们观察到 CPU 利用率大幅上升，原因已确定为 Python 进程。
经过故障排除，我们发现 ADTK 模型是导致该问题的原因。我们正在使用其他 ML 模型，如 IForest、ECOD、CBLOF 等。但只有 ADTK 负责此峰值。
请查找当前模型代码以供参考：
data=df.copy() 
minutes = 300

df[&#39;predict_dt&#39;]=pd.to_datetime(df[&#39;predict_dt&#39;])
df = df.set_index([&#39;predict_dt&#39;]).sort_index() 

seasonal_vol = SeasonalAD(c=1.6,side=&#39;negative&#39;,trend=True) 
seasonal_vol.fit(df[&#39;predict_count&#39;])
df[&#39;anomalies&#39;]=seasonal_vol.predict(df[&#39;predict_count&#39;]) 

df2 = pd.DataFrame(columns=[&#39;predict_dt&#39;, &#39;hour&#39;, &#39;min&#39;,&#39;predict_count&#39;,&#39;label&#39;]) 
final = datetime.datetime.now(pytz.timezone(&#39;America/Los_Angeles&#39;)).replace(tzinfo=None)-timedelta(minutes=minutes)

for i in range(len(df)): 
if(data[&#39;predict_dt&#39;][i] &gt;= final):
if str(df[&#39;anomalies&#39;][i]).lower() == &quot;true&quot;:
#调用 SP 进行进一步操作

我们不确定哪个部分导致了问题。]]></description>
      <guid>https://stackoverflow.com/questions/79290008/adtk-model-consuming-high-cpu</guid>
      <pubDate>Wed, 18 Dec 2024 04:50:01 GMT</pubDate>
    </item>
    <item>
      <title>如何在 LM 中使用标记化？</title>
      <link>https://stackoverflow.com/questions/79289981/how-to-use-tokenization-in-lm</link>
      <description><![CDATA[我一直在训练这个 LM，使用以下超参数：
blocksiz = 128
batchsiz = 32
nemb = 256
nhead = 4
nlayers = 4
evalIters = 100
lr = 3e-4
epochs = 30

我的数据集是 93kb..，
我使用 GPT-2 作为 Tokenizer..
但是，当我使用 GPT-2 Tokenizer 时，训练时间太长了，
但是当我将模型训练为二元组时。它不需要那么多时间。
因此，使用具有 50257 个 Vocabsiz 的 GPT2 作为 tokenizer，会影响模型训练吗？
是否需要更多 GPU 资源来训练？
因此对于小型数据集。我应该使用什么作为标记器...？
我减少了超参数，上面我使用的参数是减少的结果
但模型训练时间太长了]]></description>
      <guid>https://stackoverflow.com/questions/79289981/how-to-use-tokenization-in-lm</guid>
      <pubDate>Wed, 18 Dec 2024 04:30:58 GMT</pubDate>
    </item>
    <item>
      <title>深度学习 Nan 损失的原因</title>
      <link>https://stackoverflow.com/questions/40050397/deep-learning-nan-loss-reasons</link>
      <description><![CDATA[什么会导致卷积神经网络发散？
具体信息：
我正在使用 Tensorflow 的 iris_training 模型和一些我自己的数据，但一直出现

错误：tensorflow：模型发散，损失 = NaN。
回溯...
tensorflow.contrib.learn.python.learn.monitors.NanLossDuringTrainingError：训练期间出现 NaN 损失。

回溯源自以下行：
 tf.contrib.learn.DNNClassifier(feature_columns=feature_columns,
hidden_​​units=[300, 300, 300],
#optimizer=tf.train.ProximalAdagradOptimizer(learning_rate=0.001, l1_regularization_strength=0.00001), 
n_classes=11,
model_dir=&quot;/tmp/iris_model&quot;)

我尝试调整优化器，使用零作为学习率，并且不使用优化器。]]></description>
      <guid>https://stackoverflow.com/questions/40050397/deep-learning-nan-loss-reasons</guid>
      <pubDate>Fri, 14 Oct 2016 19:07:18 GMT</pubDate>
    </item>
    </channel>
</rss>