<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - Thinbug</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 个</description>
    <lastBuildDate>Wed, 06 Mar 2024 12:25:00 GMT</lastBuildDate>
    <item>
      <title>为 CSV 和 Excel 数据库生成列名称</title>
      <link>https://stackoverflow.com/questions/78114334/generate-column-names-for-csvs-and-excel-databases</link>
      <description><![CDATA[所以我有一堆没有列名的 CSV 和 Excel 数据库。有没有办法用python根据列值自动生成名称？
谢谢]]></description>
      <guid>https://stackoverflow.com/questions/78114334/generate-column-names-for-csvs-and-excel-databases</guid>
      <pubDate>Wed, 06 Mar 2024 12:20:25 GMT</pubDate>
    </item>
    <item>
      <title>为每月数据编写时间滞后，以合并训练测试分割模型的情绪和市场分析</title>
      <link>https://stackoverflow.com/questions/78113308/coding-a-time-lag-for-monthly-data-to-merge-a-sentiment-and-market-analysis-for</link>
      <description><![CDATA[我们的教授为我们提供了以下代码：
代码1：
sentiment=pd.read_csv(&#39;/content/drive/MyDrive/Colab Notebooks/Python Code/Sentiment_quarterly.csv&#39;).drop(&#39;未命名：0&#39;,axis=1)
情绪
从日期时间导入日期时间
数据[&#39;数据&#39;]=0

代码2：
for k in tqdm(range(len(data[&#39;Datum&#39;])))：
    test_date=str(int(data.loc[k,&#39;bewertungsjahr&#39;]))+&#39;.&#39;+str(int(data.loc[k,&#39;bewertungsquartal&#39;]*3))
    data.loc[k,&#39;Datum&#39;]=str(pd.Timestamp(datetime.strptime(test_date, &#39;%Y.%m&#39;).date()).to_period(&#39;Q&#39;))

数据[&#39;数据&#39;][0]

代码3：
for k in tqdm(range(len(sentiment[&#39;Time&#39;]))):
    test_date=str(int(sentiment.loc[k,&#39;时间&#39;][0:4]))+&#39;.&#39;+str(int(sentiment.loc[k,&#39;时间&#39;][5])*3)
    情感.loc[k,&#39;Time&#39;]=pd.Timestamp(datetime.strptime(test_date, &#39;%Y.%m&#39;).date()).to_period(&#39;Q&#39;)

情绪[&#39;时间&#39;][0]

我们不想使用季度情绪.csv，而是使用每月.csv
季度数据中的时间格式是例如2014Q1 和月度数据显示 2014-01、2014-02...
如何调整代码以使其正常工作？
我尝试添加此 &#39;.&#39;+str(int(data.loc[k,&#39;bewertungsquartal&#39;]*12)) 这样也许我也考虑了月份。]]></description>
      <guid>https://stackoverflow.com/questions/78113308/coding-a-time-lag-for-monthly-data-to-merge-a-sentiment-and-market-analysis-for</guid>
      <pubDate>Wed, 06 Mar 2024 09:47:41 GMT</pubDate>
    </item>
    <item>
      <title>获取“ValidationError：VectorstoreIndexCreator 嵌入的 1 个验证错误”</title>
      <link>https://stackoverflow.com/questions/78112934/getting-validationerror-1-validation-error-for-vectorstoreindexcreator-embeddi</link>
      <description><![CDATA[我正在尝试构建一个 pdf 聊天机器人，您可以在其中上传 pdf 并询问与 pdf 相关的问题。为此，我正在考虑基于 RAG 的应用程序。所以我想为我的输入 pdf 创建矢量嵌入，但是当我这样做时，
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
embed_model = HuggingFaceEmbedding(model_name=“BAAI/bge-small-en-v1.5”)
index_creator = VectorstoreIndexCreator(
    矢量store_cls = 卡桑德拉，
    嵌入=嵌入模型，
    text_splitter = RecursiveCharacterTextSplitter(
        块大小 = 400,
        块重叠 = 30
    ),

    矢量store_kwargs={
        &#39;会话&#39;：会话，
        &#39;键空间&#39;：键空间，
        &#39;表名&#39;：表名
    }
）

我收到验证错误。
&lt;前&gt;&lt;代码&gt;-------------------------------------------------------- -------------------------------------------
ValidationError Traceback（最近一次调用最后一次）
&lt;ipython-input-17-b83dc7fd1587&gt;在&lt;细胞系：4&gt;()
      2 keyspace = “pdf_qa_name”
      3
----&gt; 4 index_creator = VectorstoreIndexCreator(
      5 矢量store_cls = 卡桑德拉，
      6 嵌入 = embed_model,

/usr/local/lib/python3.10/dist-packages/pydantic/v1/main.py 在 __init__(__pydantic_self__, **data)
    第 339 部分
    第340章
--&gt;第341章
    第342章
    第343章

ValidationError：VectorstoreIndexCreator 出现 1 个验证错误
嵌入
  预期 Embeddings 的实例（type=type_error.任意_type；expected_centric_type=Embeddings）

有什么想法吗？
尝试了 2 个不同的模型（Jina 和 BAAI/bge）。错误不会继续。我正在使用 open ai gpt 3.5 api。]]></description>
      <guid>https://stackoverflow.com/questions/78112934/getting-validationerror-1-validation-error-for-vectorstoreindexcreator-embeddi</guid>
      <pubDate>Wed, 06 Mar 2024 08:47:33 GMT</pubDate>
    </item>
    <item>
      <title>我的反向传播无法正常工作</title>
      <link>https://stackoverflow.com/questions/78112702/my-back-propagation-isnt-working-properly</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/78112702/my-back-propagation-isnt-working-properly</guid>
      <pubDate>Wed, 06 Mar 2024 08:06:03 GMT</pubDate>
    </item>
    <item>
      <title>我的感知器算法总是给我错误的线来分离二维线性可分离数据</title>
      <link>https://stackoverflow.com/questions/78112634/my-perceptron-algorithm-keeps-giving-me-the-wrong-line-for-separating-2d-linearl</link>
      <description><![CDATA[我正在为虚拟 2D 数据实现感知器模型。以下是我生成数据的方式
&lt;前&gt;&lt;代码&gt;#numpoint
n = 15
#f(x) = w0 + ax1 + bx2
#那么如果f(x) = 0
#x2 = (-w0 - ax1)/b
截距 = 30
一个= 4
b = 2
#生成0-20之间的随机点
x1 = np.random.uniform(-20, 20, n) #返回一个np数组
x2 = np.random.uniform(-20, 20, n)
y = []
#绘制f(x)
plt.plot(x1, (-截距 - a*x1)/b, &#39;k-&#39;)
plt.ylabel(“x2”)
plt.xlabel(“x1”)

#绘制彩色点
对于范围内的 i(0, len(x1))：
    f = 截距 + a * x1[i] + b * x2[i]
    如果（f &lt;= 0）：
        plt.plot(x1[i], x2[i], &#39;ro&#39;)
        y.追加(-1)
    如果（f&gt;0）：
        plt.plot(x1[i], x2[i], &#39;bo&#39;)
        y.追加(1)
y = np.array(y)
# 添加x0作为阈值
x0 = np.ones(n)
stacked_x = np.stack((x0,x1,x2))
堆叠_x

这是数据的可视化
在此处输入图像描述
这是我的感知器模型
类 PLA():
    def __init__(self, numPredictors):
        self.w = np.random.rand(1,numPredictors+1) #(1, numPredictors+1)
        self.iter = 0
    def fitModel（自身，xData，yData）：
        而（真）：
            yhat = np.matmul(self.w, xData).squeeze() #从(1,n)到(,n)
            比较 = np.sign(yhat) == yData
            ind = [i for i in range(0,len(compare)) if Compare[i] == False] #分类错误的索引
            打印（长度（ind））
            如果 len(ind) == 0:
                休息
            对于 ind 中的 i：
                update = yData[i]* xData[:, i] #1d 数组
                self.w = self.w + np.transpose(update[:,np.newaxis]) #转置以匹配权重的形状
            self.iter += 1

当我可视化模型时
&lt;前&gt;&lt;代码&gt;pla1 = PLA(2)
pla1.fitModel(stacked_x, y)
#绘制彩色点
对于范围内的 i(0, len(x1))：
    如果（y[i]==-1）：
        plt.plot(x1[i], x2[i], &#39;ro&#39;)
    如果（y[i]==1）：
        plt.plot(x1[i], x2[i], &#39;bo&#39;)
plt.plot(x1, (-pla1.w[0][0] - pla1.w[0][1]*x1)/(pla1.w[0][1]), &#39;g-&#39;, 标签 = “解放军”）
plt.plot(x1, (-截距 - a*x1)/b, &#39;k-&#39;, label = &quot;f(x)&quot;)
plt.xlabel(“x1”)
plt.ylabel(“x2”)
plt.图例()

我从感知器算法得到的线是不正确的
在此处输入图像描述
这是使用不同数据参数和样本大小的另一次运行 (n = 30)
在此处输入图像描述
我尝试在每次迭代时打印出更新，它按照我的预期工作。我不确定是什么导致我的算法停止，即使仍然存在错误分类的点。我已经被这个问题困扰了几天了。我非常感谢任何意见。]]></description>
      <guid>https://stackoverflow.com/questions/78112634/my-perceptron-algorithm-keeps-giving-me-the-wrong-line-for-separating-2d-linearl</guid>
      <pubDate>Wed, 06 Mar 2024 07:53:35 GMT</pubDate>
    </item>
    <item>
      <title>梯度下降最小二乘代码的问题</title>
      <link>https://stackoverflow.com/questions/78112607/problem-with-gradient-descent-least-squares-code</link>
      <description><![CDATA[我正在尝试在数据集上使用梯度下降。我写的是
&lt;前&gt;&lt;代码&gt;导入numpy
将 pandas 导入为 pd
将 numpy 导入为 np
将 matplotlib.pyplot 导入为 plt

数据 = pd.read_csv(&#39;C:/Users/Teacher/Downloads/data.csv&#39;)
X = data.iloc[:, 0] # 选择 data 中第一列的所有数据
Y = data.iloc[:, 1]
plt.scatter(X,Y)
plt.show()
n = 长度 (X)

a = 0
b = 0
L = .001

对于范围（1000）内的 i：
    y_预测 = a * X + b
    pd_a = (1 / n) * sum((y_预测 - Y) * X)
    pd_b = (1 / n) * sum(y_预测 - Y)
    a = a - L * pd_a
    b = b - L * pd_b
打印（a，b）
plt.scatter(X, Y)
c, d = numpy.polyfit(X, Y, 1)
打印（c，d）
plt.plot([min(X), max(X)], [a * x + b for x in [min(X), max(X)]], [c * x + d for x in [min( X), 最大值(X)]])
plt.show()

如果我定义 X 和 Y = np.random.rand(20)，那么一切似乎都工作正常，所以我相信问题就在那里。然而，X 和 Y 的散点图仍然很好，即使我将它们定义为数据集的第一列和第二列，所以我不确定发生了什么。]]></description>
      <guid>https://stackoverflow.com/questions/78112607/problem-with-gradient-descent-least-squares-code</guid>
      <pubDate>Wed, 06 Mar 2024 07:48:04 GMT</pubDate>
    </item>
    <item>
      <title>在 randomForestClassifier 上使用 GridsearchCV 时遇到的问题</title>
      <link>https://stackoverflow.com/questions/78112023/problem-faced-while-using-gridsearchcv-on-randomforestclassifier</link>
      <description><![CDATA[我正在使用 RandomForestClassifier 处理与心脏病相关的分类问题。在对 RandomForestClassifier 执行超参数调整时，我面临以下问题。我使用 sklearn Pipeline 和 ColumnTransformer 进行预处理。
错误：总共 2160 次拟合中有 720 次失败。
这些参数的训练测试分区的分数将设置为 nan。
如果这些失败不是预期的，您可以尝试通过设置 error_score=&#39;raise&#39; 来调试它们。
用户警告：一项或多项测试分数是非有限的

numerical_pipeline = 管道(
步骤=[(&#39;缩放器&#39;,StandardScaler())]
）

分类管道=管道（
步骤=[(&#39;编码器&#39;,OneHotEncoder(handle_unknown=&#39;忽略&#39;))]
）

预处理器 = ColumnTransformer(
[(&#39;numerical_pipeline&#39;,numerical_pipeline,numerical_features),
 (&#39;categorical_pipeline&#39;,categorical_pipeline,categorical_features)]`

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3)`

scaled_X_train = 预处理器.fit_transform(X_train)
scaled_X_test = 预处理器.transform(X_test)`

param_grid={&#39;max_depth&#39;:[3,5,10,无],
          &#39;n_estimators&#39;:[10,100,200],
          &#39;最大特征&#39;:[1,3,5,7],
          &#39;min_samples_leaf&#39;:[1,2,3],
          &#39;min_samples_split&#39;:[1,2,3]
       }

grid = GridSearchCV(RandomForestClassifier(),param_grid=param_grid,cv=5,scoring=&#39;准确性&#39;,verbose=True,n_jobs=-1)
grid.fit(scaled_X_train,y_train)
]]></description>
      <guid>https://stackoverflow.com/questions/78112023/problem-faced-while-using-gridsearchcv-on-randomforestclassifier</guid>
      <pubDate>Wed, 06 Mar 2024 05:36:25 GMT</pubDate>
    </item>
    <item>
      <title>使用反应本机剂量进行实时物体检测未检测到物体[关闭]</title>
      <link>https://stackoverflow.com/questions/78110978/real-time-object-detection-with-react-native-dose-not-detect-objects</link>
      <description><![CDATA[这是使用 Tensorflow 依赖项、cocossd 库和 React Native Canvas 库进行 React Native 的实时对象检测程序。
此代码没有错误，但程序未检测到任何对象。
节点版本为20
我通过 expo go 运行它
这是代码。
从“@tensorflow-models/coco-ssd”导入*作为cocoSsd；
从“@tensorflow/tfjs”导入* as tf；
从“@tensorflow/tfjs-react-native”导入{cameraWithTensors}；
从“expo-camera”导入{Camera}；
从“react”导入 React, { useEffect, useRef, useState };
从“react-native”导入 { Dimensions、LogBox、Platform、StyleSheet、View }；
从“react-native-canvas”导入画布；
从“expo-location”导入*作为位置；

const TensorCamera =cameraWithTensors(相机);

LogBox.ignoreAllLogs(true);

const { 宽度, 高度 } = Dimensions.get(“窗口”);

导出默认函数 App() {
  const [model, setModel] = useState();
  让 context = useRef();
  const canvas = useRef();

  函数handleCameraStream（图像：任意）{
    const 循环 = async () =&gt; {
      const nextImageTensor = images.next().value;

      if (!model || !nextImageTensor) throw new Error(“无模型”);

      模型
        .检测(nextImageTensor)
        .then((预测) =&gt; {
          drawRectangle(预测, nextImageTensor);
        })
        .catch((错误) =&gt; {
          控制台.log(错误);
        });

      请求动画帧（循环）；
    };
    环形（）;
  }

  函数绘制矩形（
    预测：cocoSsd.DetectedObject[]，
    nextImageTensor：任意
  ）{
    if (!context.current || !canvas.current) {
      console.log(“没有上下文或画布”);
      返回;
    }

    console.log(预测);

    // 匹配相机预览的大小
    const scaleWidth = 宽度 / nextImageTensor.shape[1];
    const scaleHeight = 高度 / nextImageTensor.shape[0];

    const FlipHorizo​​ntal = Platform.OS ===“ios”； ？假：真；

    // 我们将清除之前的预测
    context.current.clearRect(0, 0, 宽度, 高度);

    // 为每个预测绘制矩形
    for (预测的常量预测) {
      const [x, y, 宽度, 高度] = Prediction.bbox;

      // 根据计算出的比率缩放坐标
      constboundingBoxX = 水平翻转
        ？ canvas.current.width - x *scaleWidth - 宽度*scaleWidth
        : x * 缩放宽度;
      constboundingBoxY=y*scaleHeight；

      // 绘制边界框。
      上下文.当前.中风矩形（
        边界框X，
        边界框Y，
        宽度 * 比例宽度，
        高度 * 比例高度
      ）；
      // 绘制标签
      上下文.当前.fillText(
        预测.类，
        边界框X - 5,
        边界框Y - 5
      ）；
    }
  }

  const handleCanvas = async (can: Canvas) =​​&gt;; {
    如果能） {
      can.width = 宽度；
      can.height = 高度；
      const ctx: CanvasRenderingContext2D = can.getContext(“2d”);
      上下文.当前 = ctx;
      ctx.strikeStyle = &quot;红色&quot;;
      ctx.fillStyle = “红色”;
      ctx.lineWidth = 3;
      canvas.current = 可以;
    }
  };

  让纹理尺寸；
  Platform.OS ===“ios”；
    ？ (textureDims = { 高度: 1920, 宽度: 1080 })
    : (textureDims = { 高度: 1200, 宽度: 1600 });

  useEffect(() =&gt; {
    (异步() =&gt; {
      const { status } =等待Camera.requestCameraPermissionsAsync();
      等待 tf.ready();
      setModel(等待 cocoSsd.load());
    })();
  }, []);

  返回 （
    &lt;查看样式={styles.container}&gt;
      &lt;张量相机
        // 标准相机道具
        风格={风格.相机}
        类型={Camera.Constants.Type.back}
        // 张量相关的 props
        cameraTextureHeight={textureDims.height}
        cameraTextureWidth={textureDims.width}
        调整高度={200}
        调整宽度={152}
        调整深度={3}
        onReady={handleCameraStream}
        自动渲染={true}
        useCustomShadersToResize={false}
      &gt;&gt;

      &gt;
    &lt;/查看&gt;
  ）；
}

const 样式 = StyleSheet.create({
  容器： {
    弹性：1，
    背景颜色：“#fff”，
  },
  相机： {
    宽度：“100%”，
    高度：“100%”，
  },
  帆布： {
    位置：“绝对”，
    z索引：1000000，
    宽度：“100%”，
    高度：“100%”，
  },
});

我需要程序检测对象]]></description>
      <guid>https://stackoverflow.com/questions/78110978/real-time-object-detection-with-react-native-dose-not-detect-objects</guid>
      <pubDate>Tue, 05 Mar 2024 22:54:43 GMT</pubDate>
    </item>
    <item>
      <title>在 Keras 中创建一个自定义激活函数，需要将张量 x 提升到小数点</title>
      <link>https://stackoverflow.com/questions/78110583/create-a-custom-activation-function-in-keras-that-requires-elevating-tensor-x-to</link>
      <description><![CDATA[我正在尝试在 Keras 中实现自定义激活函数，修改 sigmoid 函数如下：

该函数将 X 进行“a”次幂（必须是小数点，例如 0.3）在密集层中，使用 keras 后端解决回归问题。出现的问题是，当我应用服装函数时，它仅在值为整数时生成结果，当值为小数时，回归会生成 NaN。我实现这个方程的方法如下：
将 numpy 导入为 np
将 pandas 导入为 pd
从 keras.models 导入顺序
从 keras.layers 导入密集
将 matplotlib.pyplot 导入为 plt
从 scikeras.wrappers 导入 KerasRegressor
从 sklearn.model_selection 导入 KFold
从 sklearn.model_selection 导入 cross_val_score
从 sklearn.preprocessing 导入 MinMaxScaler
将张量流导入为 tf
从 keras 导入后端为 K

def 自定义激活(x):
    return (1 / (1 + K.exp((-x)**0.5)))) #在此示例中 a=0.5 和 b=1

dataframe = pd.read_csv(“housing.csv”, delim_whitespace=True, header=None)
数据集 = dataframe.values

X = 数据集[:, :13]
Y = 数据集[:, 13]

缩放器 = MinMaxScaler(feature_range=(0.1, 0.9))

X_归一化 = 缩放器.fit_transform(X)
y_normalized = scaler.fit_transform(Y.reshape(-1, 1))

模型=顺序（）
model.add(密集(100,input_shape=(13,),激活=custom_activation))
model.add（密集（1，激活=&#39;线性&#39;））
model.compile(loss=&#39;mean_squared_error&#39;, 优化器=&#39;adam&#39;)

a = model.fit(X_normalized, y_normalized,epochs=100, batch_size=102, verbose=0)
y_hat = model.predict(X_normalized)

文本
我尝试通过进行多次测试来解决这个细节，检查 Keras 是否可以将 X 提高到小数。考虑到要提高的值是 1/2（平方根），我复制了这个案例，我还实现了函数 relu 和 squared，向我展示了它们给出的结果：
def custom_activation(x):
   return (1 / (1 + K.exp((*K.sqrt(-x))))) #b=1

def custom_activation(x)
   return (1 / (1 + K.exp((*K.relu(-x))**0.2))) #b=1

不幸的是，我没有在 keras 后端找到类似于 relu 的东西，但用于线性输出。我观察到的另一个问题是方程 y&#39;=(-x)^(a-1)by(1-y) 的导数，其中元素 (-x)^(a-1 ）在我看来这可能会导致冲突，但是我也不知道如何制作自定义衍生产品。]]></description>
      <guid>https://stackoverflow.com/questions/78110583/create-a-custom-activation-function-in-keras-that-requires-elevating-tensor-x-to</guid>
      <pubDate>Tue, 05 Mar 2024 21:13:35 GMT</pubDate>
    </item>
    <item>
      <title>自动编码器模型错误？</title>
      <link>https://stackoverflow.com/questions/78110545/wrong-autoencoder-model</link>
      <description><![CDATA[我正在尝试使用张量流创建一个用于异常检测的自动编码器，该模型可以运行，但仅此而已。
这是模型：
int_vectorizer=layers.TextVectorization(
    最大令牌=10000,
    输出模式=&#39;int&#39;,
    输出序列长度=140
）
int_vectorizer.adapt(adapt_data)

模型 = tf.keras.Sequential([
    int_向量化器，
    层.密集（256，激活=“relu”），
    层.密集（128，激活=“relu”），
    层.密集（64，激活=“relu”），
    层.密集（32，激活=“relu”），
    层.密集（64，激活=“relu”），
    层.密集（128，激活=“sigmoid”），`
]）

label_converter=layers.StringLookup(output_mode=“int”)
label_converter.adapt(数据)

model.compile(optimizer=&#39;adam&#39;, loss=“mae”)
model.fit(数据, label_converter(数据), epochs=200)

测试时，我得到以下 2 个输入的相同百分比水平：

我尝试更改层、节点数量、单元数量和不同的激活。]]></description>
      <guid>https://stackoverflow.com/questions/78110545/wrong-autoencoder-model</guid>
      <pubDate>Tue, 05 Mar 2024 21:05:27 GMT</pubDate>
    </item>
    <item>
      <title>无监督自动编码器产生特定的输出维度</title>
      <link>https://stackoverflow.com/questions/78107646/unsupervised-autoencoder-produce-specific-output-dimensions</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/78107646/unsupervised-autoencoder-produce-specific-output-dimensions</guid>
      <pubDate>Tue, 05 Mar 2024 12:12:37 GMT</pubDate>
    </item>
    <item>
      <title>更改 onnx 模型中的输入和输出形状</title>
      <link>https://stackoverflow.com/questions/75867115/change-input-and-output-shapes-in-onnx-model</link>
      <description><![CDATA[我对机器学习很陌生，所以我提前为这个问题表示歉意。
我有一个预先训练的 onnx 模型，具有定义的输入和输出形状。
是否可以更改这些值？
我研究了可能的解决方案，尝试使用例如onnxruntime.tools.make_dynamic_shape_fixed，但由于模型已经具有固定的形状，因此失败。
我还在考虑将模型转换为张量流格式，并尝试从那里修改形状，但我没有取得多大进展。
任何帮助将不胜感激！]]></description>
      <guid>https://stackoverflow.com/questions/75867115/change-input-and-output-shapes-in-onnx-model</guid>
      <pubDate>Tue, 28 Mar 2023 13:46:08 GMT</pubDate>
    </item>
    <item>
      <title>ValueError：X 有 1 个特征，但 LinearRegression 期望有 2 个特征作为输入</title>
      <link>https://stackoverflow.com/questions/73132252/valueerror-x-has-1-features-but-linearregression-is-expecting-2-features-as-in</link>
      <description><![CDATA[我正在使用 pywebio 为我的机器学习程序创建一个小型脚本运行用户界面。当不使用小型 UI 时，运行线性回归 predict() 函数时不会出现任何错误。
UI 正在从用户处检索两个数字：&#39;age&#39; 和 &#39;salary&#39;。这两个数字被输入到一个 numpy 数组中，并且当我收到有关 numpy 数组形状的错误时，该 numpy 数组已从一维数组重新调整为二维数组。
现在，当 sklearn 文档指出线性回归 predict() 时，我收到一条有关 predict() 方法仅接收 1 个特征而不是 2 个特征的错误消息&gt; 方法总是获取“self”和另一个特征。我该如何修复这个错误？
这是我的用户界面代码：
age = int(input(“请输入您的年龄：”, type=NUMBER))
工资 = int(input(&quot;请输入您的工资：&quot;, type=NUMBER))

条目 = np.array([年龄, 薪水])
reshape_entry = Entry.reshape(-1, 1)

估计 = regr.predict(reshape_entry)

这是错误消息：
ValueError Traceback（最近一次调用最后一次）
输入 In [21], in ()

输入[21]，在retirement_ui()中

文件 ~\anaconda3\lib\site-packages\sklearn\linear_model\_base.py:362，在 LinearModel.predict(self, X) 中
    348 def 预测（自身，X）：
    第349章
    350 使用线性模型进行预测。
    第351章
   （...）
    360 返回预测值。
    第361章
--&gt;第362章

文件〜\ anaconda3 \ lib \ site-packages \ sklearn \ Linear_model \ _base.py：345，在LinearModel._decision_function（self，X）中
    第342章
    第343章
--&gt; [第 345 章]
    [第 346 章]

文件 ~\anaconda3\lib\site-packages\sklearn\base.py:585，在 BaseEstimator._validate_data(self, X, y, Reset, validate_separately, **check_params)
    第582章
    第584章
--&gt;第585章
    第587章 回来

文件 ~\anaconda3\lib\site-packages\sklearn\base.py:400，在 BaseEstimator._check_n_features(self, X, Reset) 中
    第397章 回归
    第399章
--&gt;第400章
    [第 401 章]
    [402] f“期待{self.n_features_in_}特征作为输入。”
    第403章）

ValueError：X 有 1 个特征，但 LinearRegression 期望有 2 个特征作为输入。
]]></description>
      <guid>https://stackoverflow.com/questions/73132252/valueerror-x-has-1-features-but-linearregression-is-expecting-2-features-as-in</guid>
      <pubDate>Wed, 27 Jul 2022 04:29:07 GMT</pubDate>
    </item>
    <item>
      <title>Pytorch DataLoader内存未释放</title>
      <link>https://stackoverflow.com/questions/52015010/pytorch-dataloader-memory-is-not-released</link>
      <description><![CDATA[我想在google collaboratory上的pythorch上实现SRGAN，但是DataLoader的内存似乎被释放了，所以如果你转动epoch，就会出现内存错误。
如果您告诉我如何执行此操作以释放每批内存，我将不胜感激。
这是代码的 GitHub 链接
已经 48 了，1 个 echoch 发生内存错误。如果将批量大小设置为 8 的 1/6，则大约在第 6 个 epoch 时会出现错误。
我正在使用以下代码读取高分辨率和低分辨率图像。扩展图像文件夹。但是例如，即使执行学习时出现错误，GPU的内存也不会被释放
类 DownSizePairImageFolder(ImageFolder):
    def __init__(自身，根，变换=无，large_size=256，small_size=64，**kwds)：
        super().__init__(根，变换=变换，**kwds)
        self.large_resizer = 变换.Scale(large_size)
        self.small_resizer = 变换.Scale(small_size)
    
    def __getitem__(自身，索引)：
        路径, _ = self.imgs[索引]
        img = self.loader(路径)
        Large_img = self.large_resizer(img)
        Small_img = self.small_resizer(img)
        如果 self.transform 不是 None：
            Large_img = self.transform(large_img)
            小img = self.transform(small_img)
        返回小img、大img


train_data = DownSizePairImageFolder(&#39;./lfw-deepfunneled/train&#39;,transform=transforms.ToTensor())
test_data = DownSizePairImageFolder(&#39;./lfw-deepfunneled/test&#39;,transform=transforms.ToTensor())
批量大小 = 8
train_loader = DataLoader(train_data,batch_size,shuffle=True)
test_loader = DataLoader(test_data,batch_size,shuffle=False)
]]></description>
      <guid>https://stackoverflow.com/questions/52015010/pytorch-dataloader-memory-is-not-released</guid>
      <pubDate>Sat, 25 Aug 2018 07:25:26 GMT</pubDate>
    </item>
    <item>
      <title>Spark：用spark绘制模型的学习曲线</title>
      <link>https://stackoverflow.com/questions/51038518/spark-draw-learning-curve-of-a-model-with-spark</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/51038518/spark-draw-learning-curve-of-a-model-with-spark</guid>
      <pubDate>Tue, 26 Jun 2018 08:41:25 GMT</pubDate>
    </item>
    </channel>
</rss>