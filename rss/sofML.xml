<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - 堆栈内存溢出</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 条</description>
    <lastBuildDate>Wed, 11 Sep 2024 01:12:11 GMT</lastBuildDate>
    <item>
      <title>基于时间的市场模型交叉验证[关闭]</title>
      <link>https://stackoverflow.com/questions/78970532/time-based-cross-validation-on-market-model</link>
      <description><![CDATA[我正在尝试预测市场价格。我的问题是使用基于时间的 CV 而不是传统 CV 是否有意义。我在拆分数据以训练/测试/验证我的模型时是否应该考虑时间？
在我的数据中，有多个客户对产品 X 进行报价。市场价格平均随着时间的推移而上涨，但由于有多个客户，我认为过去报价的客户（因此他们的市场价值回报）与特征报价（新老客户未来返回的市场价值）之间没有依赖关系。我同意整体市场价值取决于时间，但我不确定不同的人对此有多大影响，以及我的问题是否需要基于时间的 CV。
目前我正在使用普通 CV，但我想知道基于时间的 CV 是否会更好]]></description>
      <guid>https://stackoverflow.com/questions/78970532/time-based-cross-validation-on-market-model</guid>
      <pubDate>Tue, 10 Sep 2024 16:51:25 GMT</pubDate>
    </item>
    <item>
      <title>在表格数据上训练神经网络-验证数据的损失停滞不前[关闭]</title>
      <link>https://stackoverflow.com/questions/78970305/train-a-neural-network-on-tabular-data-loss-on-validation-data-stagnates</link>
      <description><![CDATA[我正在表格数据上训练一个神经网络。我有一个训练集和一个验证集，分别有 55000 个和 20000 个样本。我已经用 200 个时期对它进行了训练。我观察到训练集上的损失（均方误差）稳步下降，而验证集上的损失下降/停滞。这不是我所期望的，因为在某个时候验证集上的损失毕竟应该增加（过度拟合），但我没有看到，它在 80 个时期后保持稳定。这让我很困惑。有人对此有什么想法吗？
尝试：训练一个神经网络
预期：在某个时候验证集上的损失增加
结果：验证集上的损失停滞不前]]></description>
      <guid>https://stackoverflow.com/questions/78970305/train-a-neural-network-on-tabular-data-loss-on-validation-data-stagnates</guid>
      <pubDate>Tue, 10 Sep 2024 15:51:09 GMT</pubDate>
    </item>
    <item>
      <title>Transformer 架构中填充批次的掩蔽和计算损失</title>
      <link>https://stackoverflow.com/questions/78970293/masking-and-computing-loss-for-a-padded-batch-in-a-transformer-architecture</link>
      <description><![CDATA[我正在尝试重新创建 Transformer 模型，并以 带注释的 Transformer 为基础。我的问题与填充有关：

带注释的 Transformer 如何处理填充序列？我可以看到他们创建了方法 Batch.make_std_mask，据说该方法（也）会屏蔽所有填充标记，但这仅适用于合成数据。
在基于 Transformer 的架构中，通常应如何处理填充序列？我可以看到提及（再次，在带注释的 Transformer 中，搜索“批处理对速度非常重要。”）以最小化填充，我猜这是为了找到最小化填充的序列长度？我非常确定必须将整个填充序列传入模型，否则自注意力机制就会出现问题。除了在嵌入 (pytorch) 中设置 padding_idx 之类的内容外，模型本身是否应该处理填充标记？损失计算索引目标和模型输出是否应忽略所有填充的标记？

我已经看过这个问题（在 pytorch 中通过具有线性输出层的 RNN 发送的填充批次的掩码和计算损失） - 对于基于注意力的模型，该过程是否相同，或者是否存在差异，因为注意力机制如何“看到”整个序列一次？
我也看过这个问题（Transformer 编码器中的查询填充掩码和键填充掩码），但我不确定它是否处理了同样的问题。如果是这样，我仍然希望得到澄清（并以那里的答案的形式），因为我既不完全理解这个问题，也不完全理解目前接受的（唯一）答案。]]></description>
      <guid>https://stackoverflow.com/questions/78970293/masking-and-computing-loss-for-a-padded-batch-in-a-transformer-architecture</guid>
      <pubDate>Tue, 10 Sep 2024 15:48:06 GMT</pubDate>
    </item>
    <item>
      <title>使用 Pytorch 进行人体分割会失败，但使用 Tensorflow Keras 不会失败</title>
      <link>https://stackoverflow.com/questions/78969962/human-segmentation-fails-with-pytorch-not-with-tensorflow-keras</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/78969962/human-segmentation-fails-with-pytorch-not-with-tensorflow-keras</guid>
      <pubDate>Tue, 10 Sep 2024 14:18:33 GMT</pubDate>
    </item>
    <item>
      <title>用 R 预测股票波动性</title>
      <link>https://stackoverflow.com/questions/78969928/forecasting-volatility-of-stocks-in-r</link>
      <description><![CDATA[项目概述：
我正在开展一个项目，使用 469 天内 292 只股票的每日数据来预测股票指数的波动性。我有一个包含 104 个特征的数据集，包括特定于股票的特征、滞后变量和移动平均线。此外，我计算了 6 个波动代理，并计划对每个代理进行 1 天、5 天和 10 天的预测。
目标：
我的目标是：使用经典的时间序列预测方法（例如 ARIMA、GARCH）对波动性进行建模。
应用机器学习技术（例如随机森林、梯度提升、RNN）来提高预测准确性。
具体挑战：
鉴于我的数据结构（每日股票数据、波动代理和各种特征），我不确定如何最好地进行传统时间序列模型和机器学习模型的特征选择和预处理。
我正在寻找有关模型选择的指导、在多变量环境中处理时间序列数据的最佳实践以及任何可以帮助我获得的相关文献开始。
问题：

使用时间序列模型和机器学习技术预测波动性的最佳起点是什么？

是否有任何推荐的资源或论文解释如何使用这样的数据集进行波动性预测？

我应该如何处理多元时间序列预测的特征工程和模型验证？


我正在开展一个预测股票指数波动性的项目，但由于缺乏使用某些技术的经验，我不知道如何开始。
以下是我想做的事情：

我有 469 天内 292 只股票的每日数据。
我的数据集包括 104 个特征，例如股票特定变量、滞后变量和移动平均线。
我已经计算了 6 个波动代理，我的目标是预测每个代理未来 1、5 和 10 天的情况。
我计划从经典的时间序列预测方法（例如 ARIMA、GARCH）开始，然后探索机器学习技术，如随机森林或 RNN。

我遇到的困难：
我不确定如何开始这个项目。具体来说，我无法理解如何构建数据、选择特征和应用适当的模型。我不知道如何进行时间序列和机器学习方法的特征选择、模型验证和性能评估。
我希望得到一些关于从哪里开始的指导、推荐的方法以及任何可以帮助我学习最佳实践的资源或文献。]]></description>
      <guid>https://stackoverflow.com/questions/78969928/forecasting-volatility-of-stocks-in-r</guid>
      <pubDate>Tue, 10 Sep 2024 14:11:41 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 OpenCV 改进这种图像自然背景扩展方法？</title>
      <link>https://stackoverflow.com/questions/78969286/how-can-i-improve-this-approach-for-natural-background-extension-in-an-image-usi</link>
      <description><![CDATA[我正在使用 Python 中的 OpenCV 扩展图像的背景。我目前的方法是复制边框并对扩展区域应用高斯模糊以将它们混合到原始图像中。目标是使背景扩展看起来更自然，尤其是对于具有一致纹理的图像。
这是我当前使用的代码：
import cv2
import numpy as np

def expand_image_with_smart_blend(image_path, top=50, bottom=50, left=50, right=50):
img = cv2.imread(image_path)
original_h, original_w = img.shape[:2]

expanded_img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_REPLICATE)

blured_img = expand_img.copy()

if top &gt; 0:
blured_img[0:top, :] = cv2.GaussianBlur(expanded_img[0:top, :], (51, 51), 0)

如果底部 &gt; 0:
blured_img[original_h + top:original_h + top + bottom, :] = cv2.GaussianBlur(expanded_img[original_h + top:original_h + top + bottom, :], (51, 51), 0)

如果左侧 &gt; 0:
blured_img[:, 0:left] = cv2.GaussianBlur(expanded_img[:, 0:left], (51, 51), 0)

如果右侧 &gt; 0:
blured_img[:, original_w + left:original_w + left + right] = cv2.GaussianBlur(expanded_img[:, original_w + left:original_w + left + right], (51, 51), 0)

cv2.namedWindow(&quot;智能混合扩展图像&quot;, cv2.WINDOW_NORMAL)
cv2.namedWindow(&quot;原始图像&quot;, cv2.WINDOW_NORMAL)
cv2.imwrite(&#39;expanded_smart_blended_image.jpg&#39;, blured_img)
cv2.imshow(&#39;智能混合扩展图像&#39;, blured_img)
cv2.imshow(&quot;原始图像&quot;, img)
cv2.waitKey(0)
cv2.destroyAllWindows()

expand_image_with_smart_blend(&#39;test_img.jpg&#39;, top=100, bottom=100, left=100, right=100)

我尝试过的方法：
cv2.BORDER_REPLICATE：我使用它将原始图像的边缘复制到新扩展的区域中。
高斯模糊：应用于扩展区域以柔化原始图像和新区域之间的过渡。
问题：
结果在某种程度上是可以接受的，但过渡仍然看起来不像我想要的那样自然。特别是：
某些区域的过度模糊使背景看起来不真实。
对于纹理更复杂的图像，边缘复制并不总是有效。
原始图像 结果图像
问题：
在 OpenCV 或其他库中，是否有更复杂的方法来扩展图像的背景，从而产生更自然、无缝的结果？我愿意接受涉及高级图像处理技术或机器学习的方法。任何使用扩散模型的方法都可以。]]></description>
      <guid>https://stackoverflow.com/questions/78969286/how-can-i-improve-this-approach-for-natural-background-extension-in-an-image-usi</guid>
      <pubDate>Tue, 10 Sep 2024 11:32:09 GMT</pubDate>
    </item>
    <item>
      <title>当我尝试在自定义数据集上训练我的分割模型时，准确率停留在同一数值上，一点也没有提高</title>
      <link>https://stackoverflow.com/questions/78969275/when-im-trying-to-train-my-segmentation-model-on-a-custom-dataset-the-accuracy</link>
      <description><![CDATA[我尝试过改变学习率、损失和指标，但在自定义数据集上运行时，准确率仍然“完全”相同（0.28）。损失有所减少，但幅度很小
训练循环详情：
它有一个 ResNet50 主干，包括 softmax。使用 tensorflow.keras。
我已将数据加载代码附在下面。

def load_image(image_path):
# 读取图像文件
image = tf.io.read_file(image_path)

# 解码图像
image = tf.image.decode_image(image, channels=3, expand_animations=False)

# 调整图像大小
image = tf.image.resize(image, [224, 224])

# 标准化图像
image = image / 255.0

# tf.print(&quot;调整大小后的图像形状：&quot;, tf.shape(image))

返回图像

def load_mask(mask_path):
# 读取掩码文件
mask = tf.io.read_file(mask_path)

# 解码掩码
mask = tf.image.decode_image(mask, channels=1, expand_animations=False)

#调整掩码大小
mask = tf.image.resize(mask, [224, 224])

# 标准化掩码
mask = mask / 255.0

# tf.print(&quot;调整大小后的掩码形状：&quot;, tf.shape(mask))

return mask

def serialize_example(image, mask):
feature = {
&#39;image&#39;: tf.train.Feature(bytes_list=tf.train.BytesList(value=[tf.io.encode_jpeg(tf.cast(image * 255.0, tf.uint8)).numpy()])),
&#39;mask&#39;: tf.train.Feature(bytes_list=tf.train.BytesList(value=[tf.io.encode_jpeg(tf.cast(mask * 255.0, tf.uint8)).numpy()]))
}
example_proto = tf.train.Example(features=tf.train.Features(feature=feature))
return example_proto.SerializeToString()

def _parse_function(proto):
keys_to_features = {
&#39;image&#39;: tf.io.FixedLenFeature([], tf.string),
&#39;mask&#39;: tf.io.FixedLenFeature([], tf.string)
}
parsed_features = tf.io.parse_single_example(proto, keys_to_features)

image = tf.image.decode_jpeg(parsed_features[&#39;image&#39;], channels=3)
mask = tf.image.decode_jpeg(parsed_features[&#39;mask&#39;], channels=1)

image.set_shape([None, None, 3])
mask.set_shape([None, None, 1])

image = tf.image.resize(image, [224, 224]) / 255.0
mask = tf.image.resize(mask, [224, 224]) / 255.0

# 调试：打印图像和掩码的形状
print(f&quot;解析的图像形状：{tf.shape(image)}, 解析的掩码形状：{tf.shape(mask)}&quot;)

return image, mask

def preprocess_and_save_to_tfrecord(images_dir, mask_dir, output_file):
output_dir = os.path.dirname(output_file)
if not os.path.exists(output_dir):
os.makedirs(output_dir)

image_paths = sorted([os.path.join(images_dir, fname) for fname in os.listdir(images_dir) if fname.endswith(&#39;.jpg&#39;)])
mask_paths = sorted([os.path.join(masks_dir, fname) for fname in os.listdir(masks_dir) if fname.endswith(&#39;.jpg&#39;)])

if len(image_paths) != len(mask_paths):
raise ValueError(&quot;图像和掩码的数量不匹配。&quot;)

writer = tf.io.TFRecordWriter(output_file)
for image_path, mask_path in zip(image_paths, mask_paths):
image = load_image(image_path)
mask = load_mask(mask_path)
example = serialize_example(image, mask)
writer.write(example)
print(f&quot;将 {image_path} 和 {mask_path} 写入 TFRecord&quot;)
writer.close()

def load_tfrecord_dataset(tfrecord_file):
dataset = tf.data.TFRecordDataset(tfrecord_file)
dataset = dataset.map(_parse_function, num_parallel_calls=tf.data.AUTOTUNE)
return dataset
# 定义路径和输出文件
train_images_dir = &#39;segmentation/idd20k_final/train/images&#39;
train_masks_dir = &#39;segmentation/idd20k_final/train/mask&#39;
test_images_dir = &#39;segmentation/idd20k_final/test/images&#39;
test_masks_dir = &#39;segmentation/idd20k_final/test/mask&#39;

train_output_file = &#39;segmentation/idd20k_final/tfrecords/train.tfrecord&#39;
test_output_file = &#39;segmentation/idd20k_final/tfrecords/test.tfrecord&#39;

preprocess_and_save_to_tfrecord(train_images_dir, train_masks_dir, train_output_file)
preprocess_and_save_to_tfrecord(test_images_dir, test_masks_dir, test_output_file)

# 从 TFRecord 加载数据集
train_dataset = load_tfrecord_dataset(train_output_file)
test_dataset = load_tfrecord_dataset(test_output_file)

# 批处理和预取
batch_size = 16
train_dataset = train_dataset.batch(batch_size)
test_dataset = test_dataset.batch(batch_size)

# 这将使用标准 Python 打印形状
print(&quot;train_dataset 中的批次数：&quot;, len(list(train_dataset.as_numpy_iterator())))
print(&quot;test_dataset 中的批次数：&quot;, len(list(test_dataset.as_numpy_iterator())))
`base_learning_rate = 0.001
optimizer = tf.keras.optimizers.SGD(learning_rate=base_learning_rate, motivation=0.2, clipnorm=5.0)
model.compile(optimizer=optimizer,
loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
metrics=[&#39;accuracy&#39;])`

]]></description>
      <guid>https://stackoverflow.com/questions/78969275/when-im-trying-to-train-my-segmentation-model-on-a-custom-dataset-the-accuracy</guid>
      <pubDate>Tue, 10 Sep 2024 11:29:37 GMT</pubDate>
    </item>
    <item>
      <title>zero123 的更大分辨率输出</title>
      <link>https://stackoverflow.com/questions/78969143/bigger-resolution-output-of-zero123</link>
      <description><![CDATA[我在 instantMesh 上下文中使用 zero123，我想知道 zero123 是否有可能输出更大分辨率的图像？
目前分辨率为 320x320，对于从 InstantMesh 的 3d 重建管道获得良好的输出纹理来说，这个分​​辨率有点低。
代码使用方式如下：
import torch
import request
from PIL import Image
from diffusers import DiffusionPipeline, EulerAncestralDiscreteScheduler

# 加载管道
pipeline = DiffusionPipeline.from_pretrained(
&quot;sudo-ai/zero123plus-v1.1&quot;, custom_pipeline=&quot;sudo-ai/zero123plus-pipeline&quot;,
torch_dtype=torch.float16
)

# 随意调整调度程序！
# `timestep_spacing` 参数在旧版本的 `diffusers` 中不受支持
# 因此可能会降低性能
# 我们建议使用 `diffusers==0.20.2`
pipeline.scheduler = EulerAncestralDiscreteScheduler.from_config(
pipeline.scheduler.config, timestep_spacing=&#39;trailing&#39;
)
pipeline.to(&#39;cuda:0&#39;)

# 下载示例图像。
cond = Image.open(requests.get(&quot;https://d.skis.ltd/nrp/sample-data/lysol.png&quot;, stream=True).raw)

# 运行管道！
result = pipeline(cond, num_inference_steps=75).images[0]
# 对于一般物体的一般真实和合成图像
# 通常大约有 28 个推理步骤就足够了
# 对于具有面部等精细细节的图像（真实或动漫）
# 您可能需要 75-100 个步骤来构建细节

result.show()
result.save(&quot;output.png&quot;)
]]></description>
      <guid>https://stackoverflow.com/questions/78969143/bigger-resolution-output-of-zero123</guid>
      <pubDate>Tue, 10 Sep 2024 10:55:23 GMT</pubDate>
    </item>
    <item>
      <title>如何在HuggingFace中组织机器学习项目？</title>
      <link>https://stackoverflow.com/questions/78969051/how-to-organize-a-machine-learning-project-in-huggingface</link>
      <description><![CDATA[虽然我同意没有一种适用于每种用例的“理想”组织方案，但我正在寻找一种标准化的方式来组织 HuggingFace 环境中机器学习 (ML) 项目中编译的代码、脚本、模型和数据。
根据我的经验，机器学习项目包括：

数据：用于训练和评估模型的一个或多个数据集（理想情况下，版本受控）。
模型：ML 模型的权重（同样，版本受控）
代码：用于以下操作的脚本集合：

收集和探索数据；

预处理、聚合数据并创建数据集；和

训练、调整和评估模型。




其他项目可能有其他组件，我有兴趣了解任何其他解决方案。例如，就我而言，我有一个应用程序的源代码，该应用程序利用模型实现特定目标。此应用程序使用 GitHub 进行版本控制。
为了使我的 ML 研究最开放和可重复，我希望将数据集和模型与脚本一起发布。这样，任何人都可以以与我完全相同的方式以最自动化的方式收集数据并训练模型。我发现 HuggingFace 是存储模型和数据集的绝佳场所，尽管无法找到一种结构化的方式将数据和模型脚本包含在各自的存储库中。
目前，我一直将模型和数据集上传到 HuggingFace，但脚本与应用程序源代码一起存储在 GitHub 中。我认为这并不正确，因为脚本与 ML 管道的关系比与后来使用它们的应用程序的关系更密切。]]></description>
      <guid>https://stackoverflow.com/questions/78969051/how-to-organize-a-machine-learning-project-in-huggingface</guid>
      <pubDate>Tue, 10 Sep 2024 10:30:42 GMT</pubDate>
    </item>
    <item>
      <title>Gradcam 与预期结果不符 [关闭]</title>
      <link>https://stackoverflow.com/questions/78968918/gradcam-doesnt-match-with-expected-results</link>
      <description><![CDATA[我为胸部 X 光 (CXR) 图像创建了 GradCAM 可视化，但结果并不如我所料。通常，GradCAM 热图会突出显示整个相关模式，如狗的脸或猫的腿，如下例所示：
我在互联网上看到的任何地方都能看到那些漂亮的热图，它们包裹着应该找到的整个模式
示例：

在这里，您可以清楚地看到模型专注于狗的脸或猫腿后部的图案。这也是人类会解读为猫或狗的部分。
但是，我的 GradCAM 结果看起来不同：

在我的可视化中，倒数第二层（Conv3_1）关注边缘，最后一层（Conv3_2）显示随机点，主要在心脏或胸骨上。尽管如此，我的模型的性能指标确实很好：
我只是假设我的模型只是做出了错误的预测，但准确率约为 96%，模型没有过度拟合，指标非常好
测试准确率：0.9570
测试损失：0.1253
测试 AUC：0.9896
测试精度：0.9719
测试召回率：0.9412

有人能向我解释一下为什么我制作的 gradcam 没有覆盖整个肺部吗？或者病理部位？
它学习的模式是否如此具体，以至于在最后一层只发现一小部分区域？]]></description>
      <guid>https://stackoverflow.com/questions/78968918/gradcam-doesnt-match-with-expected-results</guid>
      <pubDate>Tue, 10 Sep 2024 09:57:16 GMT</pubDate>
    </item>
    <item>
      <title>使用 MediaPipe 和 OpenCV 优化从视频中提取坐标的时间</title>
      <link>https://stackoverflow.com/questions/78967995/optimizing-coordinates-extraction-time-from-video-using-mediapipe-and-opencv</link>
      <description><![CDATA[我在 Python 后端服务器中使用 MediaPipe 和 OpenCV 从通过 API 有效负载发送的视频中提取人体姿势坐标。但这需要相当长的时间，例如，1080p 分辨率的 30/50 fps 的 1 秒视频大约需要 2 到 4 秒，3 到 5 秒的视频需要 30 到 45 秒，15 秒的视频大约需要 2 分钟。我尝试降低帧速率，将视频分成多个部分，但坐标提取所需的总体时间并没有改善。
关于如何优化坐标提取时间有什么建议吗？此外，还有其他比 MediaPipe 更快的坐标提取替代方案吗？]]></description>
      <guid>https://stackoverflow.com/questions/78967995/optimizing-coordinates-extraction-time-from-video-using-mediapipe-and-opencv</guid>
      <pubDate>Tue, 10 Sep 2024 05:23:41 GMT</pubDate>
    </item>
    <item>
      <title>在函数中创建 VLLM 对象时会导致内存错误，即使明确清除 GPU 缓存也是如此，只有共享引用才能使代码不会崩溃</title>
      <link>https://stackoverflow.com/questions/78959131/vllm-objects-cause-memory-errors-when-created-in-a-function-even-when-explicitly</link>
      <description><![CDATA[我在 Python 中使用 VLLM 库时遇到了问题。具体来说，当我在函数内部创建 VLLM 模型对象时，我遇到了内存问题，并且无法有效清除 GPU 内存，即使在删除对象并使用 torch.cuda.empty_cache() 之后也是如此。
当我尝试在函数内部实例化 LLM 对象时会出现问题，但如果我在父进程或全局范围内实例化该对象，则不会发生这种情况。这表明 VLLM 在函数中创建和管理对象时存在问题，从而导致内存保留和 GPU 耗尽。
以下是代码的简化版本：
import torch
import gc
from vllm import LLM

def run_vllm_eval(model_name, samples_params, path_2_eval_dataset):
# 在函数中实例化 LLM
llm = LLM(model=model_name, dtype=torch.float16, trust_remote_code=True)

# 在此处运行一些 VLLM 推理或评估（简化）
result = llm.generate([path_2_eval_dataset], samples_params)

# 推理后清理
del llm
gc.collect()
torch.cuda.empty_cache()

# 在此之后，GPU 内存不会被清除正确并导致 OOM 错误
run_vllm_eval()
run_vllm_eval()
run_vllm_eval()

但是
llm = run_vllm_eval2()
llm = run_vllm_eval2(llm)
llm = run_vllm_eval2(llm)

有效。
即使明确删除 LLM 对象并清除缓存后，GPU 内存仍未正确释放，导致在尝试加载或运行同一脚本中的另一个模型时出现内存不足 (OOM) 错误。
我尝试过的方法：

使用 del 删除 LLM 对象。
运行 gc.collect() 以触发 Python 的垃圾集合。
使用 torch.cuda.empty_cache() 清除 CUDA 内存。
确保父进程中没有实例化 VLLM 对象。

当在函数内创建 LLM 对象时，这些似乎都无法解决问题。
问题：

在函数内创建 VLLM 对象时，有人遇到过类似的内存问题吗？
是否有推荐的方法来管理或清除函数中的 VLLM 对象以防止 GPU 内存保留？
在这种情况下，是否存在与标准 Hugging Face 或 PyTorch 模型不同的特定 VLLM 处理技术？
]]></description>
      <guid>https://stackoverflow.com/questions/78959131/vllm-objects-cause-memory-errors-when-created-in-a-function-even-when-explicitly</guid>
      <pubDate>Sat, 07 Sep 2024 00:58:59 GMT</pubDate>
    </item>
    <item>
      <title>Transformer 编码器中的查询填充掩码和密钥填充掩码</title>
      <link>https://stackoverflow.com/questions/65262928/query-padding-mask-and-key-padding-mask-in-transformer-encoder</link>
      <description><![CDATA[我正在使用 pytorch nn.MultiheadAttention 在 transformer 编码器中实现自注意力部分，并在 transformer 的填充掩码中进行混淆。
下图显示了查询（行）和键（列）的自注意力权重。
如您所见，有一些标记“&lt;PAD&gt;”，我已经在键中对其进行了掩码。因此 token 不会计算注意力权重。

还有两个问题：

在查询部分，除了红色方块部分，我还可以屏蔽它们（“&lt;PAD&gt;”）吗？这合理吗？

我该如何屏蔽“&lt;PAD&gt;”在查询中？


注意权重还通过在 src_mask 或 src_key_padding_mask 参数中提供掩码，沿行使用 softmax 函数。如果我将所有 &lt;PAD&gt;&gt; 行设置为 -inf，则 softmax 将返回 nan，损失将为 nan]]></description>
      <guid>https://stackoverflow.com/questions/65262928/query-padding-mask-and-key-padding-mask-in-transformer-encoder</guid>
      <pubDate>Sat, 12 Dec 2020 08:19:34 GMT</pubDate>
    </item>
    <item>
      <title>在 PyTorch 中，通过具有线性输出层的 RNN 发送填充批次的掩蔽和计算损失</title>
      <link>https://stackoverflow.com/questions/59292708/masking-and-computing-loss-for-a-padded-batch-sent-through-an-rnn-with-a-linear</link>
      <description><![CDATA[虽然这是一个典型的用例，但我找不到一个简单明了的指南来说明当通过 RNN 发送时，在 pytorch 中计算填充小批量损失的规范方法是什么。
我认为规范的管道可能是：

pytorch RNN 期望填充的批量张量形状为：(max_seq_len, batch_size, emb_size)

因此，我们给出一个嵌入层，例如这个张量：
tensor([[1, 1],
[2, 2],
[3, 9]])


9 是填充索引。批量大小为 2。嵌入层将使其形状为 (max_seq_len, batch_size, emb_size)。批次中的序列按降序排列，因此我们可以打包它。

我们应用 pack_padded_sequence，应用 RNN，最后应用 pad_packed_sequence。此时我们有 (max_seq_len、batch_size、hidden_​​size)

现在我们在结果上应用线性输出层，假设是 log_softmax。所以最后我们有一个批次分数的张量，形状为：(max_seq_len、batch_size、linear_out_size)


我应该如何从这里计算损失，掩盖填充部分（使用任意目标）？]]></description>
      <guid>https://stackoverflow.com/questions/59292708/masking-and-computing-loss-for-a-padded-batch-sent-through-an-rnn-with-a-linear</guid>
      <pubDate>Wed, 11 Dec 2019 19:25:31 GMT</pubDate>
    </item>
    <item>
      <title>隔离森林 Sklearn 用于一维数组或列表以及如何调整超参数</title>
      <link>https://stackoverflow.com/questions/50957340/isolation-forest-sklearn-for-1d-array-or-list-and-how-to-tune-hyper-parameters</link>
      <description><![CDATA[有没有办法为 1D 数组或列表实现 sklearn 隔离森林？我遇到的所有示例都是针对 2 维或更高维度的数据。
我现在已经开发了一个具有三个特征的模型，示例代码片段如下：
# 三列的数据框
df_data = datafr[[&#39;col_A&#39;, &#39;col_B&#39;, &#39;col_C&#39;]]
w_train = page_data[:700]
w_test = page_data[700:-2]

from sklearn.ensemble import IsolationForest
# 拟合模型
clf = IsolationForest(max_samples=&#39;auto&#39;)
clf.fit(w_train)

# 使用测试集进行测试
y_pred_test = clf.predict(w_test)

我主要依赖的参考资料：IsolationForest 示例 | scikit-learn
df_data 是一个包含三列的数据框。我实际上想在 1 维或列表数据中查找异常值。
另一个问题是如何调整隔离森林模型？其中一种方法是增加污染值以减少误报。但如何使用其他参数，如 n_estimators、max_samples、max_features、versbose 等。]]></description>
      <guid>https://stackoverflow.com/questions/50957340/isolation-forest-sklearn-for-1d-array-or-list-and-how-to-tune-hyper-parameters</guid>
      <pubDate>Wed, 20 Jun 2018 21:32:17 GMT</pubDate>
    </item>
    </channel>
</rss>