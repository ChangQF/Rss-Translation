<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - 堆栈内存溢出</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 条</description>
    <lastBuildDate>Tue, 10 Dec 2024 21:17:20 GMT</lastBuildDate>
    <item>
      <title>如何加载使用（version ='latest'）框架训练的 Sagemaker XGBoost 模型？</title>
      <link>https://stackoverflow.com/questions/79269787/how-to-load-sagemaker-xgboost-model-which-was-trained-using-version-latest</link>
      <description><![CDATA[管道中有一个使用此容器创建的现有 xgboost 模型
sagemaker.image_uris.retrieve(&#39;xgboost&#39;, sagemaker.Session().boto_region_name, version=&#39;latest&#39;)
输出：&#39;{accountid}.dkr.ecr.us-east-1.amazonaws.com/xgboost:latest&#39;
我从模型工件中提取了 model.tar.gz 并加载了 xgboost-model 文件
但它给出了此错误
XGBoostError: basic_string::resize
我运行了一个 shell 脚本，使用所有可用的 XGBoost 版本加载模型，但没有任何效果。
我只想使用 model.get_score 检查特征重要性，仅此而已。 
如有任何回复，我们将不胜感激。谢谢！]]></description>
      <guid>https://stackoverflow.com/questions/79269787/how-to-load-sagemaker-xgboost-model-which-was-trained-using-version-latest</guid>
      <pubDate>Tue, 10 Dec 2024 20:57:42 GMT</pubDate>
    </item>
    <item>
      <title>奇怪的是损失法学硕士的跳高</title>
      <link>https://stackoverflow.com/questions/79269535/strangely-high-jump-in-loss-llm</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/79269535/strangely-high-jump-in-loss-llm</guid>
      <pubDate>Tue, 10 Dec 2024 19:31:33 GMT</pubDate>
    </item>
    <item>
      <title>ValueError：无法将字符串转换为浮点数：'N/'</title>
      <link>https://stackoverflow.com/questions/79268711/valueerror-could-not-convert-string-to-float-n</link>
      <description><![CDATA[我正在 Jupyter Notebook 上开展一个机器学习项目，该项目用于预测电动汽车的价格。
我在 Jupyter Notebook 上运行此单元：
p = regressor.predict(df2)

我收到此错误：
ValueError Traceback（最近一次调用最后一次）
~\AppData\Local\Temp\ipykernel_16424\818753220.py in &lt;module&gt;
----&gt; 1 p = regressor.predict(df2)

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\tree\_classes.py in predict(self, X, check_input)
465 &quot;&quot;&quot;
466 check_is_fitted(self)
--&gt; 467 X = self._validate_X_predict(X, check_input)
468 proba = self.tree_.predict(X)
469 n_samples = X.shape[0]

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\tree\_classes.py in _validate_X_predict(self, X, check_input)
431 &quot;&quot;&quot;验证预测（概率）上的训练数据。&quot;&quot;&quot;
432 if check_input:
--&gt; 433 X = self._validate_data(X, dtype=DTYPE, accept_sparse=&quot;csr&quot;, reset=False)
434 if issparse(X) and (
435 X.indices.dtype != np.intc 或 X.indptr.dtype != np.intc

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\base.py in _validate_data(self, X, y, reset, validate_separately, **check_params)
564 raise ValueError(&quot;应在 X、y 或两者上进行验证。&quot;)
565 elif not no_val_X and no_val_y:
--&gt; 566 X = check_array(X, **check_params)
567 out = X
568 elif no_val_X 且 not no_val_y:

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\utils\validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, Ensure_2d, allow_nd, Ensure_min_samples, Ensure_min_features, estimator)
744 array = array.astype(dtype, casting=&quot;unsafe&quot;, copy=False)
745 else:
--&gt; 746 array = np.asarray(array, order=order, dtype=dtype)
747 except ComplexWarning as complex_warning:
748 raise ValueError(

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\pandas\core\generic.py in __array__(self, dtype)
1991 
1992 def __array__(self, dtype: NpDtype | None = None) -&gt; np.ndarray:
-&gt; 1993 return np.asarray(self._values, dtype=dtype)
1994 
1995 def __array_wrap__(

ValueError: 无法将字符串转换为浮点数：&#39;N/&#39;

我做了什么试试？
我尝试使用以下代码：
uv = np.nanpercentile(df2[&#39;Base MSRP&#39;], [99])[0]*2
df2[&#39;Base MSRP&#39;][(df2[&#39;Base MSRP&#39;]&gt;uv)] = uv
le = preprocessing.LabelEncoder()
cols = [&#39;County&#39;, &#39;City&#39;, &#39;State&#39;, &#39;ZIP Code&#39;, &#39;Model Year&#39;, &#39;Make&#39;, &#39;Model&#39;, &#39;Electric Vehicle Type&#39;, &#39;Clean Alternative Fuel Vehicle (CAFV) Eligibility&#39;]
for col in cols:
le.fit(t[col])
df2[col] = le.transform(df2[col]) 
print(le.classes_)
regressor.fit(x, y)
p = regressor.predict(df2)

这是我的笔记本的链接：https://github.com/SteveAustin583/electric-vehicle-price-prediction-revengers/blob/main/revengers.ipynb
如何解决这个问题？]]></description>
      <guid>https://stackoverflow.com/questions/79268711/valueerror-could-not-convert-string-to-float-n</guid>
      <pubDate>Tue, 10 Dec 2024 15:00:14 GMT</pubDate>
    </item>
    <item>
      <title>从softmax输出中获取不确定性和置信度[关闭]</title>
      <link>https://stackoverflow.com/questions/79267578/get-uncertainty-and-confidence-from-softmax-output</link>
      <description><![CDATA[给定四个 3 类 softmax 输出向量，如下所示：
# 高置信度和低不确定性
A = [0.8, 0.1, 0.1]

# 高置信度和高不确定性
B = [0.8, 0.19, 0.01]

# 低置信度和低不确定性
C = [0.5, 0.25, 0.25]

# 低置信度和高不确定性
D = [0.5, 0.49, 0.01]

我希望有一个包或库或函数，其中输入是 softmax 向量，输出是不确定性和置信度，两者的范围都从 0（低不确定性/置信度） 到 1（高不确定性/置信度）
例如，返回具有置信度和不确定性的元组分别为：
compute_conf_uncert(A) -&gt; (0.8, ~0.1)
compute_conf_uncert(B) -&gt; (0.8, ~0.9)
...
]]></description>
      <guid>https://stackoverflow.com/questions/79267578/get-uncertainty-and-confidence-from-softmax-output</guid>
      <pubDate>Tue, 10 Dec 2024 08:57:42 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 Keras 组合预先训练好的层将多个模型合并为一个</title>
      <link>https://stackoverflow.com/questions/79267084/how-to-combine-multiple-models-into-one-by-combining-pre-trained-layers-using-ke</link>
      <description><![CDATA[我有多个经过预训练的分类模型。我想将它们组合成一个模型。每个模型都包含相同的 EfficentNet 和 Resnet 架构，然后是连接层和 Conv 层，然后是密集层。我想从每个模型中删除 Resnet 和 EfficentNet，并仅对整个“final_model”使用一个。之前，模型是在冻结的 EfficentNet 和 Resnet 上使用 imagenet 权重进行训练的。
我尝试过这样的解决方案，但当我尝试通过在测试数据集上运行此模型来验证权重是否相同时，它给出了随机输出。
shared_input = Input(shape=(224, 224, 3), name=&quot;shared_input&quot;)

efficient_net = EfficientNetB7(weights=&#39;imagenet&#39;, include_top=False, input_shape=(SIZE, SIZE, 3))
resnet = ResNet152(weights=&#39;imagenet&#39;, include_top=False, input_shape=(SIZE, SIZE, 3))

efficient_net = efficient_net(shared_input)
resnet = resnet(shared_input)

shared_conc = Concatenate()([efficient_net, resnet])

for i in范围（模型数量）：
模型 = 加载模型（f“model_nb_{i}.keras”）
小模型 = 模型（模型.layers[4].输入，模型.layers[-1].输出）
小模型.append（小模型（shared_conc））

组合输出 = 连接（名称=“最终输出”（轻量级输出）
最终模型 = 模型（输入=[shared_input]，输出=[组合输出]）
]]></description>
      <guid>https://stackoverflow.com/questions/79267084/how-to-combine-multiple-models-into-one-by-combining-pre-trained-layers-using-ke</guid>
      <pubDate>Tue, 10 Dec 2024 05:19:07 GMT</pubDate>
    </item>
    <item>
      <title>我想研究第三磨牙。如何通过机器学习来唯一地识别牙齿？[关闭]</title>
      <link>https://stackoverflow.com/questions/79267013/i-want-to-work-with-3rd-molar-teeth-how-can-i-uniquely-identify-the-teeth-throu</link>
      <description><![CDATA[一般来说，第三磨牙有 4 颗。我想唯一地识别每颗牙齿。如果缺少任何一颗，我也想通过机器学习来识别它。
我曾尝试注释其中一张牙齿图像。但我没有得到任何有价值的结果。]]></description>
      <guid>https://stackoverflow.com/questions/79267013/i-want-to-work-with-3rd-molar-teeth-how-can-i-uniquely-identify-the-teeth-throu</guid>
      <pubDate>Tue, 10 Dec 2024 04:26:21 GMT</pubDate>
    </item>
    <item>
      <title>处理 Llama 3.2：3b-Instruct 模型中的令牌限制问题（最多 2048 个令牌）</title>
      <link>https://stackoverflow.com/questions/79267003/handling-token-limit-issues-in-llama-3-23b-instruct-model-2048-tokens-max</link>
      <description><![CDATA[我正在使用 Llama 3.2:3b-instruct 模型，并遇到以下错误：
此模型的最大上下文长度为 2048 个标记。但是，您请求了 
2049 个标记（消息中为 1681 个，完成中为 368 个）。

我理解这是由于超出令牌限制造成的，但我想知道：

为什么存在此令牌限制，此特定限制是否有技术原因？
是否有任何最佳实践或技术可以减少令牌使用量，而不会丢失消息或完成中的关键上下文？
是否有关于此令牌限制的官方文档或开发人员更新，或者是否有在未来版本中增加此限制的潜在计划？
是否有其他人在类似场景中有效地使用此模型的替代策略（例如分块、总结或其他技巧）？
]]></description>
      <guid>https://stackoverflow.com/questions/79267003/handling-token-limit-issues-in-llama-3-23b-instruct-model-2048-tokens-max</guid>
      <pubDate>Tue, 10 Dec 2024 04:19:17 GMT</pubDate>
    </item>
    <item>
      <title>GFPGAN CoreML 模型无法正常工作</title>
      <link>https://stackoverflow.com/questions/79266909/gfpgan-coreml-model-isnt-working-correctly</link>
      <description><![CDATA[我尝试从 hoseins77/gfpgan 和 TheMurusTeam/coreml-upscaler-gfpgan 下载 GFPGAN CoreML 模型，但是当我在我的项目中使用它时，输出的图像不正确。 GFPGAN 似乎总体上工作正常，因为它可以在此处在线运行，但 CoreML 模型似乎不起作用。
以下是几个示例：


下面是运行该模型的代码。我是否需要进行一些其他配置才能使 GFPGAN CoreML 模型正常工作？
func getPhotoSharpened(_ photo: CGImage) async -&gt; CGImage? {
guard let vnModel = await getVNModelFromStorage() else { return nil }

let coreMLRequest = VNCoreMLRequest(model: vnModel)
coreMLRequest.imageCropAndScaleOption = .scaleFit

do {
let handler = VNImageRequestHandler(cgImage: photo, options: [:])
try handler.perform([coreMLRequest])
} catch {
print(&quot;Error sharpening photo: \(error)&quot;)
}

guard
let results = coreMLRequest.results as? [VNPixelBufferObservation],
let outputPixelBuffer = results.first?.pixelBuffer
else {
print(&quot;无法从模型获取输出&quot;); return nil
}

let ciImage = CIImage(cvPixelBuffer: outputPixelBuffer)
let desireAspectRatio = CGFloat(photo.width) / CGFloat(photo.height)
// cropped 函数在其他地方定义。
let croppedImage = cropped(ciImage, toAspectRatio: desireAspectRatio)

let context = CIContext()
guard let sharpenedImage = context.createCGImage(croppedImage, from: croppedImage.extent) else {
print(&quot;无法从 CIImage 创建锐化 CGImage&quot;)
return nil
}

return sharpenedImage
}

private func getVNModelFromStorage() async -&gt; VNCoreMLModel? {
do {
// gpfganFileUrl 在其他地方定义。
let mlModel = try await MLModel.load(contentsOf: gpfganFileUrl, configuration: .init())
return try VNCoreMLModel(for: mlModel)
} catch {
print(&quot;无法从文件加载 GFPGAN 模型，错误为：\(error)&quot;); return nil
}
}

]]></description>
      <guid>https://stackoverflow.com/questions/79266909/gfpgan-coreml-model-isnt-working-correctly</guid>
      <pubDate>Tue, 10 Dec 2024 02:53:43 GMT</pubDate>
    </item>
    <item>
      <title>使用 OpenCV 从正面识别和计数书籍[关闭]</title>
      <link>https://stackoverflow.com/questions/79266411/recognition-and-counting-of-books-from-front-using-opencv</link>
      <description><![CDATA[我想开发一个应用程序，让我可以计算书架上的书籍数量。如果它还可以给我一份书籍清单就好了，因为几乎所有书籍的书脊上都有名字。主要问题是要找出每一本书，有些书是同一种颜色，所以可能很难把它们挑出来。我该如何进行分割并使用像素分析来准确计数。
我还没有开始。我只是需要一些关于如何去做的想法。
(https://i.sstatic.net/fDewOa6t.jpg)(https://i.sstatic.net/7A5czzJe.jpg)]]></description>
      <guid>https://stackoverflow.com/questions/79266411/recognition-and-counting-of-books-from-front-using-opencv</guid>
      <pubDate>Mon, 09 Dec 2024 20:46:33 GMT</pubDate>
    </item>
    <item>
      <title>NotFittedError：此 DecisionTreeClassifier 实例尚未在 Jupyter 中安装[关闭]</title>
      <link>https://stackoverflow.com/questions/79266379/notfittederror-this-decisiontreeclassifier-instance-is-not-fitted-yet-in-jupyte</link>
      <description><![CDATA[我正在 Jupyter Notebook 上开展一个机器学习项目，分析最便宜的电动汽车。
我在 Jupyter Notebook 上运行此单元：
fig = plt.figure(figsize=(25,20))
tree.plot_tree(clf)
plt.show()

我收到此错误：
-------------------------------------------------------------------------------
NotFittedError Traceback（最近一次调用最后一次）
~\AppData\Local\Temp\ipykernel_8784\285030017.py in &lt;module&gt;
1 fig = plt.figure(figsize=(25,20))
----&gt; 2 tree.plot_tree(clf)
3 plt.show()

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\tree\_export.py 在 plot_tree(decision_tree、max_depth、feature_names、class_names、label、filled、impurity、node_ids、proportion、rounded、precision、ax、fontsize) 中
178 &quot;&quot;&quot;
179 
--&gt; 180 check_is_fitted(decision_tree)
181 
182 exporter = _MPLTreeExporter(

~\.conda\envs\electricvehiclepriceprediction\lib\site-packages\sklearn\utils\validation.py in check_is_fitted(estimator, attributed, msg, all_or_any)
1220 
1221 如果未安装：
-&gt; 1222 引发 NotFittedError(msg % {&quot;name&quot;: type(estimator).__name__})
1223 
1224 

NotFittedError：此 DecisionTreeClassifier 实例尚未安装。使用此估算器之前，请使用适当的参数调用“fit”。
&lt;图形尺寸 2500x2000，轴数为 0&gt;

做了什么我试试？
我尝试使用以下代码：
tree_clf = DecisionTreeClassifier(max_depth=2, random_state=42) 
tree_clf.fit(X_test, y_test)
DecisionTreeClassifier(max_depth=2, random_state=42)
clf = tree.DecisionTreeClassifier(random_state=0)
fig = plt.figure(figsize=(25,20))
tree.plot_tree(clf)
plt.show()

这是我的笔记本的链接：https://github.com/SteveAustin583/cheapest-electric-car/blob/main/ElectricCars.ipynb
如何解决此问题？]]></description>
      <guid>https://stackoverflow.com/questions/79266379/notfittederror-this-decisiontreeclassifier-instance-is-not-fitted-yet-in-jupyte</guid>
      <pubDate>Mon, 09 Dec 2024 20:32:17 GMT</pubDate>
    </item>
    <item>
      <title>时间序列运动捕捉数据的 PCA 图聚类问题</title>
      <link>https://stackoverflow.com/questions/79263104/pca-plot-clustering-issue-with-time-series-motion-capture-data</link>
      <description><![CDATA[我正在使用 PCA 对手部动作捕捉数据的时间序列数据集进行降维，并遇到了意外的聚类行为。以下是我的过程和我面临的问题的详细信息。

上下文：
我有一个使用智能手套捕捉的手部动作记录数据集，每个手指上有 4 个传感器。每个传感器提供：

位置值：X、Y、Z
旋转值：X、Y、Z、W

数据记录在单独的文件中，每个文件包含 10 次手势重复。这些重复随后被分割成单独的文件（每个文件 1 个重复），贴上标签，并合并成一个大型数据集。
在对数据进行标签编码和缩放后，我使用以下代码应用 PCA 进行降维：
# PCA 用于降维
pca_components = 3
pca = PCA(n_components=pca_components)
x_train_pca = pca.fit_transform(x_train_scaled)

为了可视化结果，我创建了一个 PCA 摘要图，其中每个数据段都表示为一个点。目标是查看每个手势的 10 个点的聚类。以下是总结 PCA 结果的代码：
# 将 PCA 结果转换为 DataFrame 以关联标签
x_train_pca_df = pd.DataFrame(x_train_pca, columns=[&#39;PC1&#39;, &#39;PC2&#39;, &#39;PC3&#39;])
x_train_pca_df[&#39;label&#39;] = y_train_data
x_train_pca_df[&#39;segment&#39;] = train_data[&#39;segment&#39;].values.ravel()

# 计算每个数据集的 PC1 和 PC2 的平均值（将每个数据集总结为一个点）
summary_train_points = x_train_pca_df.groupby([&#39;label&#39;, &#39;segment&#39;]).mean().reset_index()

以下是我用来绘制总结 PCA 的方法数据：
def plot_3d_pca_matplotlib(summary_points, title=&#39;3D PCA Plot&#39;):
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111,projection=&#39;3d&#39;)

# 对于每个唯一数据集（标签），分散点并分配图例条目
unique_labels = summary_points[&#39;label&#39;].unique()

for label in unique_labels:
# 过滤当前标签的数据
filtered_data = summary_points[summary_points[&#39;label&#39;] == label]

# 当前标签点的散点图
ax.scatter(filtered_data[&#39;PC1&#39;],
filtered_data[&#39;PC2&#39;],
filtered_data[&#39;PC3&#39;],
label=label)

ax.set_xlabel(&#39;PCA 组件 1&#39;)
ax.set_ylabel(&#39;PCA 组件 2&#39;)
ax.set_zlabel(&#39;PCA 组件 3&#39;)
ax.set_title(title)
ax.legend(title=&quot;Labels&quot;, loc=&quot;center left&quot;, bbox_to_anchor=(1.05, 0.7))

plt.subplots_adjust(left=0.05, right=0.75)
plt.show()


问题：
当我为相同手势记录一组新数据并绘制 PCA 结果时，我希望看到每个手势有 20 个点（10 个来自原始数据的点 + 10 个来自新数据的点）的聚类。
相反，PCA 图显示每个手势有两个独立的 10 个点的簇。这表明，即使手势相同，新数据也未与 PCA 空间中的原始数据对齐。

问题：
什么原因导致相同手势被分离为不同的簇？
可能与以下因素有关：

缩放过程？
传感器校准不一致？
在应用 PCA 之前是否需要对齐或对数据进行额外的预处理？
]]></description>
      <guid>https://stackoverflow.com/questions/79263104/pca-plot-clustering-issue-with-time-series-motion-capture-data</guid>
      <pubDate>Sun, 08 Dec 2024 18:31:23 GMT</pubDate>
    </item>
    <item>
      <title>保留验证集-超参数调整</title>
      <link>https://stackoverflow.com/questions/79247785/holdout-validation-set-hyperparameter-tuning</link>
      <description><![CDATA[我有一个大型数据集，我将其拆分为：

训练集 (80%)
验证集 (10%)
测试集 (10%)

在每个集合上，我执行了缺失值插补和特征选择（在训练集上训练，并复制到验证和测试集中）以避免数据泄露。
现在，我想用 Python 训练 XGBoost 模型，并希望使用训练集执行超参数调整，并使用验证集评估每个参数集。我如何使用 RandomizedSearchCV 等随机方法执行此操作，以便不运行所有参数集？
如果我是正确的，GridSearch 和 RandomizedSearchCV 仅允许交叉验证，这不是我想要的，因为将预处理的训练集拆分成几层会导致数据泄露。
我知道我可以构建一个 sklearn 管道，在其中对每个折叠进行预处理，但我想避免后一种选择。
我只能考虑像在 GridSearch 中一样运行每个参数集的代码：
from sklearn.model_selection import ParameterGrid
import xgboost as xgb

# 定义你的超参数网格
param_grid = {
&#39;max_depth&#39;: [3, 5, 7],
&#39;learning_rate&#39;: [0.01, 0.1, 0.2],
&#39;n_estimators&#39;: [100, 200, 300]
}

best_score = -1
best_params = {}

for params in ParameterGrid(param_grid):
model = xgb.XGBClassifier(**params)
model.fit(X_train, y_train)
val_score = model.score(X_val, y_val) # 或者使用更具体的指标

if val_score &gt; best_score:
best_score = val_score
best_params = params

# 使用最佳超参数训练最终模型
best_model = xgb.XGBClassifier(**best_params)
best_model.fit(X_train, y_train)
]]></description>
      <guid>https://stackoverflow.com/questions/79247785/holdout-validation-set-hyperparameter-tuning</guid>
      <pubDate>Tue, 03 Dec 2024 13:26:56 GMT</pubDate>
    </item>
    <item>
      <title>Google Colab 免费套餐：使用自定义数据集对 LLAMA 2 进行微调时代码在 51,000 个示例处停止</title>
      <link>https://stackoverflow.com/questions/76765564/google-colab-free-tier-code-stops-at-51-000-examples-while-fine-tuning-llama-2</link>
      <description><![CDATA[我在使用自定义数据集在 Google Colab 上微调 Llama 2 时遇到了一个问题。尽管我的数据集包含 61,609 个示例，但在训练过程中，代码会在 51,000 个示例时停止运行。奇怪的是，当我使用更大的数据集测试代码时，它运行得非常好。我按照 YouTube 上的教程对 Llama 2 进行了微调，您可以在下面找到原始的 Colab 和教程链接。
教程链接：YouTube 教程
原始 Colab：Google Colab
数据集链接：My Custom数据集
代码：
!pip install -q -U trl transformers accelerate git+https://github.com/huggingface/peft.git
!pip install -q datasets bitsandbytes einops wandb

from datasets import load_dataset
from transformers import AutoTokenizer, TrainingArguments
from peft import LoraConfig, get_peft_model
from trl import SFTTrainer

# 加载数据集
dataset_name = &#39;harpyerr/merged-pf&#39;
dataset = load_dataset(dataset_name, split=&quot;train&quot;)

# 定义 model_name、lora_alpha、lora_dropout、lora_r 和其他配置
model_name = &quot;your_pretrained_model_name&quot; # 用预训练模型的名称替换
lora_alpha = 16
lora_dropout = 0.1
lora_r = 64

# 初始化 tokenizer
tokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code=True)
tokenizer.pad_token = tokenizer.eos_token

# 定义 LoraConfig
peft_config = LoraConfig(
lora_alpha=lora_alpha,
lora_dropout=lora_dropout,
r=lora_r,
bias=&quot;none&quot;,
task_type=&quot;CAUSAL_LM&quot;
)

# 定义训练参数
output_dir = &quot;./results&quot;
per_device_train_batch_size = 4
gradient_accumulation_steps = 4
optim = &quot;paged_adamw_32bit&quot;
save_steps = 100
logging_steps = 10
learning_rate = 2e-4
max_grad_norm = 0.3
max_steps = 100
warmup_ratio = 0.03
lr_scheduler_type = &quot;constant&quot;

training_arguments = TrainingArguments(
output_dir=output_dir,
per_device_train_batch_size=per_device_train_batch_size,
gradient_accumulation_steps=gradient_accumulation_steps,
optim=optim,
save_steps=save_steps,
logs_steps=logging_steps,
learning_rate=learning_rate,
fp16=True,
max_grad_norm=max_grad_norm,
max_steps=max_steps,
warmup_ratio=warmup_ratio,
group_by_length=True,
lr_scheduler_type=lr_scheduler_type,
)

# 初始化 SFTTrainer
max_seq_length = 512
trainer = SFTTrainer(
model=model,
train_dataset=dataset,
peft_config=peft_config,
dataset_text_field=&quot;text&quot;,
max_seq_length=max_seq_length,
tokenizer=tokenizer,
args=training_arguments,
)

# 将所有规范化层转换为 float32
import torch
for name, module in trainer.model.named_modules():
if &quot;norm&quot; in name:
module = module.to(torch.float32)

# 开始训练
trainer.train()

我尝试使用不同且大小更大的数据集来检查问题是否特定于我的自定义数据集。令人惊讶的是，当我使用其他更大的数据集时，代码运行良好，没有任何停机问题。因此，我推断问题不在于代码或训练器，而可能与我的自定义数据集的特定特征有关。]]></description>
      <guid>https://stackoverflow.com/questions/76765564/google-colab-free-tier-code-stops-at-51-000-examples-while-fine-tuning-llama-2</guid>
      <pubDate>Tue, 25 Jul 2023 18:25:00 GMT</pubDate>
    </item>
    <item>
      <title>sklearn.exceptions.NotFittedError：此 DecisionTreeClassifier 实例尚未适合</title>
      <link>https://stackoverflow.com/questions/74928705/sklearn-exceptions-notfittederror-this-decisiontreeclassifier-instance-is-not-f</link>
      <description><![CDATA[我尝试使用 DecisionTreeClassifier 在 Python 中不使用 graphviz 的情况下使用图像数据的模式可视化决策树，但我一直收到错误
sklearn.exceptions.NotFittedError：此 DecisionTreeClassifier 实例尚未拟合。在使用此估算器之前，请使用适当的参数调用“fit”。

即使我在 google colab 和 VScode 中尝试，仍然会收到错误。我的数据集只有 2 列，即 ModusH 和 Index。
这是我的数据集示例
数据集
这是代码：
datapisang= pd.read_csv(&#39;DataModusdiperbaiki.csv&#39;) 
X= datapisang[[&#39;ModusH&#39;]] 
Y= datapisang[[&#39;Index&#39;]] 
X_train, X_test, Y_train, Y_test = train_test_split(X, Y) 
# 模型
DT_model= DecisionTreeClassifier() 
DT_model.fit(X_train,Y_train) 
DT_model.print_tree() 
data = [Modus_citra] # 模式图像 
hasilprediksi = DT_model.predict([data]) 

fn = [&#39;ModusH&#39;] 
cn = [&#39;Index&#39;] 

fig,axes = plt.subplots(nrows = 1,ncols = 1,figsize = (4,4),dpi=300)

tree.plot_tree(DT_model,
feature_names = fn, 
class_names=cn,
filled = True);

fig.savefig(&#39;imagename.png&#39;)

我尝试进行可视化，但即使使用 graphviz，每次都会出错。如何解决这个问题？]]></description>
      <guid>https://stackoverflow.com/questions/74928705/sklearn-exceptions-notfittederror-this-decisiontreeclassifier-instance-is-not-f</guid>
      <pubDate>Tue, 27 Dec 2022 11:28:09 GMT</pubDate>
    </item>
    <item>
      <title>NotFittedError：此 DecisionTreeClassifier 实例尚未适合</title>
      <link>https://stackoverflow.com/questions/70864176/notfittederror-this-decisiontreeclassifier-instance-is-not-fitted-yet</link>
      <description><![CDATA[我正在尝试运行基于决策树的模型。我尝试了以下操作：
X = df[[&#39;Quantity&#39;]]
y = df[[&#39;label&#39;]]
params = {&#39;max_depth&#39;:[2,3,4], &#39;min_samples_split&#39;:[2,3,5,10]}
clf_dt = DecisionTreeClassifier()
clf = GridSearchCV(clf_dt, param_grid=params,scoring=&#39;f1&#39;)
clf.fit(X, y)
clf_dt = DecisionTreeClassifier(clf.best_params_)

并收到此处提到的警告
FutureWarning：通过 criterion={&#39;max_depth&#39;: 2, &#39;min_samples_split&#39;: 2} 作为关键字参数。从版本 1.0（重命名为 0.25）开始，将这些作为位置参数传递将导致错误
warnings.warn(f&quot;将 {args_msg} 作为关键字参数传递。来自版本 &quot;

后来，我尝试运行下面的代码并收到错误（但我已经使用 .fit() 拟合了模型）
from sklearn import tree
tree.plot_tree(clf_dt, filled=True, feature_names = list(X.columns), class_names=[&#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;])

NotFittedError：此 DecisionTreeClassifier 实例尚未拟合。在使用此估算器之前，请使用适当的参数调用 
&#39;fit&#39;。

我该如何解决这个问题？]]></description>
      <guid>https://stackoverflow.com/questions/70864176/notfittederror-this-decisiontreeclassifier-instance-is-not-fitted-yet</guid>
      <pubDate>Wed, 26 Jan 2022 13:28:32 GMT</pubDate>
    </item>
    </channel>
</rss>