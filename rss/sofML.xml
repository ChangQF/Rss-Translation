<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>标记为机器学习的活跃问题 - Thinbug</title>
    <link>https://stackoverflow.com/questions/tagged/?tagnames=machine-learning&sort=active</link>
    <description>来自 stackoverflow.com 的最新 30 个</description>
    <lastBuildDate>Sun, 24 Dec 2023 18:15:56 GMT</lastBuildDate>
    <item>
      <title>如何使用 tff.simulation.datasets.ClientData 无参数？</title>
      <link>https://stackoverflow.com/questions/77711302/how-to-use-tff-simulation-datasets-clientdata-no-argument</link>
      <description><![CDATA[创建 TFF ClientData 对象的函数：
def create_tff_client_data(client_ids, train_data, feature_columns, target_column):
    返回 tff.simulation.datasets.ClientData(
        client_ids=client_ids,
        create_tf_dataset_for_client_fn=lambda client_id: (
            tf.data.Dataset.from_tensor_slices(
                {
                    &#39;features&#39;: train_data[train_data[&#39;client_id&#39;] == client_id][feature_columns].values,
                    &#39;标签&#39;: train_data[train_data[&#39;client_id&#39;] == client_id][target_column].values
                }
            ）
        ）
    ）


错误ClientData没有参数
我有一个使用联合学习预测员工绩效的项目，我有完整的代码来解决这部分代码的问题]]></description>
      <guid>https://stackoverflow.com/questions/77711302/how-to-use-tff-simulation-datasets-clientdata-no-argument</guid>
      <pubDate>Sun, 24 Dec 2023 17:01:52 GMT</pubDate>
    </item>
    <item>
      <title>人工智能数字预测[关闭]</title>
      <link>https://stackoverflow.com/questions/77711067/artificial-intelligence-number-prediction</link>
      <description><![CDATA[尽管它没有给出任何错误，但它会将我从外部上传的照片估计为 2。我的模型具有很高的准确率。有什么问题吗？
它在测试数据上运行良好。但是，当我从外部上传图像时，它无法正常工作。
请帮帮我
这是代码
将 numpy 导入为 np
从 sklearn.preprocessing 导入 StandardScaler
从 sklearn.decomposition 导入 PCA
从 sklearn.datasets 导入 fetch_openml
从 sklearn.linear_model 导入 LogisticRegression
从 sklearn.model_selection 导入 train_test_split
将 tkinter 导入为 tk
从 tkinter 导入 ttk, filedialog
从 PIL 导入图像、ImageTk

# 加载 MNIST 数据集
mnist = fetch_openml(&#39;mnist_784&#39;, 版本=1, 缓存=True)

# 将数据集分为训练集和测试集
train_img, test_img, train_lbl, test_lbl = train_test_split(mnist.data, mnist.target, test_size=1/7.0, random_state=0)

# 标准化数据
定标器=标准定标器()
缩放器.fit(train_img)
train_img = 缩放器.transform(train_img)
test_img = 缩放器.transform(test_img)

# 使用 PCA 降低维度（保留 95% 的方差）
期望方差 = 0.95
pca = PCA(n_components=desired_variance)
pca.fit(train_img)
train_img = pca.transform(train_img)
test_img = pca.transform(test_img)

# 训练逻辑回归模型
LogisticRegr = LogisticRegression(求解器=&#39;lbfgs&#39;, max_iter=10000)
LogisticsRegr.fit(train_img, train_lbl)

def 准备图像（图像路径）：
    尝试：
        # 打开图像
        img = Image.open(图像路径)
        
        # 将图像大小调整为 28x28
        img = img.resize((28, 28), Image.LANCZOS)
        
        # 将图像转换为灰度图
        img = img.convert(&#39;L&#39;)
        
        # 将图像转换为numpy数组
        img_array = np.array(img)
        
        # 压平图像
        img_array_flat = img_array.flatten()
        
        # 标准化图像
        img_array_flat_normalized = img_array_flat / 255.0

        返回 img_array_flat_normalized.reshape(1, -1)
    除了异常 e：
        print(f&quot;错误: {e}&quot;)
        返回无

def get_prediction(img_pca):
    尝试：
        返回logisticRegr.predict(img_pca)
    除了异常 e：
        print(f&quot;错误: {e}&quot;)
        返回无

def get_accuracy(test_img, test_lbl):
    尝试：
        返回logisticRegr.score(test_img, test_lbl)
    除了异常 e：
        print(f&quot;错误: {e}&quot;)
        返回无

def update_gui(图像路径):
    img_scaled = 准备图像（图像路径）
    
    如果 img_scaled 不是 None：
        img_pca = pca.transform(img_scaled)
        预测 = get_prediction(img_pca)
        准确度 = get_accuracy(test_img, test_lbl)

        print(f&quot;预测：{预测[0]}&quot;)
        print(f&quot;模型精度: {accuracy:.4f}&quot;)

        img = Image.open(图像路径)
        img = img.resize((28, 28), Image.LANCZOS)
        img = img.convert(&#39;L&#39;)
        img_tk = ImageTk.PhotoImage(img)
        img_label.config（图像=img_tk）
        img_label.image = img_tk

        Prediction_label.config(text=f&quot;预测：{预测[0]}&quot;)
        precision_label.config(text=f&quot;模型精度：{accuracy:.4f}&quot;)

# 图形用户界面
窗口 = tk.Tk()
window.title(&quot;数字识别界面&quot;)

img_label = ttk.Label(窗口)
img_label.grid（行=0，列=0，列跨度=2）

Prediction_label = ttk.Label(window, text=&quot;预测：&quot;)
Prediction_label.grid（行=1，列=0，列跨度=2）

precision_label = ttk.Label(window, text=&quot;模型准确度：&quot;)
precision_label.grid(行=2，列=0，列跨度=2)

def select_image():
    file_path = filedialog.askopenfilename()
    image_entry.delete(0, tk.END)
    image_entry.insert(0, 文件路径)

image_button = ttk.Button(window, text=“选择图像”, command=choose_image)
image_button.grid(行=3，列=0，pady=10)

image_entry = ttk.Entry(窗口)
image_entry.grid(行=3，列=1，pady=10)

Predict_button = ttk.Button(window, text=“预测”, command=lambda: update_gui(image_entry.get()))
Predict_button.grid(行=4，列=0，列跨度=2，pady=10)

窗口.mainloop()


让他猜对我从外面上传的照片中的数字。我找不到问题。]]></description>
      <guid>https://stackoverflow.com/questions/77711067/artificial-intelligence-number-prediction</guid>
      <pubDate>Sun, 24 Dec 2023 15:27:20 GMT</pubDate>
    </item>
    <item>
      <title>ChatGpt 出现后机器学习工具的现状 [关闭]</title>
      <link>https://stackoverflow.com/questions/77710992/current-state-of-machine-learning-tools-after-chatgpt-appearence</link>
      <description><![CDATA[我想学习机器学习，对其工作原理有基本了解，但零实践经验。想了解该地区的现状。
是的，您不能使用 ChatGPT 进行人脸检测/识别。但是 NLP（简单任务的文本处理）似乎完全被 ChatGPT 功能所覆盖。我可以将文本发送到 chat-gpt 并获得很好的分析。我在这里看到的唯一问题是它无法处理大文本。
ChatGPT 后，所有 NLP 库都会过时吗？如果不是 - 哪些任务仍然相关？]]></description>
      <guid>https://stackoverflow.com/questions/77710992/current-state-of-machine-learning-tools-after-chatgpt-appearence</guid>
      <pubDate>Sun, 24 Dec 2023 14:57:02 GMT</pubDate>
    </item>
    <item>
      <title>增加 Amazon Sagemaker 培训和评估作业的数量</title>
      <link>https://stackoverflow.com/questions/77710916/increase-the-volume-of-amazon-sagemaker-training-and-evaluation-jobs</link>
      <description><![CDATA[我正在运行带有自定义容器的 Sagemaker 管道以进行培训和评估。训练容器将通过从S3存储桶下载数据来训练模型，并将模型存储到S3存储桶中，评估容器将获取该模型，从S3存储桶下载测试数据并准备评估结果。目前，训练数据下载到容器本身中。该代码工作正常，但对于大量数据，我收到以下错误：OSError：[Errno 28]设备上没有剩余空间。我正在考虑附加一个 EBS 卷，以便可以在 EBS 卷中下载训练数据，这样我们就可以避免错误。
有人实施过类似的解决方案吗？]]></description>
      <guid>https://stackoverflow.com/questions/77710916/increase-the-volume-of-amazon-sagemaker-training-and-evaluation-jobs</guid>
      <pubDate>Sun, 24 Dec 2023 14:26:05 GMT</pubDate>
    </item>
    <item>
      <title>如何使用套索回归制作逻辑回归项目？</title>
      <link>https://stackoverflow.com/questions/77710851/how-can-i-make-a-logistic-regression-project-with-lasso-regression</link>
      <description><![CDATA[如何使用套索回归制作逻辑回归项目？
我需要做什么才能将任何逻辑回归项目转换为套索回归项目？
我应该在代码中更改哪些内容，应该如何编辑数据集？]]></description>
      <guid>https://stackoverflow.com/questions/77710851/how-can-i-make-a-logistic-regression-project-with-lasso-regression</guid>
      <pubDate>Sun, 24 Dec 2023 13:55:17 GMT</pubDate>
    </item>
    <item>
      <title>RandomizedSearchCV 中的 random_state 显着影响性能</title>
      <link>https://stackoverflow.com/questions/77710713/random-state-in-randomizedsearchcv-significantly-affects-performance</link>
      <description><![CDATA[我很难理解 random_state 参数。每当我更改代码中的 random_state 时，如下所示，它都会显着影响模型的性能。
grid_xgb = RandomizedSearchCV(模型, param_distributions=params, n_iter=25, cv=StratifiedKFold(5, shuffle=True, random_state=1000), random_state=0)

grid_xgb = RandomizedSearchCV(模型, param_distributions=params, n_iter=25, cv=StratifiedKFold(5, shuffle=True, random_state=0), random_state=1000)

grid_xgb = RandomizedSearchCV(模型, param_distributions=params, n_iter=25, cv=StratifiedKFold(5, shuffle=True, random_state=500), random_state=300)

Stack Overflow 答案中的Random_state 对准确性的贡献指出
&lt;块引用&gt;
非常重要的一点是，您不应该使用random_state来尝试提高模型的准确性。根据定义，这将导致您的模型过度拟合您的数据，并且无法泛化到未见过的数据。

我不想通过更改 random_state 数字来提高模型的准确性。但是，如果模型的性能随着不同的 random_state 值而不断变化，我就无法信任所构建的模型。
这是否意味着该模型根本不稳健？
我没想到 random_state 数字会对我的工作产生如此重大的影响。]]></description>
      <guid>https://stackoverflow.com/questions/77710713/random-state-in-randomizedsearchcv-significantly-affects-performance</guid>
      <pubDate>Sun, 24 Dec 2023 13:04:10 GMT</pubDate>
    </item>
    <item>
      <title>我可以编辑我构建的 Arima 模型来至少做出一些未来预测而不是比较真实的股票数据吗</title>
      <link>https://stackoverflow.com/questions/77710653/can-i-edit-this-arima-model-that-i-have-built-to-at-least-make-some-future-predi</link>
      <description><![CDATA[def best_arima():
    对于 selected_stocks 中的股票：
        stock_prices = selected_stocks[股票]

        # 将数据分为训练数据和测试数据
        train_size = int(len(股票价格) * 0.8)
        train_data = stock_prices[:train_size]
        test_data = stock_prices[train_size:]

        # 构建模型的训练和测试数据
        历史 = [x 代表 train_data 中的 x]
        # y = 测试数据

        # 存储股票价格预测
        预测=列表()

        # 创建 Arima 模型并将其拟合到我的 selected_stocks 数据上以进行股价预测
        arima_model = ARIMA(历史, 顺序=(1, 1, 0))
        Fitted_arima_model = arima_model.fit()
        forcasted_values = Fitted_arima_model.forecast()[0]
        预测.append（预测值）
        历史记录.append(test_data[0])

        # 滚动多个预测
        对于范围内的 i(1, len(test_data))：
            ＃ 预言
            arima_model = ARIMA(历史, 顺序=(1, 1, 0))
            Fitted_arima_model = arima_model.fit()
            forcasted_values = Fitted_arima_model.forecast()[0]
            预测.append（预测值）
            观察结果 = test_data[i]
            历史.追加（观察）

        plt.figure(figsize=(12, 8))
        plt.plot(stock_prices, color=&#39;green&#39;, label=&#39;火车股票价格&#39;)
        plt.plot(test_data.index, test_data, color=&#39;red&#39;, label=&#39;真实股价&#39;)
        plt.plot(test_data.index, 预测, color=&#39;blue&#39;, label=&#39;预测股价&#39;)
        plt.title(f&#39;股票价格预测：{stock}&#39;)
        plt.图例()
        plt.show()

        mse =mean_squared_error（测试数据，预测）
        打印（&#39;MSE：&#39;+ str（mse））
        mae =mean_absolute_error（测试数据，预测）
        打印（&#39;MAE：&#39;+ str（mae））
        rmse = math.sqrt(mean_squared_error(test_data, 预测))
        打印（&#39;均方根误差：&#39;+ str（均方根误差））

这个 Arima 模型在比较真实股票数据方面效果非常好，但它实际上并没有预测任何我想要的未来价值。
如何转换我已经构建的 Arima 函数来预测第二天或下周？
我正在考虑也许有一个 7 天的预测列表或第二天的预测，将其存储在那里，然后绘制它，因为我需要预测未来的变量，而不是仅仅与真实数据进行比较。]]></description>
      <guid>https://stackoverflow.com/questions/77710653/can-i-edit-this-arima-model-that-i-have-built-to-at-least-make-some-future-predi</guid>
      <pubDate>Sun, 24 Dec 2023 12:40:09 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 Streamlit 和 Python 在图像中的破碎区域绘制红色圆圈？</title>
      <link>https://stackoverflow.com/questions/77710624/how-to-draw-a-red-circle-on-a-fractured-area-in-an-image-using-streamlit-and-pyt</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/77710624/how-to-draw-a-red-circle-on-a-fractured-area-in-an-image-using-streamlit-and-pyt</guid>
      <pubDate>Sun, 24 Dec 2023 12:27:22 GMT</pubDate>
    </item>
    <item>
      <title>自定义梯度提升分类器实现。训练无进展</title>
      <link>https://stackoverflow.com/questions/77710582/custom-gradient-boosting-classifier-implementation-no-training-progress</link>
      <description><![CDATA[我正在尝试实现一个GradientBoostingClassifier
我从 StatQuest 视频中获取了该算法（梯度提升第 4 部分（共 4 部分）：分类详细信息）并尝试使用 numpy + sklearn.DecisionTreeRegressor 作为基本模型来实现它。
这是我的代码：
从 sklearn.tree 导入 DecisionTreeRegressor

定义 sigmoid(x):
  如果x&gt; 0:
    z = np.exp(-x)
    返回 1/(1+z)
  别的：
    z = np.exp(x)
    返回 z/(1+z)

类 GradientBoostingClassifier()：
  def __init__(self, n_estimators=20, lr=0.1):
    self.n_estimators = n_estimators
    self.lr = lr
    self.training_history = {
        “log_loss”：[]，“roc_auc”：[]，“pr_auc”：[]
    }
    self.base_learners = []

  def fit(自身, X, y):
    数据 = X.copy()
    特征=数据.列
    # 1. 使用常量值初始化模型：
    p = y.sum() / len(y)
    赔率 = p / (1-p)
    log_odds = np.log(赔率)
    数据[&#39;cur_log_odds&#39;] = log_odds
    数据[&#39;预测&#39;] = 数据[&#39;cur_log_odds&#39;].apply(sigmoid)

    self.training_history[&#39;log_loss&#39;].append( log_loss(y, data[&#39;prediction&#39;]) )
    self.training_history[&#39;roc_auc&#39;].append( roc_auc_score(y, data[&#39;预测&#39;]) )
    self.training_history[&#39;pr_auc&#39;].append(average_ precision_score(y, data[&#39;prediction&#39;]) )

    # 2. 对于 m = 1 到 M：
    for _ in tqdm(range(self.n_estimators)):
      # 2.1 计算所谓的伪残差：
      数据[&#39;残差&#39;] = (数据[&#39;预测&#39;] - y)

      # 2.2 拟合基学习器回归器来预测伪残差：
      base_learner = DecisionTreeRegressor（max_深度 = 3，min_samples_split = 2，random_state = 42）
      base_learner.fit(数据[特征],数据[&#39;残差&#39;])
      self.base_learners.append(base_learner)

      # 2.3 对于每个叶子计算其输出对数几率
      # 从回归树中获取叶子数
      数据[&#39;叶子&#39;] = base_learner.apply(数据[特征])

      # 将输出对数奇数计算为 sum(residuals) / sum(old_prediction * (1 - old_prediction))
      leafs_output = data.groupby(&#39;leaf&#39;, as_index=False).apply(
          lambda d: d[&#39;残差&#39;].sum() / (0.00001+(d[&#39;预测&#39;] * (1-d[&#39;预测&#39;]) ).sum())
      ).rename(columns={无: &#39;lambda_odds&#39;})

      数据 = data.merge(leafs_output, on=&#39;leaf&#39;)
      # 2.4 更新 current_log_odds = current_log_odds + lr*predicted_log_odds
      数据[&#39;cur_log_odds&#39;] += self.lr*data[&#39;lambda_odds&#39;]
      数据 = data.drop(&#39;lambda_odds&#39;, axis=1)

      数据[&#39;预测&#39;] = 数据[&#39;cur_log_odds&#39;].apply(sigmoid)

      self.training_history[&#39;log_loss&#39;].append( log_loss(y, data[&#39;prediction&#39;]) )
      self.training_history[&#39;roc_auc&#39;].append( roc_auc_score(y, data[&#39;预测&#39;]) )
      self.training_history[&#39;pr_auc&#39;].append(average_ precision_score(y, data[&#39;prediction&#39;]) )

    返回数据

  def Predict_proba(自身, X):
    经过

问题是，即使经过 1000 次迭代 (n_estimators = 1000)，我的 roc_auc 和 pr_auc 分数也接近随机模型给出的分数（roc_auc=0.5，pr_auc=0.29，这是正类的比例）。
我做错了什么？
即使 n_estimators = 10，sklearn GradientBoostingClassifier 实现在同一数据集上也能给出更高的分数]]></description>
      <guid>https://stackoverflow.com/questions/77710582/custom-gradient-boosting-classifier-implementation-no-training-progress</guid>
      <pubDate>Sun, 24 Dec 2023 12:11:08 GMT</pubDate>
    </item>
    <item>
      <title>交叉验证期间出错，ValueError：发现未知类别</title>
      <link>https://stackoverflow.com/questions/77710473/error-during-cross-validation-valueerror-found-unknown-categories</link>
      <description><![CDATA[我的目标是预测电影的类型。我无法真正更改代码的主要结构，因为它是一个作业。
您可以在此处找到完整代码：https://github.com/pietrosaveri/ML_movies 
您可以在此处找到数据集：https://www.kaggle。 com/datasets/akshaypawar7/millions-of-movies
我正在尝试评估 ML 算法的不同组合，看看哪一种是最好的。
我相信此错误是由创建新列的 OnceHotEncoder 转换器造成的。还有一个错误：ConvergenceWarning：达到了 max_iter，这意味着 coef_ 没有收敛。
/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/linear_model/_sag.py:350：ConvergenceWarning：达到了 max_iter，这意味着 coef_ 达到了不收敛
  警告.警告(
/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/model_selection/_validation.py:821：UserWarning：评分失败。这些参数的训练测试分区的分数将设置为 nan。细节：
回溯（最近一次调用最后一次）：
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/model_selection/_validation.py”，第 810 行，在 _score 中
    分数=记分器（估计器，X_测试，y_测试）
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/metrics/_scorer.py”，第 266 行，在 __call__ 中
    返回 self._score（部分（_cached_call，无），估计器，X，y_true，**_kwargs）
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/metrics/_scorer.py”，第 353 行，在 _score 中
    y_pred = method_caller(估计器, “预测”, X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/metrics/_scorer.py”，第 86 行，在 _cached_call 中
    结果，_ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/utils/_response.py”，第 194 行，在 _get_response_values 中
    y_pred = 预测方法(X)
             ^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/pipeline.py”，第 514 行，在预测中
    Xt = 变换.transform(Xt)
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  文件“/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/sklearn/utils/_set_output.py”，第 157 行，包装
    data_to_wrap = f(self, X, *args, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
    引发值错误（消息）
ValueError: 在转换过程中在第 0 列中发现未知类别 [&#39;fa&#39;, &#39;xx&#39;, &#39;he&#39;]

  警告.警告(
]]></description>
      <guid>https://stackoverflow.com/questions/77710473/error-during-cross-validation-valueerror-found-unknown-categories</guid>
      <pubDate>Sun, 24 Dec 2023 11:29:20 GMT</pubDate>
    </item>
    <item>
      <title>当我尝试运行管道文件时，有关 zenml 中的 mlops 的错误出现 KeyError：“不存在名称为“local”且类型为“orchestrator”的风味。”</title>
      <link>https://stackoverflow.com/questions/77710193/error-regarding-mlops-in-zenml-when-i-try-to-run-pipeline-file-im-getting-keyer</link>
      <description><![CDATA[]]></description>
      <guid>https://stackoverflow.com/questions/77710193/error-regarding-mlops-in-zenml-when-i-try-to-run-pipeline-file-im-getting-keyer</guid>
      <pubDate>Sun, 24 Dec 2023 09:42:10 GMT</pubDate>
    </item>
    <item>
      <title>Edge Impulse 物体检测中的多个标签检测，无需相应产品</title>
      <link>https://stackoverflow.com/questions/77710120/multiple-label-detections-in-edge-impulse-object-detection-without-corresponding</link>
      <description><![CDATA[我正在使用 Edge Impulse 开发一个对象检测项目。当我启动相机时，我遇到了检测到多个标签的情况，即使框架中没有相应的实际产品。这就提出了一个问题：为什么这些标签在没有产品的情况下出现？
我已尝试检查数据并优化训练参数，但未能解决此问题。这可能是由于图像中的噪声或其他一些因素造成的吗？ Edge Impulse 中是否存在可能导致此行为的特定方法或技术？
任何有关解决此问题的见解或指导将不胜感激。谢谢。


]]></description>
      <guid>https://stackoverflow.com/questions/77710120/multiple-label-detections-in-edge-impulse-object-detection-without-corresponding</guid>
      <pubDate>Sun, 24 Dec 2023 09:07:02 GMT</pubDate>
    </item>
    <item>
      <title>使用机器学习将地址文本拆分为多个组件</title>
      <link>https://stackoverflow.com/questions/77710080/split-address-text-into-components-using-machine-learning</link>
      <description><![CDATA[我有一个 CSV 文件，每一行代表地址的不同组成部分，例如城市、街道、门牌号等，然后一列在一行中包含组合地址，具有预定义的格式，例如街道房屋号码、邮政编码、城市。
我想要的是判断用户输入的地址文本的不同组成部分，例如我想知道用户是否输入了所有组件，或者只是输入了街道名称和城市等，以及这些组件的值是什么。
我可以通过机器学习技术来实现这一目标，以便我使用 CSV 文件来教导模型，这就是地址文本被分割成不同组件的方式，然后期望它根据该训练为我提供不同的组件？]]></description>
      <guid>https://stackoverflow.com/questions/77710080/split-address-text-into-components-using-machine-learning</guid>
      <pubDate>Sun, 24 Dec 2023 08:47:00 GMT</pubDate>
    </item>
    <item>
      <title>来自 sklearn 的 GridSearchCV</title>
      <link>https://stackoverflow.com/questions/76011951/gridsearchcv-from-sklearn</link>
      <description><![CDATA[使用 sklearn 中的岭回归器并使用 GridSearchCV 构建线性回归时，出现以下错误：
值错误：
估算器 Ridge() 的参数“ridge”无效。有效参数为：[&#39;alpha&#39;、&#39;copy_X&#39;、&#39;fit_intercept&#39;、&#39;max_iter&#39;、&#39;positive&#39;、&#39;random_state&#39;、&#39;solver&#39;、&#39;tol&#39;]。

我的代码如下：
X,y = Train_arr.iloc[:,:-1],Train_arr.iloc[:,-1]

从 sklearn.linear_model 导入 Ridge
从 sklearn.model_selection 导入 GridSearchCV
从 sklearn.metrics 导入mean_squared_error

山脊 = 山脊()
param_grid = {&#39;ridge__aplha&#39;: np.logspace(-10,10,100)}

ridge_regressor = GridSearchCV(ridge, param_grid,scoring=&#39;neg_mean_squared_error&#39;,cv=5, n_jobs =-1)
ridge_regressor.fit(X,y)

如果有人能强调我哪里出错了，这导致了上述值错误，我将不胜感激。
谢谢！]]></description>
      <guid>https://stackoverflow.com/questions/76011951/gridsearchcv-from-sklearn</guid>
      <pubDate>Fri, 14 Apr 2023 05:52:23 GMT</pubDate>
    </item>
    <item>
      <title>我们如何在 CNN 中选择内核？ （卷积神经网络）</title>
      <link>https://stackoverflow.com/questions/55193099/how-do-we-select-kernels-in-cnn-convolutional-neural-networks</link>
      <description><![CDATA[在输入神经网络之前，需要将内核应用于图像以进行特征提取。但是，我们如何理解特定的内核将有助于提取神经网络所需的特征。]]></description>
      <guid>https://stackoverflow.com/questions/55193099/how-do-we-select-kernels-in-cnn-convolutional-neural-networks</guid>
      <pubDate>Sat, 16 Mar 2019 03:16:37 GMT</pubDate>
    </item>
    </channel>
</rss>